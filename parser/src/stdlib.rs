//! Sigil Standard Library
//!
//! A comprehensive collection of built-in functions that leverage
//! Sigil's polysynthetic syntax and evidentiality type system.
//!
//! ## Modules
//!
//! - **core**: Essential functions (print, assert, panic)
//! - **math**: Mathematical operations including poly-cultural math
//! - **collections**: Array, map, set operations
//! - **string**: String manipulation
//! - **evidence**: Evidentiality markers and operations
//! - **iter**: Iterator-style operations for pipes
//! - **io**: File and console I/O
//! - **time**: Date, time, and measurement
//! - **random**: Random number generation
//! - **convert**: Type conversions
//! - **json**: JSON parsing and serialization
//! - **fs**: File system operations
//! - **crypto**: Hashing and encoding (SHA256, MD5, base64)
//! - **regex**: Regular expression matching
//! - **uuid**: UUID generation
//! - **system**: Environment, args, process control
//! - **stats**: Statistical functions
//! - **matrix**: Matrix operations
//! - **polycultural_text**: World-class text handling for all scripts
//!   - Script detection (Latin, Arabic, CJK, Cyrillic, etc.)
//!   - Bidirectional text (RTL/LTR)
//!   - Locale-aware case mapping (Turkish İ, German ß)
//!   - Locale-aware collation (Swedish ä vs German ä)
//!   - ICU-based segmentation (Thai, CJK word boundaries)
//!   - Transliteration to ASCII
//!   - Emoji handling
//!   - Diacritic manipulation
//! - **text_intelligence**: AI-native text analysis
//!   - String similarity (Levenshtein, Jaro-Winkler, Sørensen-Dice)
//!   - Phonetic encoding (Soundex, Metaphone, Cologne)
//!   - Language detection with confidence scores
//!   - LLM token counting (OpenAI, Claude-compatible)
//!   - Stemming (Porter, Snowball for 15+ languages)
//!   - Stopword filtering
//!   - N-grams and shingles for similarity
//!   - Fuzzy matching utilities

use crate::interpreter::{
    ActorInner, BuiltInFn, ChannelInner, Evidence, Function, Interpreter, RuntimeError, Value,
};
use std::cell::RefCell;
use std::collections::HashMap;
use std::io::Write;
use std::rc::Rc;
use std::sync::{mpsc, Arc, Mutex};
use std::thread;
use std::time::{Duration, Instant, SystemTime, UNIX_EPOCH};

// External crates for extended stdlib
use base64::{engine::general_purpose, Engine as _};
use md5::Md5;
use regex::Regex;
use sha2::{Digest, Sha256, Sha512};
use unicode_normalization::UnicodeNormalization;
use unicode_segmentation::UnicodeSegmentation;
use uuid::Uuid;

// Polycultural text processing
use deunicode::deunicode;
use icu_casemap::titlecase::TitlecaseOptions;
use icu_casemap::CaseMapper;
use icu_collator::{Collator, CollatorOptions};
use icu_locid::{LanguageIdentifier, Locale};
use icu_segmenter::{SentenceSegmenter, WordSegmenter};
use unicode_bidi::BidiInfo;
use unicode_script::{Script, UnicodeScript};
use unicode_width::UnicodeWidthStr;

// Text intelligence
use rust_stemmers::{Algorithm as StemAlgorithm, Stemmer};
use tiktoken_rs::{cl100k_base, p50k_base, r50k_base};
use whatlang::{detect, Lang, Script as WhatLangScript};

// Cryptographic primitives for experimental crypto
use rand::Rng;

/// Register all standard library functions
pub fn register_stdlib(interp: &mut Interpreter) {
    register_core(interp);
    register_math(interp);
    register_collections(interp);
    register_string(interp);
    register_evidence(interp);
    register_affect(interp);
    register_iter(interp);
    register_io(interp);
    register_time(interp);
    register_random(interp);
    register_convert(interp);
    register_cycle(interp);
    register_simd(interp);
    register_graphics_math(interp);
    register_concurrency(interp);
    // Phase 4: Extended stdlib
    register_json(interp);
    register_fs(interp);
    register_crypto(interp);
    register_regex(interp);
    register_uuid(interp);
    register_system(interp);
    register_stats(interp);
    register_matrix(interp);
    // Phase 5: Language power-ups
    register_functional(interp);
    register_benchmark(interp);
    register_itertools(interp);
    register_ranges(interp);
    register_bitwise(interp);
    register_format(interp);
    // Phase 6: Pattern matching power-ups
    register_pattern(interp);
    // Phase 7: DevEx enhancements
    register_devex(interp);
    // Phase 8: Performance optimizations
    register_soa(interp);
    register_tensor(interp);
    register_autodiff(interp);
    register_spatial(interp);
    register_physics(interp);
    // Phase 9: Differentiating features
    register_geometric_algebra(interp);
    register_dimensional(interp);
    register_ecs(interp);
    // Phase 10: Polycultural text processing
    register_polycultural_text(interp);
    // Phase 11: Text intelligence (AI-native)
    register_text_intelligence(interp);
    // Phase 12: Emotional hologram and experimental crypto
    register_hologram(interp);
    register_experimental_crypto(interp);
    // Phase 13: Multi-base encoding and cultural numerology
    register_multibase(interp);
    // Phase 14: Polycultural audio - world tuning, sacred frequencies, synthesis
    register_audio(interp);
    // Phase 15: Spirituality - divination, sacred geometry, gematria, archetypes
    register_spirituality(interp);
    // Phase 16: Polycultural color - synesthesia, cultural color systems, color spaces
    register_color(interp);
    // Phase 17: Protocol support - HTTP, gRPC, WebSocket, Kafka, AMQP, GraphQL
    register_protocol(interp);
    // Phase 18: AI Agent infrastructure - Tools, LLM, Planning, Memory, Vectors
    register_agent_tools(interp);
    register_agent_llm(interp);
    register_agent_memory(interp);
    register_agent_planning(interp);
    register_agent_vectors(interp);
    // Phase 19: Multi-Agent Coordination and Reasoning
    register_agent_swarm(interp);
    register_agent_reasoning(interp);
}

// Helper to define a builtin
fn define(
    interp: &mut Interpreter,
    name: &str,
    arity: Option<usize>,
    func: fn(&mut Interpreter, Vec<Value>) -> Result<Value, RuntimeError>,
) {
    let builtin = Value::BuiltIn(Rc::new(BuiltInFn {
        name: name.to_string(),
        arity,
        func,
    }));
    interp
        .globals
        .borrow_mut()
        .define(name.to_string(), builtin);
}

// Helper function for value equality comparison
fn values_equal_simple(a: &Value, b: &Value) -> bool {
    match (a, b) {
        (Value::Int(x), Value::Int(y)) => x == y,
        (Value::Float(x), Value::Float(y)) => (x - y).abs() < f64::EPSILON,
        (Value::Int(x), Value::Float(y)) | (Value::Float(y), Value::Int(x)) => {
            (*x as f64 - y).abs() < f64::EPSILON
        }
        (Value::Bool(x), Value::Bool(y)) => x == y,
        (Value::String(x), Value::String(y)) => x == y,
        (Value::Char(x), Value::Char(y)) => x == y,
        (Value::Null, Value::Null) => true,
        (Value::Empty, Value::Empty) => true,
        (Value::Infinity, Value::Infinity) => true,
        _ => false,
    }
}

// ============================================================================
// CORE FUNCTIONS
// ============================================================================

fn register_core(interp: &mut Interpreter) {
    // print - variadic print without newline
    define(interp, "print", None, |interp, args| {
        let output: Vec<String> = args.iter().map(|v| format!("{}", v)).collect();
        let line = output.join(" ");
        print!("{}", line);
        std::io::stdout().flush().ok();
        interp.output.push(line);
        Ok(Value::Null)
    });

    // println - print with newline
    define(interp, "println", None, |interp, args| {
        let output: Vec<String> = args.iter().map(|v| format!("{}", v)).collect();
        let line = output.join(" ");
        println!("{}", line);
        interp.output.push(line);
        Ok(Value::Null)
    });

    // dbg - debug print with source info
    define(interp, "dbg", Some(1), |interp, args| {
        let output = format!("[DEBUG] {:?}", args[0]);
        println!("{}", output);
        interp.output.push(output);
        Ok(args[0].clone())
    });

    // type_of - get type name
    define(interp, "type_of", Some(1), |_, args| {
        let type_name = match &args[0] {
            Value::Null => "null",
            Value::Bool(_) => "bool",
            Value::Int(_) => "i64",
            Value::Float(_) => "f64",
            Value::String(_) => "str",
            Value::Char(_) => "char",
            Value::Array(_) => "array",
            Value::Tuple(_) => "tuple",
            Value::Struct { name, .. } => name,
            Value::Variant { enum_name, .. } => enum_name,
            Value::Function(_) => "fn",
            Value::BuiltIn(_) => "builtin",
            Value::Ref(_) => "ref",
            Value::Infinity => "infinity",
            Value::Empty => "empty",
            Value::Evidential { evidence, .. } => match evidence {
                Evidence::Known => "known",
                Evidence::Uncertain => "uncertain",
                Evidence::Reported => "reported",
                Evidence::Paradox => "paradox",
            },
            Value::Affective { .. } => "affective",
            Value::Map(_) => "map",
            Value::Set(_) => "set",
            Value::Channel(_) => "channel",
            Value::ThreadHandle(_) => "thread",
            Value::Actor(_) => "actor",
            Value::Future(_) => "future",
        };
        Ok(Value::String(Rc::new(type_name.to_string())))
    });

    // assert - assertion with optional message
    define(interp, "assert", None, |_, args| {
        if args.is_empty() {
            return Err(RuntimeError::new("assert() requires at least one argument"));
        }
        let condition = match &args[0] {
            Value::Bool(b) => *b,
            _ => return Err(RuntimeError::new("assert() condition must be bool")),
        };
        if !condition {
            let msg = if args.len() > 1 {
                format!("{}", args[1])
            } else {
                "assertion failed".to_string()
            };
            return Err(RuntimeError::new(format!("Assertion failed: {}", msg)));
        }
        Ok(Value::Null)
    });

    // panic - abort execution with message
    define(interp, "panic", None, |_, args| {
        let msg = if args.is_empty() {
            "explicit panic".to_string()
        } else {
            args.iter()
                .map(|v| format!("{}", v))
                .collect::<Vec<_>>()
                .join(" ")
        };
        Err(RuntimeError::new(format!("PANIC: {}", msg)))
    });

    // todo - mark unimplemented code
    define(interp, "todo", None, |_, args| {
        let msg = if args.is_empty() {
            "not yet implemented".to_string()
        } else {
            format!("{}", args[0])
        };
        Err(RuntimeError::new(format!("TODO: {}", msg)))
    });

    // unreachable - mark code that should never execute
    define(interp, "unreachable", None, |_, args| {
        let msg = if args.is_empty() {
            "entered unreachable code".to_string()
        } else {
            format!("{}", args[0])
        };
        Err(RuntimeError::new(format!("UNREACHABLE: {}", msg)))
    });

    // clone - deep clone a value
    define(interp, "clone", Some(1), |_, args| Ok(deep_clone(&args[0])));

    // identity - return value unchanged (useful in pipes)
    define(interp, "id", Some(1), |_, args| Ok(args[0].clone()));

    // default - return default value for a type
    define(interp, "default", Some(1), |_, args| {
        let type_name = match &args[0] {
            Value::String(s) => s.as_str(),
            _ => return Err(RuntimeError::new("default() requires type name string")),
        };
        match type_name {
            "bool" => Ok(Value::Bool(false)),
            "i64" | "int" => Ok(Value::Int(0)),
            "f64" | "float" => Ok(Value::Float(0.0)),
            "str" | "string" => Ok(Value::String(Rc::new(String::new()))),
            "array" => Ok(Value::Array(Rc::new(RefCell::new(Vec::new())))),
            _ => Err(RuntimeError::new(format!(
                "no default for type: {}",
                type_name
            ))),
        }
    });
}

// Deep clone helper
fn deep_clone(value: &Value) -> Value {
    match value {
        Value::Array(arr) => {
            let cloned: Vec<Value> = arr.borrow().iter().map(deep_clone).collect();
            Value::Array(Rc::new(RefCell::new(cloned)))
        }
        Value::Struct { name, fields } => {
            let cloned: HashMap<String, Value> = fields
                .borrow()
                .iter()
                .map(|(k, v)| (k.clone(), deep_clone(v)))
                .collect();
            Value::Struct {
                name: name.clone(),
                fields: Rc::new(RefCell::new(cloned)),
            }
        }
        Value::Evidential { value, evidence } => Value::Evidential {
            value: Box::new(deep_clone(value)),
            evidence: *evidence,
        },
        other => other.clone(),
    }
}

// ============================================================================
// MATH FUNCTIONS
// ============================================================================

fn register_math(interp: &mut Interpreter) {
    // Basic math
    define(interp, "abs", Some(1), |_, args| match &args[0] {
        Value::Int(n) => Ok(Value::Int(n.abs())),
        Value::Float(n) => Ok(Value::Float(n.abs())),
        _ => Err(RuntimeError::new("abs() requires number")),
    });

    define(interp, "neg", Some(1), |_, args| match &args[0] {
        Value::Int(n) => Ok(Value::Int(-n)),
        Value::Float(n) => Ok(Value::Float(-n)),
        _ => Err(RuntimeError::new("neg() requires number")),
    });

    define(interp, "sqrt", Some(1), |_, args| match &args[0] {
        Value::Int(n) => Ok(Value::Float((*n as f64).sqrt())),
        Value::Float(n) => Ok(Value::Float(n.sqrt())),
        _ => Err(RuntimeError::new("sqrt() requires number")),
    });

    define(interp, "cbrt", Some(1), |_, args| match &args[0] {
        Value::Int(n) => Ok(Value::Float((*n as f64).cbrt())),
        Value::Float(n) => Ok(Value::Float(n.cbrt())),
        _ => Err(RuntimeError::new("cbrt() requires number")),
    });

    define(interp, "pow", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::Int(base), Value::Int(exp)) => {
                if *exp >= 0 {
                    Ok(Value::Int(base.pow(*exp as u32)))
                } else {
                    Ok(Value::Float((*base as f64).powi(*exp as i32)))
                }
            }
            (Value::Float(base), Value::Int(exp)) => Ok(Value::Float(base.powi(*exp as i32))),
            (Value::Float(base), Value::Float(exp)) => Ok(Value::Float(base.powf(*exp))),
            (Value::Int(base), Value::Float(exp)) => Ok(Value::Float((*base as f64).powf(*exp))),
            _ => Err(RuntimeError::new("pow() requires numbers")),
        }
    });

    define(interp, "exp", Some(1), |_, args| match &args[0] {
        Value::Int(n) => Ok(Value::Float((*n as f64).exp())),
        Value::Float(n) => Ok(Value::Float(n.exp())),
        _ => Err(RuntimeError::new("exp() requires number")),
    });

    define(interp, "ln", Some(1), |_, args| match &args[0] {
        Value::Int(n) => Ok(Value::Float((*n as f64).ln())),
        Value::Float(n) => Ok(Value::Float(n.ln())),
        _ => Err(RuntimeError::new("ln() requires number")),
    });

    define(interp, "log", Some(2), |_, args| {
        let (value, base) = match (&args[0], &args[1]) {
            (Value::Int(v), Value::Int(b)) => (*v as f64, *b as f64),
            (Value::Float(v), Value::Int(b)) => (*v, *b as f64),
            (Value::Int(v), Value::Float(b)) => (*v as f64, *b),
            (Value::Float(v), Value::Float(b)) => (*v, *b),
            _ => return Err(RuntimeError::new("log() requires numbers")),
        };
        Ok(Value::Float(value.log(base)))
    });

    define(interp, "log10", Some(1), |_, args| match &args[0] {
        Value::Int(n) => Ok(Value::Float((*n as f64).log10())),
        Value::Float(n) => Ok(Value::Float(n.log10())),
        _ => Err(RuntimeError::new("log10() requires number")),
    });

    define(interp, "log2", Some(1), |_, args| match &args[0] {
        Value::Int(n) => Ok(Value::Float((*n as f64).log2())),
        Value::Float(n) => Ok(Value::Float(n.log2())),
        _ => Err(RuntimeError::new("log2() requires number")),
    });

    // Trigonometry
    define(interp, "sin", Some(1), |_, args| match &args[0] {
        Value::Int(n) => Ok(Value::Float((*n as f64).sin())),
        Value::Float(n) => Ok(Value::Float(n.sin())),
        _ => Err(RuntimeError::new("sin() requires number")),
    });

    define(interp, "cos", Some(1), |_, args| match &args[0] {
        Value::Int(n) => Ok(Value::Float((*n as f64).cos())),
        Value::Float(n) => Ok(Value::Float(n.cos())),
        _ => Err(RuntimeError::new("cos() requires number")),
    });

    define(interp, "tan", Some(1), |_, args| match &args[0] {
        Value::Int(n) => Ok(Value::Float((*n as f64).tan())),
        Value::Float(n) => Ok(Value::Float(n.tan())),
        _ => Err(RuntimeError::new("tan() requires number")),
    });

    define(interp, "asin", Some(1), |_, args| match &args[0] {
        Value::Int(n) => Ok(Value::Float((*n as f64).asin())),
        Value::Float(n) => Ok(Value::Float(n.asin())),
        _ => Err(RuntimeError::new("asin() requires number")),
    });

    define(interp, "acos", Some(1), |_, args| match &args[0] {
        Value::Int(n) => Ok(Value::Float((*n as f64).acos())),
        Value::Float(n) => Ok(Value::Float(n.acos())),
        _ => Err(RuntimeError::new("acos() requires number")),
    });

    define(interp, "atan", Some(1), |_, args| match &args[0] {
        Value::Int(n) => Ok(Value::Float((*n as f64).atan())),
        Value::Float(n) => Ok(Value::Float(n.atan())),
        _ => Err(RuntimeError::new("atan() requires number")),
    });

    define(interp, "atan2", Some(2), |_, args| {
        let (y, x) = match (&args[0], &args[1]) {
            (Value::Int(y), Value::Int(x)) => (*y as f64, *x as f64),
            (Value::Float(y), Value::Int(x)) => (*y, *x as f64),
            (Value::Int(y), Value::Float(x)) => (*y as f64, *x),
            (Value::Float(y), Value::Float(x)) => (*y, *x),
            _ => return Err(RuntimeError::new("atan2() requires numbers")),
        };
        Ok(Value::Float(y.atan2(x)))
    });

    // Hyperbolic
    define(interp, "sinh", Some(1), |_, args| match &args[0] {
        Value::Int(n) => Ok(Value::Float((*n as f64).sinh())),
        Value::Float(n) => Ok(Value::Float(n.sinh())),
        _ => Err(RuntimeError::new("sinh() requires number")),
    });

    define(interp, "cosh", Some(1), |_, args| match &args[0] {
        Value::Int(n) => Ok(Value::Float((*n as f64).cosh())),
        Value::Float(n) => Ok(Value::Float(n.cosh())),
        _ => Err(RuntimeError::new("cosh() requires number")),
    });

    define(interp, "tanh", Some(1), |_, args| match &args[0] {
        Value::Int(n) => Ok(Value::Float((*n as f64).tanh())),
        Value::Float(n) => Ok(Value::Float(n.tanh())),
        _ => Err(RuntimeError::new("tanh() requires number")),
    });

    // Rounding
    define(interp, "floor", Some(1), |_, args| match &args[0] {
        Value::Int(n) => Ok(Value::Int(*n)),
        Value::Float(n) => Ok(Value::Int(n.floor() as i64)),
        _ => Err(RuntimeError::new("floor() requires number")),
    });

    define(interp, "ceil", Some(1), |_, args| match &args[0] {
        Value::Int(n) => Ok(Value::Int(*n)),
        Value::Float(n) => Ok(Value::Int(n.ceil() as i64)),
        _ => Err(RuntimeError::new("ceil() requires number")),
    });

    define(interp, "round", Some(1), |_, args| match &args[0] {
        Value::Int(n) => Ok(Value::Int(*n)),
        Value::Float(n) => Ok(Value::Int(n.round() as i64)),
        _ => Err(RuntimeError::new("round() requires number")),
    });

    define(interp, "trunc", Some(1), |_, args| match &args[0] {
        Value::Int(n) => Ok(Value::Int(*n)),
        Value::Float(n) => Ok(Value::Int(n.trunc() as i64)),
        _ => Err(RuntimeError::new("trunc() requires number")),
    });

    define(interp, "fract", Some(1), |_, args| match &args[0] {
        Value::Int(_) => Ok(Value::Float(0.0)),
        Value::Float(n) => Ok(Value::Float(n.fract())),
        _ => Err(RuntimeError::new("fract() requires number")),
    });

    // Min/Max/Clamp
    define(interp, "min", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::Int(a), Value::Int(b)) => Ok(Value::Int(*a.min(b))),
            (Value::Float(a), Value::Float(b)) => Ok(Value::Float(a.min(*b))),
            (Value::Int(a), Value::Float(b)) => Ok(Value::Float((*a as f64).min(*b))),
            (Value::Float(a), Value::Int(b)) => Ok(Value::Float(a.min(*b as f64))),
            _ => Err(RuntimeError::new("min() requires numbers")),
        }
    });

    define(interp, "max", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::Int(a), Value::Int(b)) => Ok(Value::Int(*a.max(b))),
            (Value::Float(a), Value::Float(b)) => Ok(Value::Float(a.max(*b))),
            (Value::Int(a), Value::Float(b)) => Ok(Value::Float((*a as f64).max(*b))),
            (Value::Float(a), Value::Int(b)) => Ok(Value::Float(a.max(*b as f64))),
            _ => Err(RuntimeError::new("max() requires numbers")),
        }
    });

    define(interp, "clamp", Some(3), |_, args| {
        match (&args[0], &args[1], &args[2]) {
            (Value::Int(val), Value::Int(min), Value::Int(max)) => {
                Ok(Value::Int(*val.max(min).min(max)))
            }
            (Value::Float(val), Value::Float(min), Value::Float(max)) => {
                Ok(Value::Float(val.max(*min).min(*max)))
            }
            _ => Err(RuntimeError::new("clamp() requires matching number types")),
        }
    });

    // Sign
    define(interp, "sign", Some(1), |_, args| match &args[0] {
        Value::Int(n) => Ok(Value::Int(n.signum())),
        Value::Float(n) => Ok(Value::Float(if *n > 0.0 {
            1.0
        } else if *n < 0.0 {
            -1.0
        } else {
            0.0
        })),
        _ => Err(RuntimeError::new("sign() requires number")),
    });

    // Constants
    define(interp, "PI", Some(0), |_, _| {
        Ok(Value::Float(std::f64::consts::PI))
    });
    define(interp, "E", Some(0), |_, _| {
        Ok(Value::Float(std::f64::consts::E))
    });
    define(interp, "TAU", Some(0), |_, _| {
        Ok(Value::Float(std::f64::consts::TAU))
    });
    define(interp, "PHI", Some(0), |_, _| {
        Ok(Value::Float(1.618033988749895))
    }); // Golden ratio

    // GCD/LCM
    define(interp, "gcd", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::Int(a), Value::Int(b)) => Ok(Value::Int(gcd(*a, *b))),
            _ => Err(RuntimeError::new("gcd() requires integers")),
        }
    });

    define(interp, "lcm", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::Int(a), Value::Int(b)) => {
                let g = gcd(*a, *b);
                Ok(Value::Int((a * b).abs() / g))
            }
            _ => Err(RuntimeError::new("lcm() requires integers")),
        }
    });

    // Factorial
    define(interp, "factorial", Some(1), |_, args| match &args[0] {
        Value::Int(n) if *n >= 0 => {
            let mut result: i64 = 1;
            for i in 2..=(*n as u64) {
                result = result.saturating_mul(i as i64);
            }
            Ok(Value::Int(result))
        }
        Value::Int(_) => Err(RuntimeError::new(
            "factorial() requires non-negative integer",
        )),
        _ => Err(RuntimeError::new("factorial() requires integer")),
    });

    // Is checks
    define(interp, "is_nan", Some(1), |_, args| match &args[0] {
        Value::Float(n) => Ok(Value::Bool(n.is_nan())),
        Value::Int(_) => Ok(Value::Bool(false)),
        _ => Err(RuntimeError::new("is_nan() requires number")),
    });

    define(interp, "is_infinite", Some(1), |_, args| match &args[0] {
        Value::Float(n) => Ok(Value::Bool(n.is_infinite())),
        Value::Int(_) => Ok(Value::Bool(false)),
        Value::Infinity => Ok(Value::Bool(true)),
        _ => Err(RuntimeError::new("is_infinite() requires number")),
    });

    define(interp, "is_finite", Some(1), |_, args| match &args[0] {
        Value::Float(n) => Ok(Value::Bool(n.is_finite())),
        Value::Int(_) => Ok(Value::Bool(true)),
        Value::Infinity => Ok(Value::Bool(false)),
        _ => Err(RuntimeError::new("is_finite() requires number")),
    });

    define(interp, "is_even", Some(1), |_, args| match &args[0] {
        Value::Int(n) => Ok(Value::Bool(n % 2 == 0)),
        _ => Err(RuntimeError::new("is_even() requires integer")),
    });

    define(interp, "is_odd", Some(1), |_, args| match &args[0] {
        Value::Int(n) => Ok(Value::Bool(n % 2 != 0)),
        _ => Err(RuntimeError::new("is_odd() requires integer")),
    });

    define(interp, "is_prime", Some(1), |_, args| match &args[0] {
        Value::Int(n) => Ok(Value::Bool(is_prime(*n))),
        _ => Err(RuntimeError::new("is_prime() requires integer")),
    });
}

fn gcd(mut a: i64, mut b: i64) -> i64 {
    a = a.abs();
    b = b.abs();
    while b != 0 {
        let t = b;
        b = a % b;
        a = t;
    }
    a
}

fn is_prime(n: i64) -> bool {
    if n < 2 {
        return false;
    }
    if n == 2 {
        return true;
    }
    if n % 2 == 0 {
        return false;
    }
    let sqrt = (n as f64).sqrt() as i64;
    for i in (3..=sqrt).step_by(2) {
        if n % i == 0 {
            return false;
        }
    }
    true
}

// ============================================================================
// COLLECTION FUNCTIONS
// ============================================================================

fn register_collections(interp: &mut Interpreter) {
    // Basic operations
    define(interp, "len", Some(1), |_, args| match &args[0] {
        Value::Array(arr) => Ok(Value::Int(arr.borrow().len() as i64)),
        Value::String(s) => Ok(Value::Int(s.chars().count() as i64)),
        Value::Tuple(t) => Ok(Value::Int(t.len() as i64)),
        Value::Map(m) => Ok(Value::Int(m.borrow().len() as i64)),
        Value::Set(s) => Ok(Value::Int(s.borrow().len() as i64)),
        _ => Err(RuntimeError::new(
            "len() requires array, string, tuple, map, or set",
        )),
    });

    define(interp, "is_empty", Some(1), |_, args| match &args[0] {
        Value::Array(arr) => Ok(Value::Bool(arr.borrow().is_empty())),
        Value::String(s) => Ok(Value::Bool(s.is_empty())),
        Value::Tuple(t) => Ok(Value::Bool(t.is_empty())),
        Value::Map(m) => Ok(Value::Bool(m.borrow().is_empty())),
        Value::Set(s) => Ok(Value::Bool(s.borrow().is_empty())),
        _ => Err(RuntimeError::new("is_empty() requires collection")),
    });

    // Array operations
    define(interp, "push", Some(2), |_, args| match &args[0] {
        Value::Array(arr) => {
            arr.borrow_mut().push(args[1].clone());
            Ok(Value::Null)
        }
        _ => Err(RuntimeError::new("push() requires array")),
    });

    define(interp, "pop", Some(1), |_, args| match &args[0] {
        Value::Array(arr) => arr
            .borrow_mut()
            .pop()
            .ok_or_else(|| RuntimeError::new("pop() on empty array")),
        _ => Err(RuntimeError::new("pop() requires array")),
    });

    define(interp, "first", Some(1), |_, args| match &args[0] {
        Value::Array(arr) => arr
            .borrow()
            .first()
            .cloned()
            .ok_or_else(|| RuntimeError::new("first() on empty array")),
        Value::Tuple(t) => t
            .first()
            .cloned()
            .ok_or_else(|| RuntimeError::new("first() on empty tuple")),
        _ => Err(RuntimeError::new("first() requires array or tuple")),
    });

    define(interp, "last", Some(1), |_, args| match &args[0] {
        Value::Array(arr) => arr
            .borrow()
            .last()
            .cloned()
            .ok_or_else(|| RuntimeError::new("last() on empty array")),
        Value::Tuple(t) => t
            .last()
            .cloned()
            .ok_or_else(|| RuntimeError::new("last() on empty tuple")),
        _ => Err(RuntimeError::new("last() requires array or tuple")),
    });

    // μ (mu) - middle/median element
    define(interp, "middle", Some(1), |_, args| match &args[0] {
        Value::Array(arr) => {
            let arr = arr.borrow();
            if arr.is_empty() {
                return Err(RuntimeError::new("middle() on empty array"));
            }
            let mid = arr.len() / 2;
            Ok(arr[mid].clone())
        }
        Value::Tuple(t) => {
            if t.is_empty() {
                return Err(RuntimeError::new("middle() on empty tuple"));
            }
            let mid = t.len() / 2;
            Ok(t[mid].clone())
        }
        _ => Err(RuntimeError::new("middle() requires array or tuple")),
    });

    // χ (chi) - random choice from collection
    define(interp, "choice", Some(1), |_, args| {
        use std::time::{SystemTime, UNIX_EPOCH};
        match &args[0] {
            Value::Array(arr) => {
                let arr = arr.borrow();
                if arr.is_empty() {
                    return Err(RuntimeError::new("choice() on empty array"));
                }
                let seed = SystemTime::now()
                    .duration_since(UNIX_EPOCH)
                    .unwrap_or(std::time::Duration::ZERO)
                    .as_nanos() as u64;
                let idx = ((seed.wrapping_mul(1103515245).wrapping_add(12345)) >> 16) as usize
                    % arr.len();
                Ok(arr[idx].clone())
            }
            Value::Tuple(t) => {
                if t.is_empty() {
                    return Err(RuntimeError::new("choice() on empty tuple"));
                }
                let seed = SystemTime::now()
                    .duration_since(UNIX_EPOCH)
                    .unwrap_or(std::time::Duration::ZERO)
                    .as_nanos() as u64;
                let idx =
                    ((seed.wrapping_mul(1103515245).wrapping_add(12345)) >> 16) as usize % t.len();
                Ok(t[idx].clone())
            }
            _ => Err(RuntimeError::new("choice() requires array or tuple")),
        }
    });

    // ν (nu) - nth element (alias for get with better semantics)
    define(interp, "nth", Some(2), |_, args| {
        let n = match &args[1] {
            Value::Int(i) => *i,
            _ => return Err(RuntimeError::new("nth() index must be integer")),
        };
        match &args[0] {
            Value::Array(arr) => {
                let arr = arr.borrow();
                if n < 0 || n as usize >= arr.len() {
                    return Err(RuntimeError::new("nth() index out of bounds"));
                }
                Ok(arr[n as usize].clone())
            }
            Value::Tuple(t) => {
                if n < 0 || n as usize >= t.len() {
                    return Err(RuntimeError::new("nth() index out of bounds"));
                }
                Ok(t[n as usize].clone())
            }
            _ => Err(RuntimeError::new("nth() requires array or tuple")),
        }
    });

    // ξ (xi) - next: pop and return first element (advances iterator)
    define(interp, "next", Some(1), |_, args| match &args[0] {
        Value::Array(arr) => {
            let mut arr = arr.borrow_mut();
            if arr.is_empty() {
                return Err(RuntimeError::new("next() on empty array"));
            }
            Ok(arr.remove(0))
        }
        _ => Err(RuntimeError::new("next() requires array")),
    });

    // peek - look at first element without consuming (for iterators)
    define(interp, "peek", Some(1), |_, args| match &args[0] {
        Value::Array(arr) => arr
            .borrow()
            .first()
            .cloned()
            .ok_or_else(|| RuntimeError::new("peek() on empty array")),
        _ => Err(RuntimeError::new("peek() requires array")),
    });

    define(interp, "get", Some(2), |_, args| {
        let index = match &args[1] {
            Value::Int(i) => *i,
            _ => return Err(RuntimeError::new("get() index must be integer")),
        };
        match &args[0] {
            Value::Array(arr) => {
                let arr = arr.borrow();
                let idx = if index < 0 {
                    arr.len() as i64 + index
                } else {
                    index
                } as usize;
                arr.get(idx)
                    .cloned()
                    .ok_or_else(|| RuntimeError::new("index out of bounds"))
            }
            Value::Tuple(t) => {
                let idx = if index < 0 {
                    t.len() as i64 + index
                } else {
                    index
                } as usize;
                t.get(idx)
                    .cloned()
                    .ok_or_else(|| RuntimeError::new("index out of bounds"))
            }
            _ => Err(RuntimeError::new("get() requires array or tuple")),
        }
    });

    define(interp, "set", Some(3), |_, args| {
        let index = match &args[1] {
            Value::Int(i) => *i as usize,
            _ => return Err(RuntimeError::new("set() index must be integer")),
        };
        match &args[0] {
            Value::Array(arr) => {
                let mut arr = arr.borrow_mut();
                if index >= arr.len() {
                    return Err(RuntimeError::new("index out of bounds"));
                }
                arr[index] = args[2].clone();
                Ok(Value::Null)
            }
            _ => Err(RuntimeError::new("set() requires array")),
        }
    });

    define(interp, "insert", Some(3), |_, args| {
        let index = match &args[1] {
            Value::Int(i) => *i as usize,
            _ => return Err(RuntimeError::new("insert() index must be integer")),
        };
        match &args[0] {
            Value::Array(arr) => {
                let mut arr = arr.borrow_mut();
                if index > arr.len() {
                    return Err(RuntimeError::new("index out of bounds"));
                }
                arr.insert(index, args[2].clone());
                Ok(Value::Null)
            }
            _ => Err(RuntimeError::new("insert() requires array")),
        }
    });

    define(interp, "remove", Some(2), |_, args| {
        let index = match &args[1] {
            Value::Int(i) => *i as usize,
            _ => return Err(RuntimeError::new("remove() index must be integer")),
        };
        match &args[0] {
            Value::Array(arr) => {
                let mut arr = arr.borrow_mut();
                if index >= arr.len() {
                    return Err(RuntimeError::new("index out of bounds"));
                }
                Ok(arr.remove(index))
            }
            _ => Err(RuntimeError::new("remove() requires array")),
        }
    });

    define(interp, "clear", Some(1), |_, args| match &args[0] {
        Value::Array(arr) => {
            arr.borrow_mut().clear();
            Ok(Value::Null)
        }
        _ => Err(RuntimeError::new("clear() requires array")),
    });

    // Searching
    define(interp, "contains", Some(2), |_, args| match &args[0] {
        Value::Array(arr) => Ok(Value::Bool(
            arr.borrow().iter().any(|v| values_equal(v, &args[1])),
        )),
        Value::String(s) => match &args[1] {
            Value::String(sub) => Ok(Value::Bool(s.contains(sub.as_str()))),
            Value::Char(c) => Ok(Value::Bool(s.contains(*c))),
            _ => Err(RuntimeError::new(
                "string contains() requires string or char",
            )),
        },
        _ => Err(RuntimeError::new("contains() requires array or string")),
    });

    define(interp, "index_of", Some(2), |_, args| match &args[0] {
        Value::Array(arr) => {
            let idx = arr.borrow().iter().position(|v| values_equal(v, &args[1]));
            match idx {
                Some(i) => Ok(Value::Int(i as i64)),
                None => Ok(Value::Int(-1)),
            }
        }
        Value::String(s) => match &args[1] {
            Value::String(sub) => match s.find(sub.as_str()) {
                Some(i) => Ok(Value::Int(i as i64)),
                None => Ok(Value::Int(-1)),
            },
            Value::Char(c) => match s.find(*c) {
                Some(i) => Ok(Value::Int(i as i64)),
                None => Ok(Value::Int(-1)),
            },
            _ => Err(RuntimeError::new(
                "string index_of() requires string or char",
            )),
        },
        _ => Err(RuntimeError::new("index_of() requires array or string")),
    });

    // Transformations
    define(interp, "reverse", Some(1), |_, args| match &args[0] {
        Value::Array(arr) => {
            let mut reversed: Vec<Value> = arr.borrow().clone();
            reversed.reverse();
            Ok(Value::Array(Rc::new(RefCell::new(reversed))))
        }
        Value::String(s) => {
            let reversed: String = s.chars().rev().collect();
            Ok(Value::String(Rc::new(reversed)))
        }
        _ => Err(RuntimeError::new("reverse() requires array or string")),
    });

    define(interp, "sort", Some(1), |_, args| match &args[0] {
        Value::Array(arr) => {
            let mut sorted: Vec<Value> = arr.borrow().clone();
            sorted.sort_by(compare_values);
            Ok(Value::Array(Rc::new(RefCell::new(sorted))))
        }
        _ => Err(RuntimeError::new("sort() requires array")),
    });

    define(interp, "sort_desc", Some(1), |_, args| match &args[0] {
        Value::Array(arr) => {
            let mut sorted: Vec<Value> = arr.borrow().clone();
            sorted.sort_by(|a, b| compare_values(b, a));
            Ok(Value::Array(Rc::new(RefCell::new(sorted))))
        }
        _ => Err(RuntimeError::new("sort_desc() requires array")),
    });

    define(interp, "unique", Some(1), |_, args| match &args[0] {
        Value::Array(arr) => {
            let arr = arr.borrow();
            let mut seen = Vec::new();
            let unique: Vec<Value> = arr
                .iter()
                .filter(|v| {
                    if seen.iter().any(|s| values_equal(s, v)) {
                        false
                    } else {
                        seen.push((*v).clone());
                        true
                    }
                })
                .cloned()
                .collect();
            Ok(Value::Array(Rc::new(RefCell::new(unique))))
        }
        _ => Err(RuntimeError::new("unique() requires array")),
    });

    define(interp, "flatten", Some(1), |_, args| match &args[0] {
        Value::Array(arr) => {
            let mut flattened = Vec::new();
            for item in arr.borrow().iter() {
                match item {
                    Value::Array(inner) => flattened.extend(inner.borrow().clone()),
                    other => flattened.push(other.clone()),
                }
            }
            Ok(Value::Array(Rc::new(RefCell::new(flattened))))
        }
        _ => Err(RuntimeError::new("flatten() requires array")),
    });

    // Combining
    define(interp, "concat", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::Array(a), Value::Array(b)) => {
                let mut result = a.borrow().clone();
                result.extend(b.borrow().clone());
                Ok(Value::Array(Rc::new(RefCell::new(result))))
            }
            (Value::String(a), Value::String(b)) => {
                Ok(Value::String(Rc::new(format!("{}{}", a, b))))
            }
            _ => Err(RuntimeError::new(
                "concat() requires two arrays or two strings",
            )),
        }
    });

    define(interp, "zip", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::Array(a), Value::Array(b)) => {
                let a = a.borrow();
                let b = b.borrow();
                let zipped: Vec<Value> = a
                    .iter()
                    .zip(b.iter())
                    .map(|(x, y)| Value::Tuple(Rc::new(vec![x.clone(), y.clone()])))
                    .collect();
                Ok(Value::Array(Rc::new(RefCell::new(zipped))))
            }
            _ => Err(RuntimeError::new("zip() requires two arrays")),
        }
    });

    define(interp, "enumerate", Some(1), |_, args| match &args[0] {
        Value::Array(arr) => {
            let enumerated: Vec<Value> = arr
                .borrow()
                .iter()
                .enumerate()
                .map(|(i, v)| Value::Tuple(Rc::new(vec![Value::Int(i as i64), v.clone()])))
                .collect();
            Ok(Value::Array(Rc::new(RefCell::new(enumerated))))
        }
        _ => Err(RuntimeError::new("enumerate() requires array")),
    });

    // ⋈ (bowtie) - zip_with: combine two arrays with a function
    // Since closures are complex, provide a simple zip variant that takes a mode
    define(interp, "zip_with", Some(3), |_, args| {
        let mode = match &args[2] {
            Value::String(s) => s.as_str(),
            _ => return Err(RuntimeError::new("zip_with() mode must be string")),
        };
        match (&args[0], &args[1]) {
            (Value::Array(a), Value::Array(b)) => {
                let a = a.borrow();
                let b = b.borrow();
                let result: Result<Vec<Value>, RuntimeError> = a
                    .iter()
                    .zip(b.iter())
                    .map(|(x, y)| match (x, y, mode) {
                        (Value::Int(a), Value::Int(b), "add") => Ok(Value::Int(a + b)),
                        (Value::Int(a), Value::Int(b), "sub") => Ok(Value::Int(a - b)),
                        (Value::Int(a), Value::Int(b), "mul") => Ok(Value::Int(a * b)),
                        (Value::Float(a), Value::Float(b), "add") => Ok(Value::Float(a + b)),
                        (Value::Float(a), Value::Float(b), "sub") => Ok(Value::Float(a - b)),
                        (Value::Float(a), Value::Float(b), "mul") => Ok(Value::Float(a * b)),
                        (_, _, "pair") => Ok(Value::Tuple(Rc::new(vec![x.clone(), y.clone()]))),
                        _ => Err(RuntimeError::new("zip_with() incompatible types or mode")),
                    })
                    .collect();
                Ok(Value::Array(Rc::new(RefCell::new(result?))))
            }
            _ => Err(RuntimeError::new("zip_with() requires two arrays")),
        }
    });

    // ⊔ (square cup) - lattice join / supremum (max of two values)
    define(interp, "supremum", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::Int(a), Value::Int(b)) => Ok(Value::Int(*a.max(b))),
            (Value::Float(a), Value::Float(b)) => Ok(Value::Float(a.max(*b))),
            (Value::Array(a), Value::Array(b)) => {
                // Element-wise max
                let a = a.borrow();
                let b = b.borrow();
                let result: Result<Vec<Value>, RuntimeError> = a
                    .iter()
                    .zip(b.iter())
                    .map(|(x, y)| match (x, y) {
                        (Value::Int(a), Value::Int(b)) => Ok(Value::Int(*a.max(b))),
                        (Value::Float(a), Value::Float(b)) => Ok(Value::Float(a.max(*b))),
                        _ => Err(RuntimeError::new("supremum() requires numeric arrays")),
                    })
                    .collect();
                Ok(Value::Array(Rc::new(RefCell::new(result?))))
            }
            _ => Err(RuntimeError::new(
                "supremum() requires numeric values or arrays",
            )),
        }
    });

    // ⊓ (square cap) - lattice meet / infimum (min of two values)
    define(interp, "infimum", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::Int(a), Value::Int(b)) => Ok(Value::Int(*a.min(b))),
            (Value::Float(a), Value::Float(b)) => Ok(Value::Float(a.min(*b))),
            (Value::Array(a), Value::Array(b)) => {
                // Element-wise min
                let a = a.borrow();
                let b = b.borrow();
                let result: Result<Vec<Value>, RuntimeError> = a
                    .iter()
                    .zip(b.iter())
                    .map(|(x, y)| match (x, y) {
                        (Value::Int(a), Value::Int(b)) => Ok(Value::Int(*a.min(b))),
                        (Value::Float(a), Value::Float(b)) => Ok(Value::Float(a.min(*b))),
                        _ => Err(RuntimeError::new("infimum() requires numeric arrays")),
                    })
                    .collect();
                Ok(Value::Array(Rc::new(RefCell::new(result?))))
            }
            _ => Err(RuntimeError::new(
                "infimum() requires numeric values or arrays",
            )),
        }
    });

    // Slicing
    define(interp, "slice", Some(3), |_, args| {
        let start = match &args[1] {
            Value::Int(i) => *i as usize,
            _ => return Err(RuntimeError::new("slice() start must be integer")),
        };
        let end = match &args[2] {
            Value::Int(i) => *i as usize,
            _ => return Err(RuntimeError::new("slice() end must be integer")),
        };
        match &args[0] {
            Value::Array(arr) => {
                let arr = arr.borrow();
                let end = end.min(arr.len());
                let sliced: Vec<Value> = arr[start..end].to_vec();
                Ok(Value::Array(Rc::new(RefCell::new(sliced))))
            }
            Value::String(s) => {
                let chars: Vec<char> = s.chars().collect();
                let end = end.min(chars.len());
                let sliced: String = chars[start..end].iter().collect();
                Ok(Value::String(Rc::new(sliced)))
            }
            _ => Err(RuntimeError::new("slice() requires array or string")),
        }
    });

    define(interp, "take", Some(2), |_, args| {
        let n = match &args[1] {
            Value::Int(i) => *i as usize,
            _ => return Err(RuntimeError::new("take() n must be integer")),
        };
        match &args[0] {
            Value::Array(arr) => {
                let taken: Vec<Value> = arr.borrow().iter().take(n).cloned().collect();
                Ok(Value::Array(Rc::new(RefCell::new(taken))))
            }
            _ => Err(RuntimeError::new("take() requires array")),
        }
    });

    define(interp, "skip", Some(2), |_, args| {
        let n = match &args[1] {
            Value::Int(i) => *i as usize,
            _ => return Err(RuntimeError::new("skip() n must be integer")),
        };
        match &args[0] {
            Value::Array(arr) => {
                let skipped: Vec<Value> = arr.borrow().iter().skip(n).cloned().collect();
                Ok(Value::Array(Rc::new(RefCell::new(skipped))))
            }
            _ => Err(RuntimeError::new("skip() requires array")),
        }
    });

    define(interp, "chunk", Some(2), |_, args| {
        let size = match &args[1] {
            Value::Int(i) if *i > 0 => *i as usize,
            _ => return Err(RuntimeError::new("chunk() size must be positive integer")),
        };
        match &args[0] {
            Value::Array(arr) => {
                let chunks: Vec<Value> = arr
                    .borrow()
                    .chunks(size)
                    .map(|c| Value::Array(Rc::new(RefCell::new(c.to_vec()))))
                    .collect();
                Ok(Value::Array(Rc::new(RefCell::new(chunks))))
            }
            _ => Err(RuntimeError::new("chunk() requires array")),
        }
    });

    // Range
    define(interp, "range", Some(2), |_, args| {
        let start = match &args[0] {
            Value::Int(n) => *n,
            _ => return Err(RuntimeError::new("range() requires integers")),
        };
        let end = match &args[1] {
            Value::Int(n) => *n,
            _ => return Err(RuntimeError::new("range() requires integers")),
        };
        let values: Vec<Value> = (start..end).map(Value::Int).collect();
        Ok(Value::Array(Rc::new(RefCell::new(values))))
    });

    define(interp, "range_inclusive", Some(2), |_, args| {
        let start = match &args[0] {
            Value::Int(n) => *n,
            _ => return Err(RuntimeError::new("range_inclusive() requires integers")),
        };
        let end = match &args[1] {
            Value::Int(n) => *n,
            _ => return Err(RuntimeError::new("range_inclusive() requires integers")),
        };
        let values: Vec<Value> = (start..=end).map(Value::Int).collect();
        Ok(Value::Array(Rc::new(RefCell::new(values))))
    });

    define(interp, "repeat", Some(2), |_, args| {
        let n = match &args[1] {
            Value::Int(i) if *i >= 0 => *i as usize,
            _ => {
                return Err(RuntimeError::new(
                    "repeat() count must be non-negative integer",
                ))
            }
        };
        let repeated: Vec<Value> = std::iter::repeat(args[0].clone()).take(n).collect();
        Ok(Value::Array(Rc::new(RefCell::new(repeated))))
    });

    // ========================================
    // HashMap operations
    // ========================================

    // map_new - create empty HashMap
    define(interp, "map_new", Some(0), |_, _| {
        Ok(Value::Map(Rc::new(RefCell::new(HashMap::new()))))
    });

    // map_get - get value by key
    define(interp, "map_get", Some(2), |_, args| {
        let key = match &args[1] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("map_get() key must be string")),
        };
        match &args[0] {
            Value::Map(map) => Ok(map.borrow().get(&key).cloned().unwrap_or(Value::Null)),
            _ => Err(RuntimeError::new("map_get() requires map")),
        }
    });

    // map_set - set key-value pair
    define(interp, "map_set", Some(3), |_, args| {
        let key = match &args[1] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("map_set() key must be string")),
        };
        match &args[0] {
            Value::Map(map) => {
                map.borrow_mut().insert(key, args[2].clone());
                Ok(Value::Null)
            }
            _ => Err(RuntimeError::new("map_set() requires map")),
        }
    });

    // map_has - check if key exists
    define(interp, "map_has", Some(2), |_, args| {
        let key = match &args[1] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("map_has() key must be string")),
        };
        match &args[0] {
            Value::Map(map) => Ok(Value::Bool(map.borrow().contains_key(&key))),
            _ => Err(RuntimeError::new("map_has() requires map")),
        }
    });

    // map_remove - remove key from map
    define(interp, "map_remove", Some(2), |_, args| {
        let key = match &args[1] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("map_remove() key must be string")),
        };
        match &args[0] {
            Value::Map(map) => Ok(map.borrow_mut().remove(&key).unwrap_or(Value::Null)),
            _ => Err(RuntimeError::new("map_remove() requires map")),
        }
    });

    // map_keys - get all keys as array
    define(interp, "map_keys", Some(1), |_, args| match &args[0] {
        Value::Map(map) => {
            let keys: Vec<Value> = map
                .borrow()
                .keys()
                .map(|k| Value::String(Rc::new(k.clone())))
                .collect();
            Ok(Value::Array(Rc::new(RefCell::new(keys))))
        }
        _ => Err(RuntimeError::new("map_keys() requires map")),
    });

    // map_values - get all values as array
    define(interp, "map_values", Some(1), |_, args| match &args[0] {
        Value::Map(map) => {
            let values: Vec<Value> = map.borrow().values().cloned().collect();
            Ok(Value::Array(Rc::new(RefCell::new(values))))
        }
        _ => Err(RuntimeError::new("map_values() requires map")),
    });

    // map_len - get number of entries
    define(interp, "map_len", Some(1), |_, args| match &args[0] {
        Value::Map(map) => Ok(Value::Int(map.borrow().len() as i64)),
        _ => Err(RuntimeError::new("map_len() requires map")),
    });

    // map_clear - remove all entries
    define(interp, "map_clear", Some(1), |_, args| match &args[0] {
        Value::Map(map) => {
            map.borrow_mut().clear();
            Ok(Value::Null)
        }
        _ => Err(RuntimeError::new("map_clear() requires map")),
    });

    // ========================================
    // HashSet operations
    // ========================================

    // set_new - create empty HashSet
    define(interp, "set_new", Some(0), |_, _| {
        Ok(Value::Set(Rc::new(RefCell::new(
            std::collections::HashSet::new(),
        ))))
    });

    // set_add - add item to set
    define(interp, "set_add", Some(2), |_, args| {
        let item = match &args[1] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("set_add() item must be string")),
        };
        match &args[0] {
            Value::Set(set) => {
                set.borrow_mut().insert(item);
                Ok(Value::Null)
            }
            _ => Err(RuntimeError::new("set_add() requires set")),
        }
    });

    // set_has - check if item exists
    define(interp, "set_has", Some(2), |_, args| {
        let item = match &args[1] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("set_has() item must be string")),
        };
        match &args[0] {
            Value::Set(set) => Ok(Value::Bool(set.borrow().contains(&item))),
            _ => Err(RuntimeError::new("set_has() requires set")),
        }
    });

    // set_remove - remove item from set
    define(interp, "set_remove", Some(2), |_, args| {
        let item = match &args[1] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("set_remove() item must be string")),
        };
        match &args[0] {
            Value::Set(set) => Ok(Value::Bool(set.borrow_mut().remove(&item))),
            _ => Err(RuntimeError::new("set_remove() requires set")),
        }
    });

    // set_to_array - convert set to array
    define(interp, "set_to_array", Some(1), |_, args| match &args[0] {
        Value::Set(set) => {
            let items: Vec<Value> = set
                .borrow()
                .iter()
                .map(|s| Value::String(Rc::new(s.clone())))
                .collect();
            Ok(Value::Array(Rc::new(RefCell::new(items))))
        }
        _ => Err(RuntimeError::new("set_to_array() requires set")),
    });

    // set_len - get number of items
    define(interp, "set_len", Some(1), |_, args| match &args[0] {
        Value::Set(set) => Ok(Value::Int(set.borrow().len() as i64)),
        _ => Err(RuntimeError::new("set_len() requires set")),
    });

    // set_clear - remove all items
    define(interp, "set_clear", Some(1), |_, args| match &args[0] {
        Value::Set(set) => {
            set.borrow_mut().clear();
            Ok(Value::Null)
        }
        _ => Err(RuntimeError::new("set_clear() requires set")),
    });
}

fn values_equal(a: &Value, b: &Value) -> bool {
    match (a, b) {
        (Value::Null, Value::Null) => true,
        (Value::Bool(a), Value::Bool(b)) => a == b,
        (Value::Int(a), Value::Int(b)) => a == b,
        (Value::Float(a), Value::Float(b)) => (a - b).abs() < f64::EPSILON,
        (Value::String(a), Value::String(b)) => a == b,
        (Value::Char(a), Value::Char(b)) => a == b,
        (Value::Array(a), Value::Array(b)) => {
            let a = a.borrow();
            let b = b.borrow();
            a.len() == b.len() && a.iter().zip(b.iter()).all(|(x, y)| values_equal(x, y))
        }
        (Value::Tuple(a), Value::Tuple(b)) => {
            a.len() == b.len() && a.iter().zip(b.iter()).all(|(x, y)| values_equal(x, y))
        }
        _ => false,
    }
}

fn compare_values(a: &Value, b: &Value) -> std::cmp::Ordering {
    match (a, b) {
        (Value::Int(a), Value::Int(b)) => a.cmp(b),
        (Value::Float(a), Value::Float(b)) => a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal),
        (Value::String(a), Value::String(b)) => a.cmp(b),
        (Value::Char(a), Value::Char(b)) => a.cmp(b),
        _ => std::cmp::Ordering::Equal,
    }
}

// ============================================================================
// STRING FUNCTIONS
// ============================================================================

fn register_string(interp: &mut Interpreter) {
    define(interp, "chars", Some(1), |_, args| match &args[0] {
        Value::String(s) => {
            let chars: Vec<Value> = s.chars().map(Value::Char).collect();
            Ok(Value::Array(Rc::new(RefCell::new(chars))))
        }
        _ => Err(RuntimeError::new("chars() requires string")),
    });

    define(interp, "bytes", Some(1), |_, args| match &args[0] {
        Value::String(s) => {
            let bytes: Vec<Value> = s.bytes().map(|b| Value::Int(b as i64)).collect();
            Ok(Value::Array(Rc::new(RefCell::new(bytes))))
        }
        _ => Err(RuntimeError::new("bytes() requires string")),
    });

    define(interp, "split", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::String(s), Value::String(sep)) => {
                let parts: Vec<Value> = s
                    .split(sep.as_str())
                    .map(|p| Value::String(Rc::new(p.to_string())))
                    .collect();
                Ok(Value::Array(Rc::new(RefCell::new(parts))))
            }
            (Value::String(s), Value::Char(sep)) => {
                let parts: Vec<Value> = s
                    .split(*sep)
                    .map(|p| Value::String(Rc::new(p.to_string())))
                    .collect();
                Ok(Value::Array(Rc::new(RefCell::new(parts))))
            }
            _ => Err(RuntimeError::new("split() requires string and separator")),
        }
    });

    define(interp, "join", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::Array(arr), Value::String(sep)) => {
                let parts: Vec<String> = arr.borrow().iter().map(|v| format!("{}", v)).collect();
                Ok(Value::String(Rc::new(parts.join(sep.as_str()))))
            }
            _ => Err(RuntimeError::new(
                "join() requires array and separator string",
            )),
        }
    });

    define(interp, "trim", Some(1), |_, args| match &args[0] {
        Value::String(s) => Ok(Value::String(Rc::new(s.trim().to_string()))),
        _ => Err(RuntimeError::new("trim() requires string")),
    });

    define(interp, "trim_start", Some(1), |_, args| match &args[0] {
        Value::String(s) => Ok(Value::String(Rc::new(s.trim_start().to_string()))),
        _ => Err(RuntimeError::new("trim_start() requires string")),
    });

    define(interp, "trim_end", Some(1), |_, args| match &args[0] {
        Value::String(s) => Ok(Value::String(Rc::new(s.trim_end().to_string()))),
        _ => Err(RuntimeError::new("trim_end() requires string")),
    });

    define(interp, "upper", Some(1), |_, args| match &args[0] {
        Value::String(s) => Ok(Value::String(Rc::new(s.to_uppercase()))),
        Value::Char(c) => Ok(Value::Char(c.to_uppercase().next().unwrap_or(*c))),
        _ => Err(RuntimeError::new("upper() requires string or char")),
    });

    define(interp, "lower", Some(1), |_, args| match &args[0] {
        Value::String(s) => Ok(Value::String(Rc::new(s.to_lowercase()))),
        Value::Char(c) => Ok(Value::Char(c.to_lowercase().next().unwrap_or(*c))),
        _ => Err(RuntimeError::new("lower() requires string or char")),
    });

    define(interp, "capitalize", Some(1), |_, args| match &args[0] {
        Value::String(s) => {
            let mut chars = s.chars();
            let capitalized = match chars.next() {
                None => String::new(),
                Some(c) => c.to_uppercase().chain(chars).collect(),
            };
            Ok(Value::String(Rc::new(capitalized)))
        }
        _ => Err(RuntimeError::new("capitalize() requires string")),
    });

    define(interp, "replace", Some(3), |_, args| {
        match (&args[0], &args[1], &args[2]) {
            (Value::String(s), Value::String(from), Value::String(to)) => Ok(Value::String(
                Rc::new(s.replace(from.as_str(), to.as_str())),
            )),
            _ => Err(RuntimeError::new("replace() requires three strings")),
        }
    });

    define(interp, "starts_with", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::String(s), Value::String(prefix)) => {
                Ok(Value::Bool(s.starts_with(prefix.as_str())))
            }
            _ => Err(RuntimeError::new("starts_with() requires two strings")),
        }
    });

    define(interp, "ends_with", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::String(s), Value::String(suffix)) => {
                Ok(Value::Bool(s.ends_with(suffix.as_str())))
            }
            _ => Err(RuntimeError::new("ends_with() requires two strings")),
        }
    });

    define(interp, "repeat_str", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::String(s), Value::Int(n)) if *n >= 0 => {
                Ok(Value::String(Rc::new(s.repeat(*n as usize))))
            }
            _ => Err(RuntimeError::new(
                "repeat_str() requires string and non-negative integer",
            )),
        }
    });

    define(interp, "pad_left", Some(3), |_, args| {
        match (&args[0], &args[1], &args[2]) {
            (Value::String(s), Value::Int(width), Value::Char(c)) => {
                let width = *width as usize;
                if s.len() >= width {
                    Ok(Value::String(s.clone()))
                } else {
                    let padding: String = std::iter::repeat(*c).take(width - s.len()).collect();
                    Ok(Value::String(Rc::new(format!("{}{}", padding, s))))
                }
            }
            _ => Err(RuntimeError::new(
                "pad_left() requires string, width, and char",
            )),
        }
    });

    define(interp, "pad_right", Some(3), |_, args| {
        match (&args[0], &args[1], &args[2]) {
            (Value::String(s), Value::Int(width), Value::Char(c)) => {
                let width = *width as usize;
                if s.len() >= width {
                    Ok(Value::String(s.clone()))
                } else {
                    let padding: String = std::iter::repeat(*c).take(width - s.len()).collect();
                    Ok(Value::String(Rc::new(format!("{}{}", s, padding))))
                }
            }
            _ => Err(RuntimeError::new(
                "pad_right() requires string, width, and char",
            )),
        }
    });

    define(interp, "lines", Some(1), |_, args| match &args[0] {
        Value::String(s) => {
            let lines: Vec<Value> = s
                .lines()
                .map(|l| Value::String(Rc::new(l.to_string())))
                .collect();
            Ok(Value::Array(Rc::new(RefCell::new(lines))))
        }
        _ => Err(RuntimeError::new("lines() requires string")),
    });

    define(interp, "words", Some(1), |_, args| match &args[0] {
        Value::String(s) => {
            let words: Vec<Value> = s
                .split_whitespace()
                .map(|w| Value::String(Rc::new(w.to_string())))
                .collect();
            Ok(Value::Array(Rc::new(RefCell::new(words))))
        }
        _ => Err(RuntimeError::new("words() requires string")),
    });

    define(interp, "is_alpha", Some(1), |_, args| match &args[0] {
        Value::String(s) => Ok(Value::Bool(
            !s.is_empty() && s.chars().all(|c| c.is_alphabetic()),
        )),
        Value::Char(c) => Ok(Value::Bool(c.is_alphabetic())),
        _ => Err(RuntimeError::new("is_alpha() requires string or char")),
    });

    define(interp, "is_digit", Some(1), |_, args| match &args[0] {
        Value::String(s) => Ok(Value::Bool(
            !s.is_empty() && s.chars().all(|c| c.is_ascii_digit()),
        )),
        Value::Char(c) => Ok(Value::Bool(c.is_ascii_digit())),
        _ => Err(RuntimeError::new("is_digit() requires string or char")),
    });

    define(interp, "is_alnum", Some(1), |_, args| match &args[0] {
        Value::String(s) => Ok(Value::Bool(
            !s.is_empty() && s.chars().all(|c| c.is_alphanumeric()),
        )),
        Value::Char(c) => Ok(Value::Bool(c.is_alphanumeric())),
        _ => Err(RuntimeError::new("is_alnum() requires string or char")),
    });

    define(interp, "is_space", Some(1), |_, args| match &args[0] {
        Value::String(s) => Ok(Value::Bool(
            !s.is_empty() && s.chars().all(|c| c.is_whitespace()),
        )),
        Value::Char(c) => Ok(Value::Bool(c.is_whitespace())),
        _ => Err(RuntimeError::new("is_space() requires string or char")),
    });

    // =========================================================================
    // ADVANCED STRING FUNCTIONS
    // =========================================================================

    // find - find first occurrence of substring, returns index or -1
    define(interp, "find", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::String(s), Value::String(sub)) => {
                match s.find(sub.as_str()) {
                    Some(byte_idx) => {
                        // Convert byte index to character index
                        let char_idx = s[..byte_idx].chars().count() as i64;
                        Ok(Value::Int(char_idx))
                    }
                    None => Ok(Value::Int(-1)),
                }
            }
            (Value::String(s), Value::Char(c)) => match s.find(*c) {
                Some(byte_idx) => {
                    let char_idx = s[..byte_idx].chars().count() as i64;
                    Ok(Value::Int(char_idx))
                }
                None => Ok(Value::Int(-1)),
            },
            _ => Err(RuntimeError::new(
                "find() requires string and substring/char",
            )),
        }
    });

    // index_of - find index of element in array or substring in string
    define(interp, "index_of", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::String(s), Value::String(sub)) => match s.find(sub.as_str()) {
                Some(byte_idx) => {
                    let char_idx = s[..byte_idx].chars().count() as i64;
                    Ok(Value::Int(char_idx))
                }
                None => Ok(Value::Int(-1)),
            },
            (Value::String(s), Value::Char(c)) => match s.find(*c) {
                Some(byte_idx) => {
                    let char_idx = s[..byte_idx].chars().count() as i64;
                    Ok(Value::Int(char_idx))
                }
                None => Ok(Value::Int(-1)),
            },
            (Value::Array(arr), search) => {
                // Array index_of - use Value comparison
                for (i, v) in arr.borrow().iter().enumerate() {
                    if values_equal_simple(v, search) {
                        return Ok(Value::Int(i as i64));
                    }
                }
                Ok(Value::Int(-1))
            }
            _ => Err(RuntimeError::new(
                "index_of() requires array/string and element/substring",
            )),
        }
    });

    // last_index_of - find last occurrence of substring
    define(interp, "last_index_of", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::String(s), Value::String(sub)) => match s.rfind(sub.as_str()) {
                Some(byte_idx) => {
                    let char_idx = s[..byte_idx].chars().count() as i64;
                    Ok(Value::Int(char_idx))
                }
                None => Ok(Value::Int(-1)),
            },
            (Value::String(s), Value::Char(c)) => match s.rfind(*c) {
                Some(byte_idx) => {
                    let char_idx = s[..byte_idx].chars().count() as i64;
                    Ok(Value::Int(char_idx))
                }
                None => Ok(Value::Int(-1)),
            },
            _ => Err(RuntimeError::new(
                "last_index_of() requires string and substring/char",
            )),
        }
    });

    // substring - extract substring by character indices
    define(interp, "substring", Some(3), |_, args| {
        let s = match &args[0] {
            Value::String(s) => (**s).clone(),
            _ => {
                return Err(RuntimeError::new(
                    "substring: first argument must be a string",
                ))
            }
        };
        let start = match &args[1] {
            Value::Int(n) if *n >= 0 => *n as usize,
            _ => {
                return Err(RuntimeError::new(
                    "substring: start must be a non-negative integer",
                ))
            }
        };
        let end = match &args[2] {
            Value::Int(n) if *n >= 0 => *n as usize,
            _ => {
                return Err(RuntimeError::new(
                    "substring: end must be a non-negative integer",
                ))
            }
        };
        let chars: Vec<char> = s.chars().collect();
        let len = chars.len();
        let actual_start = start.min(len);
        let actual_end = end.min(len);
        if actual_start >= actual_end {
            return Ok(Value::String(Rc::new(String::new())));
        }
        let result: String = chars[actual_start..actual_end].iter().collect();
        Ok(Value::String(Rc::new(result)))
    });

    // count - count occurrences of substring
    define(interp, "count", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::String(s), Value::String(sub)) => {
                if sub.is_empty() {
                    return Err(RuntimeError::new("count: cannot count empty string"));
                }
                let count = s.matches(sub.as_str()).count() as i64;
                Ok(Value::Int(count))
            }
            (Value::String(s), Value::Char(c)) => {
                let count = s.chars().filter(|&ch| ch == *c).count() as i64;
                Ok(Value::Int(count))
            }
            _ => Err(RuntimeError::new(
                "count() requires string and substring/char",
            )),
        }
    });

    // char_at - get character at index (safer than indexing)
    define(interp, "char_at", Some(2), |_, args| {
        let s = match &args[0] {
            Value::String(s) => (**s).clone(),
            _ => {
                return Err(RuntimeError::new(
                    "char_at: first argument must be a string",
                ))
            }
        };
        let idx = match &args[1] {
            Value::Int(n) => *n,
            _ => {
                return Err(RuntimeError::new(
                    "char_at: second argument must be an integer",
                ))
            }
        };
        let chars: Vec<char> = s.chars().collect();
        let actual_idx = if idx < 0 {
            (chars.len() as i64 + idx) as usize
        } else {
            idx as usize
        };
        match chars.get(actual_idx) {
            Some(c) => Ok(Value::Char(*c)),
            None => Ok(Value::Null),
        }
    });

    // char_code_at - get Unicode code point at index
    define(interp, "char_code_at", Some(2), |_, args| {
        let s = match &args[0] {
            Value::String(s) => (**s).clone(),
            _ => {
                return Err(RuntimeError::new(
                    "char_code_at: first argument must be a string",
                ))
            }
        };
        let idx = match &args[1] {
            Value::Int(n) => *n,
            _ => {
                return Err(RuntimeError::new(
                    "char_code_at: second argument must be an integer",
                ))
            }
        };
        let chars: Vec<char> = s.chars().collect();
        let actual_idx = if idx < 0 {
            (chars.len() as i64 + idx) as usize
        } else {
            idx as usize
        };
        match chars.get(actual_idx) {
            Some(c) => Ok(Value::Int(*c as i64)),
            None => Ok(Value::Null),
        }
    });

    // from_char_code - create string from Unicode code point
    define(interp, "from_char_code", Some(1), |_, args| {
        let code = match &args[0] {
            Value::Int(n) => *n as u32,
            _ => {
                return Err(RuntimeError::new(
                    "from_char_code: argument must be an integer",
                ))
            }
        };
        match char::from_u32(code) {
            Some(c) => Ok(Value::String(Rc::new(c.to_string()))),
            None => Err(RuntimeError::new(
                "from_char_code: invalid Unicode code point",
            )),
        }
    });

    // insert - insert string at index
    define(interp, "insert", Some(3), |_, args| {
        let s = match &args[0] {
            Value::String(s) => (**s).clone(),
            _ => return Err(RuntimeError::new("insert: first argument must be a string")),
        };
        let idx = match &args[1] {
            Value::Int(n) if *n >= 0 => *n as usize,
            _ => {
                return Err(RuntimeError::new(
                    "insert: index must be a non-negative integer",
                ))
            }
        };
        let insertion = match &args[2] {
            Value::String(s) => (**s).clone(),
            _ => return Err(RuntimeError::new("insert: third argument must be a string")),
        };
        let chars: Vec<char> = s.chars().collect();
        let actual_idx = idx.min(chars.len());
        let mut result: String = chars[..actual_idx].iter().collect();
        result.push_str(&insertion);
        result.extend(chars[actual_idx..].iter());
        Ok(Value::String(Rc::new(result)))
    });

    // remove - remove range from string
    define(interp, "remove", Some(3), |_, args| {
        let s = match &args[0] {
            Value::String(s) => (**s).clone(),
            _ => return Err(RuntimeError::new("remove: first argument must be a string")),
        };
        let start = match &args[1] {
            Value::Int(n) if *n >= 0 => *n as usize,
            _ => {
                return Err(RuntimeError::new(
                    "remove: start must be a non-negative integer",
                ))
            }
        };
        let len = match &args[2] {
            Value::Int(n) if *n >= 0 => *n as usize,
            _ => {
                return Err(RuntimeError::new(
                    "remove: length must be a non-negative integer",
                ))
            }
        };
        let chars: Vec<char> = s.chars().collect();
        let str_len = chars.len();
        let actual_start = start.min(str_len);
        let actual_end = (start + len).min(str_len);
        let mut result: String = chars[..actual_start].iter().collect();
        result.extend(chars[actual_end..].iter());
        Ok(Value::String(Rc::new(result)))
    });

    // compare - compare two strings, returns -1, 0, or 1
    define(interp, "compare", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::String(a), Value::String(b)) => {
                let result = match a.cmp(b) {
                    std::cmp::Ordering::Less => -1,
                    std::cmp::Ordering::Equal => 0,
                    std::cmp::Ordering::Greater => 1,
                };
                Ok(Value::Int(result))
            }
            _ => Err(RuntimeError::new("compare() requires two strings")),
        }
    });

    // compare_ignore_case - case-insensitive comparison
    define(interp, "compare_ignore_case", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::String(a), Value::String(b)) => {
                let result = match a.to_lowercase().cmp(&b.to_lowercase()) {
                    std::cmp::Ordering::Less => -1,
                    std::cmp::Ordering::Equal => 0,
                    std::cmp::Ordering::Greater => 1,
                };
                Ok(Value::Int(result))
            }
            _ => Err(RuntimeError::new(
                "compare_ignore_case() requires two strings",
            )),
        }
    });

    // char_count - get character count (not byte length)
    define(interp, "char_count", Some(1), |_, args| match &args[0] {
        Value::String(s) => Ok(Value::Int(s.chars().count() as i64)),
        _ => Err(RuntimeError::new("char_count() requires string")),
    });

    // byte_count - get byte length (for UTF-8 awareness)
    define(interp, "byte_count", Some(1), |_, args| match &args[0] {
        Value::String(s) => Ok(Value::Int(s.len() as i64)),
        _ => Err(RuntimeError::new("byte_count() requires string")),
    });

    // is_empty - check if string is empty
    define(interp, "is_empty", Some(1), |_, args| match &args[0] {
        Value::String(s) => Ok(Value::Bool(s.is_empty())),
        Value::Array(arr) => Ok(Value::Bool(arr.borrow().is_empty())),
        _ => Err(RuntimeError::new("is_empty() requires string or array")),
    });

    // is_blank - check if string is empty or only whitespace
    define(interp, "is_blank", Some(1), |_, args| match &args[0] {
        Value::String(s) => Ok(Value::Bool(s.trim().is_empty())),
        _ => Err(RuntimeError::new("is_blank() requires string")),
    });

    // =========================================================================
    // UNICODE NORMALIZATION FUNCTIONS
    // =========================================================================

    // nfc - Unicode Normalization Form C (Canonical Decomposition, followed by Canonical Composition)
    define(interp, "nfc", Some(1), |_, args| match &args[0] {
        Value::String(s) => Ok(Value::String(Rc::new(s.nfc().collect()))),
        _ => Err(RuntimeError::new("nfc() requires string")),
    });

    // nfd - Unicode Normalization Form D (Canonical Decomposition)
    define(interp, "nfd", Some(1), |_, args| match &args[0] {
        Value::String(s) => Ok(Value::String(Rc::new(s.nfd().collect()))),
        _ => Err(RuntimeError::new("nfd() requires string")),
    });

    // nfkc - Unicode Normalization Form KC (Compatibility Decomposition, followed by Canonical Composition)
    define(interp, "nfkc", Some(1), |_, args| match &args[0] {
        Value::String(s) => Ok(Value::String(Rc::new(s.nfkc().collect()))),
        _ => Err(RuntimeError::new("nfkc() requires string")),
    });

    // nfkd - Unicode Normalization Form KD (Compatibility Decomposition)
    define(interp, "nfkd", Some(1), |_, args| match &args[0] {
        Value::String(s) => Ok(Value::String(Rc::new(s.nfkd().collect()))),
        _ => Err(RuntimeError::new("nfkd() requires string")),
    });

    // is_nfc - check if string is in NFC form
    define(interp, "is_nfc", Some(1), |_, args| match &args[0] {
        Value::String(s) => {
            let normalized: String = s.nfc().collect();
            Ok(Value::Bool(*s.as_ref() == normalized))
        }
        _ => Err(RuntimeError::new("is_nfc() requires string")),
    });

    // is_nfd - check if string is in NFD form
    define(interp, "is_nfd", Some(1), |_, args| match &args[0] {
        Value::String(s) => {
            let normalized: String = s.nfd().collect();
            Ok(Value::Bool(*s.as_ref() == normalized))
        }
        _ => Err(RuntimeError::new("is_nfd() requires string")),
    });

    // =========================================================================
    // GRAPHEME CLUSTER FUNCTIONS
    // =========================================================================

    // graphemes - split string into grapheme clusters (user-perceived characters)
    define(interp, "graphemes", Some(1), |_, args| match &args[0] {
        Value::String(s) => {
            let graphemes: Vec<Value> = s
                .graphemes(true)
                .map(|g| Value::String(Rc::new(g.to_string())))
                .collect();
            Ok(Value::Array(Rc::new(RefCell::new(graphemes))))
        }
        _ => Err(RuntimeError::new("graphemes() requires string")),
    });

    // grapheme_count - count grapheme clusters (correct for emoji, combining chars, etc.)
    define(interp, "grapheme_count", Some(1), |_, args| {
        match &args[0] {
            Value::String(s) => Ok(Value::Int(s.graphemes(true).count() as i64)),
            _ => Err(RuntimeError::new("grapheme_count() requires string")),
        }
    });

    // grapheme_at - get grapheme cluster at index
    define(interp, "grapheme_at", Some(2), |_, args| {
        let s = match &args[0] {
            Value::String(s) => (**s).clone(),
            _ => {
                return Err(RuntimeError::new(
                    "grapheme_at: first argument must be a string",
                ))
            }
        };
        let idx = match &args[1] {
            Value::Int(n) => *n,
            _ => {
                return Err(RuntimeError::new(
                    "grapheme_at: second argument must be an integer",
                ))
            }
        };
        let graphemes: Vec<&str> = s.graphemes(true).collect();
        let actual_idx = if idx < 0 {
            (graphemes.len() as i64 + idx) as usize
        } else {
            idx as usize
        };
        match graphemes.get(actual_idx) {
            Some(g) => Ok(Value::String(Rc::new(g.to_string()))),
            None => Ok(Value::Null),
        }
    });

    // grapheme_slice - slice string by grapheme indices (proper Unicode slicing)
    define(interp, "grapheme_slice", Some(3), |_, args| {
        let s = match &args[0] {
            Value::String(s) => (**s).clone(),
            _ => {
                return Err(RuntimeError::new(
                    "grapheme_slice: first argument must be a string",
                ))
            }
        };
        let start = match &args[1] {
            Value::Int(n) if *n >= 0 => *n as usize,
            _ => {
                return Err(RuntimeError::new(
                    "grapheme_slice: start must be a non-negative integer",
                ))
            }
        };
        let end = match &args[2] {
            Value::Int(n) if *n >= 0 => *n as usize,
            _ => {
                return Err(RuntimeError::new(
                    "grapheme_slice: end must be a non-negative integer",
                ))
            }
        };
        let graphemes: Vec<&str> = s.graphemes(true).collect();
        let len = graphemes.len();
        let actual_start = start.min(len);
        let actual_end = end.min(len);
        if actual_start >= actual_end {
            return Ok(Value::String(Rc::new(String::new())));
        }
        let result: String = graphemes[actual_start..actual_end].join("");
        Ok(Value::String(Rc::new(result)))
    });

    // grapheme_reverse - reverse string by grapheme clusters (correct for emoji, etc.)
    define(interp, "grapheme_reverse", Some(1), |_, args| {
        match &args[0] {
            Value::String(s) => {
                let reversed: String = s.graphemes(true).rev().collect();
                Ok(Value::String(Rc::new(reversed)))
            }
            _ => Err(RuntimeError::new("grapheme_reverse() requires string")),
        }
    });

    // word_indices - get word boundaries
    define(interp, "word_boundaries", Some(1), |_, args| {
        match &args[0] {
            Value::String(s) => {
                let words: Vec<Value> = s
                    .unicode_words()
                    .map(|w| Value::String(Rc::new(w.to_string())))
                    .collect();
                Ok(Value::Array(Rc::new(RefCell::new(words))))
            }
            _ => Err(RuntimeError::new("word_boundaries() requires string")),
        }
    });

    // =========================================================================
    // STRING BUILDER
    // =========================================================================

    // string_builder - create a new string builder (just returns empty string for now,
    // operations can be chained with concat)
    define(interp, "string_builder", Some(0), |_, _| {
        Ok(Value::String(Rc::new(String::new())))
    });

    // concat_all - concatenate array of strings efficiently
    define(interp, "concat_all", Some(1), |_, args| match &args[0] {
        Value::Array(arr) => {
            let parts: Vec<String> = arr
                .borrow()
                .iter()
                .map(|v| match v {
                    Value::String(s) => (**s).clone(),
                    other => format!("{}", other),
                })
                .collect();
            Ok(Value::String(Rc::new(parts.join(""))))
        }
        _ => Err(RuntimeError::new("concat_all() requires array")),
    });

    // repeat_join - repeat a string n times with a separator
    define(interp, "repeat_join", Some(3), |_, args| {
        let s = match &args[0] {
            Value::String(s) => (**s).clone(),
            _ => {
                return Err(RuntimeError::new(
                    "repeat_join: first argument must be a string",
                ))
            }
        };
        let n = match &args[1] {
            Value::Int(n) if *n >= 0 => *n as usize,
            _ => {
                return Err(RuntimeError::new(
                    "repeat_join: count must be a non-negative integer",
                ))
            }
        };
        let sep = match &args[2] {
            Value::String(s) => (**s).clone(),
            _ => return Err(RuntimeError::new("repeat_join: separator must be a string")),
        };
        if n == 0 {
            return Ok(Value::String(Rc::new(String::new())));
        }
        let parts: Vec<&str> = std::iter::repeat(s.as_str()).take(n).collect();
        Ok(Value::String(Rc::new(parts.join(&sep))))
    });
}

// ============================================================================
// EVIDENCE FUNCTIONS
// ============================================================================

fn register_evidence(interp: &mut Interpreter) {
    use crate::interpreter::RuntimeConfidence;

    // Create evidential values
    define(interp, "known", Some(1), |_, args| {
        Ok(Value::Evidential {
            value: Box::new(args[0].clone()),
            evidence: Evidence::Known,
        })
    });

    define(interp, "uncertain", Some(1), |_, args| {
        Ok(Value::Evidential {
            value: Box::new(args[0].clone()),
            evidence: Evidence::Uncertain,
        })
    });

    define(interp, "reported", Some(1), |_, args| {
        Ok(Value::Evidential {
            value: Box::new(args[0].clone()),
            evidence: Evidence::Reported,
        })
    });

    define(interp, "paradox", Some(1), |_, args| {
        Ok(Value::Evidential {
            value: Box::new(args[0].clone()),
            evidence: Evidence::Paradox,
        })
    });

    // Query evidence
    define(interp, "evidence_of", Some(1), |_, args| {
        match &args[0] {
            Value::Evidential { evidence, .. } => {
                let level = match evidence {
                    Evidence::Known => "known",
                    Evidence::Uncertain => "uncertain",
                    Evidence::Reported => "reported",
                    Evidence::Paradox => "paradox",
                };
                Ok(Value::String(Rc::new(level.to_string())))
            }
            _ => Ok(Value::String(Rc::new("known".to_string()))), // Non-evidential values are known
        }
    });

    define(interp, "is_known", Some(1), |_, args| {
        match &args[0] {
            Value::Evidential {
                evidence: Evidence::Known,
                ..
            } => Ok(Value::Bool(true)),
            Value::Evidential { .. } => Ok(Value::Bool(false)),
            _ => Ok(Value::Bool(true)), // Non-evidential values are known
        }
    });

    define(interp, "is_uncertain", Some(1), |_, args| match &args[0] {
        Value::Evidential {
            evidence: Evidence::Uncertain,
            ..
        } => Ok(Value::Bool(true)),
        _ => Ok(Value::Bool(false)),
    });

    define(interp, "is_reported", Some(1), |_, args| match &args[0] {
        Value::Evidential {
            evidence: Evidence::Reported,
            ..
        } => Ok(Value::Bool(true)),
        _ => Ok(Value::Bool(false)),
    });

    define(interp, "is_paradox", Some(1), |_, args| match &args[0] {
        Value::Evidential {
            evidence: Evidence::Paradox,
            ..
        } => Ok(Value::Bool(true)),
        _ => Ok(Value::Bool(false)),
    });

    // Extract inner value
    define(interp, "strip_evidence", Some(1), |_, args| {
        match &args[0] {
            Value::Evidential { value, .. } => Ok(*value.clone()),
            other => Ok(other.clone()),
        }
    });

    // Trust operations
    define(interp, "trust", Some(1), |_, args| {
        // Upgrade reported/uncertain to known (with assertion)
        match &args[0] {
            Value::Evidential { value, .. } => Ok(Value::Evidential {
                value: value.clone(),
                evidence: Evidence::Known,
            }),
            other => Ok(other.clone()),
        }
    });

    define(interp, "verify", Some(2), |_, args| {
        // Verify evidential value with predicate, upgrading if true
        let pred_result = match &args[1] {
            Value::Bool(b) => *b,
            _ => return Err(RuntimeError::new("verify() predicate must be bool")),
        };

        if pred_result {
            match &args[0] {
                Value::Evidential { value, .. } => Ok(Value::Evidential {
                    value: value.clone(),
                    evidence: Evidence::Known,
                }),
                other => Ok(other.clone()),
            }
        } else {
            Ok(args[0].clone()) // Keep original evidence
        }
    });

    // Combine evidence (join in lattice)
    define(interp, "combine_evidence", Some(2), |_, args| {
        let ev1 = match &args[0] {
            Value::Evidential { evidence, .. } => *evidence,
            _ => Evidence::Known,
        };
        let ev2 = match &args[1] {
            Value::Evidential { evidence, .. } => *evidence,
            _ => Evidence::Known,
        };

        // Join: max of the two
        let combined = match (ev1, ev2) {
            (Evidence::Paradox, _) | (_, Evidence::Paradox) => Evidence::Paradox,
            (Evidence::Reported, _) | (_, Evidence::Reported) => Evidence::Reported,
            (Evidence::Uncertain, _) | (_, Evidence::Uncertain) => Evidence::Uncertain,
            _ => Evidence::Known,
        };

        Ok(Value::String(Rc::new(
            match combined {
                Evidence::Known => "known",
                Evidence::Uncertain => "uncertain",
                Evidence::Reported => "reported",
                Evidence::Paradox => "paradox",
            }
            .to_string(),
        )))
    });

    // === Affect-Evidence Integration ===

    // Derive evidence from affect markers
    define(interp, "affect_to_evidence", Some(1), |_, args| {
        match &args[0] {
            Value::Affective { affect, .. } => {
                // Sarcasm implies uncertainty (meaning is inverted)
                if affect.sarcasm {
                    return Ok(Value::String(Rc::new("uncertain".to_string())));
                }
                // Confidence maps to evidence
                match affect.confidence {
                    Some(RuntimeConfidence::High) => {
                        Ok(Value::String(Rc::new("known".to_string())))
                    }
                    Some(RuntimeConfidence::Low) => {
                        Ok(Value::String(Rc::new("uncertain".to_string())))
                    }
                    _ => Ok(Value::String(Rc::new("known".to_string()))),
                }
            }
            _ => Ok(Value::String(Rc::new("known".to_string()))),
        }
    });

    // Convert affective value to evidential based on affect markers
    define(interp, "affect_as_evidence", Some(1), |_, args| {
        match &args[0] {
            Value::Affective { value, affect } => {
                let evidence = if affect.sarcasm {
                    Evidence::Uncertain
                } else {
                    match affect.confidence {
                        Some(RuntimeConfidence::High) => Evidence::Known,
                        Some(RuntimeConfidence::Low) => Evidence::Uncertain,
                        _ => Evidence::Known,
                    }
                };
                Ok(Value::Evidential {
                    value: value.clone(),
                    evidence,
                })
            }
            other => Ok(other.clone()),
        }
    });

    // Check if affective value implies uncertainty
    define(interp, "is_affect_uncertain", Some(1), |_, args| {
        match &args[0] {
            Value::Affective { affect, .. } => {
                let uncertain = affect.sarcasm
                    || matches!(affect.confidence, Some(RuntimeConfidence::Low));
                Ok(Value::Bool(uncertain))
            }
            _ => Ok(Value::Bool(false)),
        }
    });

    // Combine affect and evidence (wrap evidential in affect or vice versa)
    define(interp, "with_affect_evidence", Some(2), |_, args| {
        // args[0] = affect source, args[1] = value to wrap
        match &args[0] {
            Value::Affective { affect, .. } => {
                let evidence = if affect.sarcasm {
                    Evidence::Uncertain
                } else {
                    match affect.confidence {
                        Some(RuntimeConfidence::High) => Evidence::Known,
                        Some(RuntimeConfidence::Low) => Evidence::Uncertain,
                        _ => Evidence::Known,
                    }
                };
                Ok(Value::Evidential {
                    value: Box::new(args[1].clone()),
                    evidence,
                })
            }
            Value::Evidential { evidence, .. } => {
                // Preserve evidence on the new value
                Ok(Value::Evidential {
                    value: Box::new(args[1].clone()),
                    evidence: *evidence,
                })
            }
            _ => Ok(args[1].clone()),
        }
    });
}

// ============================================================================
// AFFECT FUNCTIONS (Sentiment, Emotion, Sarcasm markers)
// ============================================================================

fn register_affect(interp: &mut Interpreter) {
    use crate::interpreter::{
        RuntimeAffect, RuntimeConfidence, RuntimeEmotion, RuntimeFormality, RuntimeIntensity,
        RuntimeSentiment,
    };

    // === Create affective values ===

    // Sentiment markers
    define(interp, "positive", Some(1), |_, args| {
        Ok(Value::Affective {
            value: Box::new(args[0].clone()),
            affect: RuntimeAffect {
                sentiment: Some(RuntimeSentiment::Positive),
                sarcasm: false,
                intensity: None,
                formality: None,
                emotion: None,
                confidence: None,
            },
        })
    });

    define(interp, "negative", Some(1), |_, args| {
        Ok(Value::Affective {
            value: Box::new(args[0].clone()),
            affect: RuntimeAffect {
                sentiment: Some(RuntimeSentiment::Negative),
                sarcasm: false,
                intensity: None,
                formality: None,
                emotion: None,
                confidence: None,
            },
        })
    });

    define(interp, "neutral", Some(1), |_, args| {
        Ok(Value::Affective {
            value: Box::new(args[0].clone()),
            affect: RuntimeAffect {
                sentiment: Some(RuntimeSentiment::Neutral),
                sarcasm: false,
                intensity: None,
                formality: None,
                emotion: None,
                confidence: None,
            },
        })
    });

    // Sarcasm marker
    define(interp, "sarcastic", Some(1), |_, args| {
        Ok(Value::Affective {
            value: Box::new(args[0].clone()),
            affect: RuntimeAffect {
                sentiment: None,
                sarcasm: true,
                intensity: None,
                formality: None,
                emotion: None,
                confidence: None,
            },
        })
    });

    // Intensity markers
    define(interp, "intensify", Some(1), |_, args| {
        Ok(Value::Affective {
            value: Box::new(args[0].clone()),
            affect: RuntimeAffect {
                sentiment: None,
                sarcasm: false,
                intensity: Some(RuntimeIntensity::Up),
                formality: None,
                emotion: None,
                confidence: None,
            },
        })
    });

    define(interp, "dampen", Some(1), |_, args| {
        Ok(Value::Affective {
            value: Box::new(args[0].clone()),
            affect: RuntimeAffect {
                sentiment: None,
                sarcasm: false,
                intensity: Some(RuntimeIntensity::Down),
                formality: None,
                emotion: None,
                confidence: None,
            },
        })
    });

    define(interp, "maximize", Some(1), |_, args| {
        Ok(Value::Affective {
            value: Box::new(args[0].clone()),
            affect: RuntimeAffect {
                sentiment: None,
                sarcasm: false,
                intensity: Some(RuntimeIntensity::Max),
                formality: None,
                emotion: None,
                confidence: None,
            },
        })
    });

    // Formality markers
    define(interp, "formal", Some(1), |_, args| {
        Ok(Value::Affective {
            value: Box::new(args[0].clone()),
            affect: RuntimeAffect {
                sentiment: None,
                sarcasm: false,
                intensity: None,
                formality: Some(RuntimeFormality::Formal),
                emotion: None,
                confidence: None,
            },
        })
    });

    define(interp, "informal", Some(1), |_, args| {
        Ok(Value::Affective {
            value: Box::new(args[0].clone()),
            affect: RuntimeAffect {
                sentiment: None,
                sarcasm: false,
                intensity: None,
                formality: Some(RuntimeFormality::Informal),
                emotion: None,
                confidence: None,
            },
        })
    });

    // Emotion markers (Plutchik's wheel)
    define(interp, "joyful", Some(1), |_, args| {
        Ok(Value::Affective {
            value: Box::new(args[0].clone()),
            affect: RuntimeAffect {
                sentiment: None,
                sarcasm: false,
                intensity: None,
                formality: None,
                emotion: Some(RuntimeEmotion::Joy),
                confidence: None,
            },
        })
    });

    define(interp, "sad", Some(1), |_, args| {
        Ok(Value::Affective {
            value: Box::new(args[0].clone()),
            affect: RuntimeAffect {
                sentiment: None,
                sarcasm: false,
                intensity: None,
                formality: None,
                emotion: Some(RuntimeEmotion::Sadness),
                confidence: None,
            },
        })
    });

    define(interp, "angry", Some(1), |_, args| {
        Ok(Value::Affective {
            value: Box::new(args[0].clone()),
            affect: RuntimeAffect {
                sentiment: None,
                sarcasm: false,
                intensity: None,
                formality: None,
                emotion: Some(RuntimeEmotion::Anger),
                confidence: None,
            },
        })
    });

    define(interp, "fearful", Some(1), |_, args| {
        Ok(Value::Affective {
            value: Box::new(args[0].clone()),
            affect: RuntimeAffect {
                sentiment: None,
                sarcasm: false,
                intensity: None,
                formality: None,
                emotion: Some(RuntimeEmotion::Fear),
                confidence: None,
            },
        })
    });

    define(interp, "surprised", Some(1), |_, args| {
        Ok(Value::Affective {
            value: Box::new(args[0].clone()),
            affect: RuntimeAffect {
                sentiment: None,
                sarcasm: false,
                intensity: None,
                formality: None,
                emotion: Some(RuntimeEmotion::Surprise),
                confidence: None,
            },
        })
    });

    define(interp, "loving", Some(1), |_, args| {
        Ok(Value::Affective {
            value: Box::new(args[0].clone()),
            affect: RuntimeAffect {
                sentiment: None,
                sarcasm: false,
                intensity: None,
                formality: None,
                emotion: Some(RuntimeEmotion::Love),
                confidence: None,
            },
        })
    });

    // Confidence markers
    define(interp, "high_confidence", Some(1), |_, args| {
        Ok(Value::Affective {
            value: Box::new(args[0].clone()),
            affect: RuntimeAffect {
                sentiment: None,
                sarcasm: false,
                intensity: None,
                formality: None,
                emotion: None,
                confidence: Some(RuntimeConfidence::High),
            },
        })
    });

    define(interp, "medium_confidence", Some(1), |_, args| {
        Ok(Value::Affective {
            value: Box::new(args[0].clone()),
            affect: RuntimeAffect {
                sentiment: None,
                sarcasm: false,
                intensity: None,
                formality: None,
                emotion: None,
                confidence: Some(RuntimeConfidence::Medium),
            },
        })
    });

    define(interp, "low_confidence", Some(1), |_, args| {
        Ok(Value::Affective {
            value: Box::new(args[0].clone()),
            affect: RuntimeAffect {
                sentiment: None,
                sarcasm: false,
                intensity: None,
                formality: None,
                emotion: None,
                confidence: Some(RuntimeConfidence::Low),
            },
        })
    });

    // === Query affect ===

    define(interp, "affect_of", Some(1), |_, args| match &args[0] {
        Value::Affective { affect, .. } => {
            let mut parts = Vec::new();
            if let Some(s) = &affect.sentiment {
                parts.push(match s {
                    RuntimeSentiment::Positive => "positive",
                    RuntimeSentiment::Negative => "negative",
                    RuntimeSentiment::Neutral => "neutral",
                });
            }
            if affect.sarcasm {
                parts.push("sarcastic");
            }
            if let Some(i) = &affect.intensity {
                parts.push(match i {
                    RuntimeIntensity::Up => "intensified",
                    RuntimeIntensity::Down => "dampened",
                    RuntimeIntensity::Max => "maximized",
                });
            }
            if let Some(f) = &affect.formality {
                parts.push(match f {
                    RuntimeFormality::Formal => "formal",
                    RuntimeFormality::Informal => "informal",
                });
            }
            if let Some(e) = &affect.emotion {
                parts.push(match e {
                    RuntimeEmotion::Joy => "joyful",
                    RuntimeEmotion::Sadness => "sad",
                    RuntimeEmotion::Anger => "angry",
                    RuntimeEmotion::Fear => "fearful",
                    RuntimeEmotion::Surprise => "surprised",
                    RuntimeEmotion::Love => "loving",
                });
            }
            if let Some(c) = &affect.confidence {
                parts.push(match c {
                    RuntimeConfidence::High => "high_confidence",
                    RuntimeConfidence::Medium => "medium_confidence",
                    RuntimeConfidence::Low => "low_confidence",
                });
            }
            Ok(Value::String(Rc::new(parts.join(", "))))
        }
        _ => Ok(Value::String(Rc::new("none".to_string()))),
    });

    define(interp, "is_sarcastic", Some(1), |_, args| match &args[0] {
        Value::Affective { affect, .. } => Ok(Value::Bool(affect.sarcasm)),
        _ => Ok(Value::Bool(false)),
    });

    define(interp, "is_positive", Some(1), |_, args| match &args[0] {
        Value::Affective { affect, .. } => Ok(Value::Bool(matches!(
            affect.sentiment,
            Some(RuntimeSentiment::Positive)
        ))),
        _ => Ok(Value::Bool(false)),
    });

    define(interp, "is_negative", Some(1), |_, args| match &args[0] {
        Value::Affective { affect, .. } => Ok(Value::Bool(matches!(
            affect.sentiment,
            Some(RuntimeSentiment::Negative)
        ))),
        _ => Ok(Value::Bool(false)),
    });

    define(interp, "is_formal", Some(1), |_, args| match &args[0] {
        Value::Affective { affect, .. } => Ok(Value::Bool(matches!(
            affect.formality,
            Some(RuntimeFormality::Formal)
        ))),
        _ => Ok(Value::Bool(false)),
    });

    define(interp, "is_informal", Some(1), |_, args| match &args[0] {
        Value::Affective { affect, .. } => Ok(Value::Bool(matches!(
            affect.formality,
            Some(RuntimeFormality::Informal)
        ))),
        _ => Ok(Value::Bool(false)),
    });

    define(interp, "emotion_of", Some(1), |_, args| match &args[0] {
        Value::Affective { affect, .. } => {
            let emotion_str = match &affect.emotion {
                Some(RuntimeEmotion::Joy) => "joy",
                Some(RuntimeEmotion::Sadness) => "sadness",
                Some(RuntimeEmotion::Anger) => "anger",
                Some(RuntimeEmotion::Fear) => "fear",
                Some(RuntimeEmotion::Surprise) => "surprise",
                Some(RuntimeEmotion::Love) => "love",
                None => "none",
            };
            Ok(Value::String(Rc::new(emotion_str.to_string())))
        }
        _ => Ok(Value::String(Rc::new("none".to_string()))),
    });

    define(interp, "confidence_of", Some(1), |_, args| match &args[0] {
        Value::Affective { affect, .. } => {
            let conf_str = match &affect.confidence {
                Some(RuntimeConfidence::High) => "high",
                Some(RuntimeConfidence::Medium) => "medium",
                Some(RuntimeConfidence::Low) => "low",
                None => "none",
            };
            Ok(Value::String(Rc::new(conf_str.to_string())))
        }
        _ => Ok(Value::String(Rc::new("none".to_string()))),
    });

    // Extract inner value
    define(interp, "strip_affect", Some(1), |_, args| match &args[0] {
        Value::Affective { value, .. } => Ok(*value.clone()),
        other => Ok(other.clone()),
    });

    // Create full affect with multiple markers
    define(interp, "with_affect", None, |_, args| {
        if args.is_empty() {
            return Err(RuntimeError::new(
                "with_affect requires at least one argument",
            ));
        }

        let base_value = args[0].clone();
        let mut affect = RuntimeAffect {
            sentiment: None,
            sarcasm: false,
            intensity: None,
            formality: None,
            emotion: None,
            confidence: None,
        };

        // Parse string markers from remaining args
        for arg in args.iter().skip(1) {
            if let Value::String(s) = arg {
                match s.as_str() {
                    "positive" | "⊕" => affect.sentiment = Some(RuntimeSentiment::Positive),
                    "negative" | "⊖" => affect.sentiment = Some(RuntimeSentiment::Negative),
                    "neutral" | "⊜" => affect.sentiment = Some(RuntimeSentiment::Neutral),
                    "sarcastic" | "⸮" => affect.sarcasm = true,
                    "intensify" | "↑" => affect.intensity = Some(RuntimeIntensity::Up),
                    "dampen" | "↓" => affect.intensity = Some(RuntimeIntensity::Down),
                    "maximize" | "⇈" => affect.intensity = Some(RuntimeIntensity::Max),
                    "formal" | "♔" => affect.formality = Some(RuntimeFormality::Formal),
                    "informal" | "♟" => affect.formality = Some(RuntimeFormality::Informal),
                    "joy" | "☺" => affect.emotion = Some(RuntimeEmotion::Joy),
                    "sadness" | "☹" => affect.emotion = Some(RuntimeEmotion::Sadness),
                    "anger" | "⚡" => affect.emotion = Some(RuntimeEmotion::Anger),
                    "fear" | "❄" => affect.emotion = Some(RuntimeEmotion::Fear),
                    "surprise" | "✦" => affect.emotion = Some(RuntimeEmotion::Surprise),
                    "love" | "♡" => affect.emotion = Some(RuntimeEmotion::Love),
                    "high" | "◉" => affect.confidence = Some(RuntimeConfidence::High),
                    "medium" | "◎" => affect.confidence = Some(RuntimeConfidence::Medium),
                    "low" | "○" => affect.confidence = Some(RuntimeConfidence::Low),
                    _ => {}
                }
            }
        }

        Ok(Value::Affective {
            value: Box::new(base_value),
            affect,
        })
    });
}

// ============================================================================
// ITERATOR-STYLE FUNCTIONS (for use in pipes)
// ============================================================================

fn register_iter(interp: &mut Interpreter) {
    // sum - sum all elements
    define(interp, "sum", Some(1), |_, args| match &args[0] {
        Value::Array(arr) => {
            let mut sum_int: i64 = 0;
            let mut sum_float: f64 = 0.0;
            let mut is_float = false;

            for val in arr.borrow().iter() {
                match val {
                    Value::Int(n) => {
                        if is_float {
                            sum_float += *n as f64;
                        } else {
                            sum_int += n;
                        }
                    }
                    Value::Float(n) => {
                        if !is_float {
                            sum_float = sum_int as f64;
                            is_float = true;
                        }
                        sum_float += n;
                    }
                    _ => return Err(RuntimeError::new("sum() requires array of numbers")),
                }
            }

            if is_float {
                Ok(Value::Float(sum_float))
            } else {
                Ok(Value::Int(sum_int))
            }
        }
        _ => Err(RuntimeError::new("sum() requires array")),
    });

    // product - multiply all elements
    define(interp, "product", Some(1), |_, args| match &args[0] {
        Value::Array(arr) => {
            let mut prod_int: i64 = 1;
            let mut prod_float: f64 = 1.0;
            let mut is_float = false;

            for val in arr.borrow().iter() {
                match val {
                    Value::Int(n) => {
                        if is_float {
                            prod_float *= *n as f64;
                        } else {
                            prod_int *= n;
                        }
                    }
                    Value::Float(n) => {
                        if !is_float {
                            prod_float = prod_int as f64;
                            is_float = true;
                        }
                        prod_float *= n;
                    }
                    _ => return Err(RuntimeError::new("product() requires array of numbers")),
                }
            }

            if is_float {
                Ok(Value::Float(prod_float))
            } else {
                Ok(Value::Int(prod_int))
            }
        }
        _ => Err(RuntimeError::new("product() requires array")),
    });

    // mean - average of elements
    define(interp, "mean", Some(1), |_, args| match &args[0] {
        Value::Array(arr) => {
            let arr = arr.borrow();
            if arr.is_empty() {
                return Err(RuntimeError::new("mean() on empty array"));
            }

            let mut sum: f64 = 0.0;
            for val in arr.iter() {
                match val {
                    Value::Int(n) => sum += *n as f64,
                    Value::Float(n) => sum += n,
                    _ => return Err(RuntimeError::new("mean() requires array of numbers")),
                }
            }

            Ok(Value::Float(sum / arr.len() as f64))
        }
        _ => Err(RuntimeError::new("mean() requires array")),
    });

    // median - middle value
    define(interp, "median", Some(1), |_, args| match &args[0] {
        Value::Array(arr) => {
            let arr = arr.borrow();
            if arr.is_empty() {
                return Err(RuntimeError::new("median() on empty array"));
            }

            let mut nums: Vec<f64> = Vec::new();
            for val in arr.iter() {
                match val {
                    Value::Int(n) => nums.push(*n as f64),
                    Value::Float(n) => nums.push(*n),
                    _ => return Err(RuntimeError::new("median() requires array of numbers")),
                }
            }

            nums.sort_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal));
            let mid = nums.len() / 2;

            if nums.len() % 2 == 0 {
                Ok(Value::Float((nums[mid - 1] + nums[mid]) / 2.0))
            } else {
                Ok(Value::Float(nums[mid]))
            }
        }
        _ => Err(RuntimeError::new("median() requires array")),
    });

    // min_of - minimum of array
    define(interp, "min_of", Some(1), |_, args| match &args[0] {
        Value::Array(arr) => {
            let arr = arr.borrow();
            if arr.is_empty() {
                return Err(RuntimeError::new("min_of() on empty array"));
            }

            let mut min = &arr[0];
            for val in arr.iter().skip(1) {
                if matches!(compare_values(val, min), std::cmp::Ordering::Less) {
                    min = val;
                }
            }
            Ok(min.clone())
        }
        _ => Err(RuntimeError::new("min_of() requires array")),
    });

    // max_of - maximum of array
    define(interp, "max_of", Some(1), |_, args| match &args[0] {
        Value::Array(arr) => {
            let arr = arr.borrow();
            if arr.is_empty() {
                return Err(RuntimeError::new("max_of() on empty array"));
            }

            let mut max = &arr[0];
            for val in arr.iter().skip(1) {
                if matches!(compare_values(val, max), std::cmp::Ordering::Greater) {
                    max = val;
                }
            }
            Ok(max.clone())
        }
        _ => Err(RuntimeError::new("max_of() requires array")),
    });

    // count - count elements (optionally matching predicate)
    define(interp, "count", Some(1), |_, args| match &args[0] {
        Value::Array(arr) => Ok(Value::Int(arr.borrow().len() as i64)),
        Value::String(s) => Ok(Value::Int(s.chars().count() as i64)),
        _ => Err(RuntimeError::new("count() requires array or string")),
    });

    // any - check if any element is truthy
    define(interp, "any", Some(1), |_, args| match &args[0] {
        Value::Array(arr) => {
            for val in arr.borrow().iter() {
                if is_truthy(val) {
                    return Ok(Value::Bool(true));
                }
            }
            Ok(Value::Bool(false))
        }
        _ => Err(RuntimeError::new("any() requires array")),
    });

    // all - check if all elements are truthy
    define(interp, "all", Some(1), |_, args| match &args[0] {
        Value::Array(arr) => {
            for val in arr.borrow().iter() {
                if !is_truthy(val) {
                    return Ok(Value::Bool(false));
                }
            }
            Ok(Value::Bool(true))
        }
        _ => Err(RuntimeError::new("all() requires array")),
    });

    // none - check if no elements are truthy
    define(interp, "none", Some(1), |_, args| match &args[0] {
        Value::Array(arr) => {
            for val in arr.borrow().iter() {
                if is_truthy(val) {
                    return Ok(Value::Bool(false));
                }
            }
            Ok(Value::Bool(true))
        }
        _ => Err(RuntimeError::new("none() requires array")),
    });
}

fn is_truthy(val: &Value) -> bool {
    match val {
        Value::Null | Value::Empty => false,
        Value::Bool(b) => *b,
        Value::Int(n) => *n != 0,
        Value::Float(n) => *n != 0.0 && !n.is_nan(),
        Value::String(s) => !s.is_empty(),
        Value::Array(arr) => !arr.borrow().is_empty(),
        Value::Evidential { value, .. } => is_truthy(value),
        _ => true,
    }
}

// ============================================================================
// I/O FUNCTIONS
// ============================================================================

fn register_io(interp: &mut Interpreter) {
    // read_file - read entire file as string
    define(interp, "read_file", Some(1), |_, args| {
        match &args[0] {
            Value::String(path) => {
                match std::fs::read_to_string(path.as_str()) {
                    Ok(content) => Ok(Value::Evidential {
                        value: Box::new(Value::String(Rc::new(content))),
                        evidence: Evidence::Reported, // File contents are reported, not known
                    }),
                    Err(e) => Err(RuntimeError::new(format!("read_file failed: {}", e))),
                }
            }
            _ => Err(RuntimeError::new("read_file() requires path string")),
        }
    });

    // write_file - write string to file
    define(interp, "write_file", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::String(path), Value::String(content)) => {
                match std::fs::write(path.as_str(), content.as_str()) {
                    Ok(_) => Ok(Value::Bool(true)),
                    Err(e) => Err(RuntimeError::new(format!("write_file failed: {}", e))),
                }
            }
            _ => Err(RuntimeError::new(
                "write_file() requires path and content strings",
            )),
        }
    });

    // append_file - append to file
    define(interp, "append_file", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::String(path), Value::String(content)) => {
                use std::fs::OpenOptions;
                let result = OpenOptions::new()
                    .create(true)
                    .append(true)
                    .open(path.as_str())
                    .and_then(|mut f| f.write_all(content.as_bytes()));
                match result {
                    Ok(_) => Ok(Value::Bool(true)),
                    Err(e) => Err(RuntimeError::new(format!("append_file failed: {}", e))),
                }
            }
            _ => Err(RuntimeError::new(
                "append_file() requires path and content strings",
            )),
        }
    });

    // file_exists - check if file exists
    define(interp, "file_exists", Some(1), |_, args| match &args[0] {
        Value::String(path) => Ok(Value::Bool(std::path::Path::new(path.as_str()).exists())),
        _ => Err(RuntimeError::new("file_exists() requires path string")),
    });

    // read_lines - read file as array of lines
    define(interp, "read_lines", Some(1), |_, args| match &args[0] {
        Value::String(path) => match std::fs::read_to_string(path.as_str()) {
            Ok(content) => {
                let lines: Vec<Value> = content
                    .lines()
                    .map(|l| Value::String(Rc::new(l.to_string())))
                    .collect();
                Ok(Value::Evidential {
                    value: Box::new(Value::Array(Rc::new(RefCell::new(lines)))),
                    evidence: Evidence::Reported,
                })
            }
            Err(e) => Err(RuntimeError::new(format!("read_lines failed: {}", e))),
        },
        _ => Err(RuntimeError::new("read_lines() requires path string")),
    });

    // env - get environment variable
    define(interp, "env", Some(1), |_, args| {
        match &args[0] {
            Value::String(name) => {
                match std::env::var(name.as_str()) {
                    Ok(value) => Ok(Value::Evidential {
                        value: Box::new(Value::String(Rc::new(value))),
                        evidence: Evidence::Reported, // Env vars are external
                    }),
                    Err(_) => Ok(Value::Null),
                }
            }
            _ => Err(RuntimeError::new("env() requires variable name string")),
        }
    });

    // env_or - get environment variable with default
    define(interp, "env_or", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::String(name), default) => match std::env::var(name.as_str()) {
                Ok(value) => Ok(Value::Evidential {
                    value: Box::new(Value::String(Rc::new(value))),
                    evidence: Evidence::Reported,
                }),
                Err(_) => Ok(default.clone()),
            },
            _ => Err(RuntimeError::new("env_or() requires variable name string")),
        }
    });

    // cwd - current working directory
    define(interp, "cwd", Some(0), |_, _| {
        match std::env::current_dir() {
            Ok(path) => Ok(Value::String(Rc::new(path.to_string_lossy().to_string()))),
            Err(e) => Err(RuntimeError::new(format!("cwd() failed: {}", e))),
        }
    });

    // args - command line arguments
    define(interp, "args", Some(0), |_, _| {
        let args: Vec<Value> = std::env::args()
            .map(|a| Value::String(Rc::new(a)))
            .collect();
        Ok(Value::Array(Rc::new(RefCell::new(args))))
    });
}

// ============================================================================
// TIME FUNCTIONS
// ============================================================================

fn register_time(interp: &mut Interpreter) {
    // now - current Unix timestamp in milliseconds
    define(interp, "now", Some(0), |_, _| {
        let duration = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap_or(Duration::ZERO);
        Ok(Value::Int(duration.as_millis() as i64))
    });

    // now_secs - current Unix timestamp in seconds
    define(interp, "now_secs", Some(0), |_, _| {
        let duration = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap_or(Duration::ZERO);
        Ok(Value::Int(duration.as_secs() as i64))
    });

    // now_micros - current Unix timestamp in microseconds
    define(interp, "now_micros", Some(0), |_, _| {
        let duration = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap_or(Duration::ZERO);
        Ok(Value::Int(duration.as_micros() as i64))
    });

    // sleep - sleep for milliseconds
    define(interp, "sleep", Some(1), |_, args| match &args[0] {
        Value::Int(ms) if *ms >= 0 => {
            std::thread::sleep(Duration::from_millis(*ms as u64));
            Ok(Value::Null)
        }
        _ => Err(RuntimeError::new(
            "sleep() requires non-negative integer milliseconds",
        )),
    });

    // measure - measure execution time of a thunk (returns ms)
    // Note: This would need closure support to work properly
    // For now, we provide a simple timer API

    // timer_start - start a timer (returns opaque handle)
    define(interp, "timer_start", Some(0), |_, _| {
        let now = Instant::now();
        // Store as microseconds since we can't store Instant directly
        Ok(Value::Int(now.elapsed().as_nanos() as i64)) // This is a bit hacky
    });
}

// ============================================================================
// RANDOM FUNCTIONS
// ============================================================================

fn register_random(interp: &mut Interpreter) {
    // random - random float 0.0 to 1.0
    define(interp, "random", Some(0), |_, _| {
        // Simple LCG random - not cryptographically secure
        use std::time::SystemTime;
        let seed = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap_or(Duration::ZERO)
            .as_nanos() as u64;
        let rand = ((seed.wrapping_mul(1103515245).wrapping_add(12345)) >> 16) as f64;
        Ok(Value::Float(rand / u32::MAX as f64))
    });

    // random_int - random integer in range [min, max)
    define(interp, "random_int", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::Int(min), Value::Int(max)) if max > min => {
                use std::time::SystemTime;
                let seed = SystemTime::now()
                    .duration_since(UNIX_EPOCH)
                    .unwrap_or(Duration::ZERO)
                    .as_nanos() as u64;
                let range = (max - min) as u64;
                let rand = ((seed.wrapping_mul(1103515245).wrapping_add(12345)) >> 16) % range;
                Ok(Value::Int(*min + rand as i64))
            }
            _ => Err(RuntimeError::new(
                "random_int() requires min < max integers",
            )),
        }
    });

    // shuffle - shuffle array in place (Fisher-Yates)
    define(interp, "shuffle", Some(1), |_, args| match &args[0] {
        Value::Array(arr) => {
            let mut arr = arr.borrow_mut();
            use std::time::SystemTime;
            let mut seed = SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap_or(Duration::ZERO)
                .as_nanos() as u64;

            for i in (1..arr.len()).rev() {
                seed = seed.wrapping_mul(1103515245).wrapping_add(12345);
                let j = ((seed >> 16) as usize) % (i + 1);
                arr.swap(i, j);
            }
            Ok(Value::Null)
        }
        _ => Err(RuntimeError::new("shuffle() requires array")),
    });

    // sample - random sample from array
    define(interp, "sample", Some(1), |_, args| match &args[0] {
        Value::Array(arr) => {
            let arr = arr.borrow();
            if arr.is_empty() {
                return Err(RuntimeError::new("sample() on empty array"));
            }

            use std::time::SystemTime;
            let seed = SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap_or(Duration::ZERO)
                .as_nanos() as u64;
            let idx =
                ((seed.wrapping_mul(1103515245).wrapping_add(12345)) >> 16) as usize % arr.len();
            Ok(arr[idx].clone())
        }
        _ => Err(RuntimeError::new("sample() requires array")),
    });
}

// ============================================================================
// CONVERSION FUNCTIONS
// ============================================================================

fn register_convert(interp: &mut Interpreter) {
    // to_string - convert to string
    define(interp, "to_string", Some(1), |_, args| {
        Ok(Value::String(Rc::new(format!("{}", args[0]))))
    });

    // to_int - convert to integer
    define(interp, "to_int", Some(1), |_, args| match &args[0] {
        Value::Int(n) => Ok(Value::Int(*n)),
        Value::Float(n) => Ok(Value::Int(*n as i64)),
        Value::Bool(b) => Ok(Value::Int(if *b { 1 } else { 0 })),
        Value::Char(c) => Ok(Value::Int(*c as i64)),
        Value::String(s) => s
            .parse::<i64>()
            .map(Value::Int)
            .map_err(|_| RuntimeError::new(format!("cannot parse '{}' as integer", s))),
        _ => Err(RuntimeError::new("to_int() cannot convert this type")),
    });

    // to_float - convert to float
    define(interp, "to_float", Some(1), |_, args| match &args[0] {
        Value::Int(n) => Ok(Value::Float(*n as f64)),
        Value::Float(n) => Ok(Value::Float(*n)),
        Value::Bool(b) => Ok(Value::Float(if *b { 1.0 } else { 0.0 })),
        Value::String(s) => s
            .parse::<f64>()
            .map(Value::Float)
            .map_err(|_| RuntimeError::new(format!("cannot parse '{}' as float", s))),
        _ => Err(RuntimeError::new("to_float() cannot convert this type")),
    });

    // to_bool - convert to boolean
    define(interp, "to_bool", Some(1), |_, args| {
        Ok(Value::Bool(is_truthy(&args[0])))
    });

    // to_char - convert to character
    define(interp, "to_char", Some(1), |_, args| match &args[0] {
        Value::Char(c) => Ok(Value::Char(*c)),
        Value::Int(n) => char::from_u32(*n as u32)
            .map(Value::Char)
            .ok_or_else(|| RuntimeError::new(format!("invalid char code: {}", n))),
        Value::String(s) => s
            .chars()
            .next()
            .map(Value::Char)
            .ok_or_else(|| RuntimeError::new("to_char() on empty string")),
        _ => Err(RuntimeError::new("to_char() cannot convert this type")),
    });

    // to_array - convert to array
    define(interp, "to_array", Some(1), |_, args| match &args[0] {
        Value::Array(arr) => Ok(Value::Array(arr.clone())),
        Value::Tuple(t) => Ok(Value::Array(Rc::new(RefCell::new(t.as_ref().clone())))),
        Value::String(s) => {
            let chars: Vec<Value> = s.chars().map(Value::Char).collect();
            Ok(Value::Array(Rc::new(RefCell::new(chars))))
        }
        _ => Ok(Value::Array(Rc::new(RefCell::new(vec![args[0].clone()])))),
    });

    // to_tuple - convert to tuple
    define(interp, "to_tuple", Some(1), |_, args| match &args[0] {
        Value::Tuple(t) => Ok(Value::Tuple(t.clone())),
        Value::Array(arr) => Ok(Value::Tuple(Rc::new(arr.borrow().clone()))),
        _ => Ok(Value::Tuple(Rc::new(vec![args[0].clone()]))),
    });

    // char_code - get unicode code point
    define(interp, "char_code", Some(1), |_, args| match &args[0] {
        Value::Char(c) => Ok(Value::Int(*c as i64)),
        _ => Err(RuntimeError::new("char_code() requires char")),
    });

    // from_char_code - create char from code point
    define(interp, "from_char_code", Some(1), |_, args| {
        match &args[0] {
            Value::Int(n) => char::from_u32(*n as u32)
                .map(Value::Char)
                .ok_or_else(|| RuntimeError::new(format!("invalid char code: {}", n))),
            _ => Err(RuntimeError::new("from_char_code() requires integer")),
        }
    });

    // hex - convert to hex string
    define(interp, "hex", Some(1), |_, args| match &args[0] {
        Value::Int(n) => Ok(Value::String(Rc::new(format!("{:x}", n)))),
        _ => Err(RuntimeError::new("hex() requires integer")),
    });

    // oct - convert to octal string
    define(interp, "oct", Some(1), |_, args| match &args[0] {
        Value::Int(n) => Ok(Value::String(Rc::new(format!("{:o}", n)))),
        _ => Err(RuntimeError::new("oct() requires integer")),
    });

    // bin - convert to binary string
    define(interp, "bin", Some(1), |_, args| match &args[0] {
        Value::Int(n) => Ok(Value::String(Rc::new(format!("{:b}", n)))),
        _ => Err(RuntimeError::new("bin() requires integer")),
    });

    // parse_int - parse string as integer with optional base
    define(interp, "parse_int", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::String(s), Value::Int(base)) if *base >= 2 && *base <= 36 => {
                i64::from_str_radix(s.trim(), *base as u32)
                    .map(Value::Int)
                    .map_err(|_| {
                        RuntimeError::new(format!("cannot parse '{}' as base-{} integer", s, base))
                    })
            }
            _ => Err(RuntimeError::new(
                "parse_int() requires string and base 2-36",
            )),
        }
    });
}

// ============================================================================
// CYCLE (MODULAR ARITHMETIC) FUNCTIONS
// For poly-cultural mathematics
// ============================================================================

fn register_cycle(interp: &mut Interpreter) {
    // cycle - create a cycle value (modular)
    define(interp, "cycle", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::Int(value), Value::Int(modulus)) if *modulus > 0 => {
                let normalized = value.rem_euclid(*modulus);
                Ok(Value::Tuple(Rc::new(vec![
                    Value::Int(normalized),
                    Value::Int(*modulus),
                ])))
            }
            _ => Err(RuntimeError::new(
                "cycle() requires value and positive modulus",
            )),
        }
    });

    // mod_add - modular addition
    define(interp, "mod_add", Some(3), |_, args| {
        match (&args[0], &args[1], &args[2]) {
            (Value::Int(a), Value::Int(b), Value::Int(m)) if *m > 0 => {
                Ok(Value::Int((a + b).rem_euclid(*m)))
            }
            _ => Err(RuntimeError::new(
                "mod_add() requires two integers and positive modulus",
            )),
        }
    });

    // mod_sub - modular subtraction
    define(interp, "mod_sub", Some(3), |_, args| {
        match (&args[0], &args[1], &args[2]) {
            (Value::Int(a), Value::Int(b), Value::Int(m)) if *m > 0 => {
                Ok(Value::Int((a - b).rem_euclid(*m)))
            }
            _ => Err(RuntimeError::new(
                "mod_sub() requires two integers and positive modulus",
            )),
        }
    });

    // mod_mul - modular multiplication
    define(interp, "mod_mul", Some(3), |_, args| {
        match (&args[0], &args[1], &args[2]) {
            (Value::Int(a), Value::Int(b), Value::Int(m)) if *m > 0 => {
                Ok(Value::Int((a * b).rem_euclid(*m)))
            }
            _ => Err(RuntimeError::new(
                "mod_mul() requires two integers and positive modulus",
            )),
        }
    });

    // mod_pow - modular exponentiation (fast)
    define(interp, "mod_pow", Some(3), |_, args| {
        match (&args[0], &args[1], &args[2]) {
            (Value::Int(base), Value::Int(exp), Value::Int(m)) if *m > 0 && *exp >= 0 => {
                Ok(Value::Int(mod_pow(*base, *exp as u64, *m)))
            }
            _ => Err(RuntimeError::new(
                "mod_pow() requires base, non-negative exp, and positive modulus",
            )),
        }
    });

    // mod_inv - modular multiplicative inverse (if exists)
    define(interp, "mod_inv", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::Int(a), Value::Int(m)) if *m > 0 => match mod_inverse(*a, *m) {
                Some(inv) => Ok(Value::Int(inv)),
                None => Err(RuntimeError::new(format!(
                    "no modular inverse of {} mod {}",
                    a, m
                ))),
            },
            _ => Err(RuntimeError::new(
                "mod_inv() requires integer and positive modulus",
            )),
        }
    });

    // Musical cycles (for tuning systems)
    // octave - normalize to octave (pitch class)
    define(interp, "octave", Some(1), |_, args| {
        match &args[0] {
            Value::Int(note) => Ok(Value::Int(note.rem_euclid(12))),
            Value::Float(freq) => {
                // Normalize frequency to octave starting at A4=440Hz
                let semitones = 12.0 * (freq / 440.0).log2();
                Ok(Value::Float(semitones.rem_euclid(12.0)))
            }
            _ => Err(RuntimeError::new("octave() requires number")),
        }
    });

    // interval - musical interval (semitones)
    define(interp, "interval", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::Int(a), Value::Int(b)) => Ok(Value::Int((b - a).rem_euclid(12))),
            _ => Err(RuntimeError::new("interval() requires two integers")),
        }
    });

    // cents - convert semitones to cents or vice versa
    define(interp, "cents", Some(1), |_, args| match &args[0] {
        Value::Int(semitones) => Ok(Value::Int(*semitones * 100)),
        Value::Float(semitones) => Ok(Value::Float(*semitones * 100.0)),
        _ => Err(RuntimeError::new("cents() requires number")),
    });

    // freq - convert MIDI note number to frequency
    define(interp, "freq", Some(1), |_, args| match &args[0] {
        Value::Int(midi) => {
            let freq = 440.0 * 2.0_f64.powf((*midi as f64 - 69.0) / 12.0);
            Ok(Value::Float(freq))
        }
        _ => Err(RuntimeError::new("freq() requires integer MIDI note")),
    });

    // midi - convert frequency to MIDI note number
    define(interp, "midi", Some(1), |_, args| match &args[0] {
        Value::Float(freq) if *freq > 0.0 => {
            let midi = 69.0 + 12.0 * (freq / 440.0).log2();
            Ok(Value::Int(midi.round() as i64))
        }
        Value::Int(freq) if *freq > 0 => {
            let midi = 69.0 + 12.0 * (*freq as f64 / 440.0).log2();
            Ok(Value::Int(midi.round() as i64))
        }
        _ => Err(RuntimeError::new("midi() requires positive frequency")),
    });
}

// Fast modular exponentiation
fn mod_pow(mut base: i64, mut exp: u64, modulus: i64) -> i64 {
    if modulus == 1 {
        return 0;
    }
    let mut result: i64 = 1;
    base = base.rem_euclid(modulus);
    while exp > 0 {
        if exp % 2 == 1 {
            result = (result * base).rem_euclid(modulus);
        }
        exp /= 2;
        base = (base * base).rem_euclid(modulus);
    }
    result
}

// ============================================================================
// SIMD VECTOR FUNCTIONS
// High-performance vector operations for game/graphics math
// ============================================================================

fn register_simd(interp: &mut Interpreter) {
    // simd_new - create a SIMD 4-component vector
    define(interp, "simd_new", Some(4), |_, args| {
        let values: Result<Vec<f64>, _> = args
            .iter()
            .map(|v| match v {
                Value::Float(f) => Ok(*f),
                Value::Int(i) => Ok(*i as f64),
                _ => Err(RuntimeError::new("simd_new() requires numbers")),
            })
            .collect();
        let values = values?;
        Ok(Value::Array(Rc::new(RefCell::new(vec![
            Value::Float(values[0]),
            Value::Float(values[1]),
            Value::Float(values[2]),
            Value::Float(values[3]),
        ]))))
    });

    // simd_splat - create vector with all same components
    define(interp, "simd_splat", Some(1), |_, args| {
        let v = match &args[0] {
            Value::Float(f) => *f,
            Value::Int(i) => *i as f64,
            _ => return Err(RuntimeError::new("simd_splat() requires number")),
        };
        Ok(Value::Array(Rc::new(RefCell::new(vec![
            Value::Float(v),
            Value::Float(v),
            Value::Float(v),
            Value::Float(v),
        ]))))
    });

    // simd_add - component-wise addition
    define(interp, "simd_add", Some(2), |_, args| {
        simd_binary_op(&args[0], &args[1], |a, b| a + b, "simd_add")
    });

    // simd_sub - component-wise subtraction
    define(interp, "simd_sub", Some(2), |_, args| {
        simd_binary_op(&args[0], &args[1], |a, b| a - b, "simd_sub")
    });

    // simd_mul - component-wise multiplication
    define(interp, "simd_mul", Some(2), |_, args| {
        simd_binary_op(&args[0], &args[1], |a, b| a * b, "simd_mul")
    });

    // simd_div - component-wise division
    define(interp, "simd_div", Some(2), |_, args| {
        simd_binary_op(&args[0], &args[1], |a, b| a / b, "simd_div")
    });

    // simd_dot - dot product of two vectors
    define(interp, "simd_dot", Some(2), |_, args| {
        let a = extract_simd(&args[0], "simd_dot")?;
        let b = extract_simd(&args[1], "simd_dot")?;
        let dot = a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
        Ok(Value::Float(dot))
    });

    // simd_cross - 3D cross product (w component set to 0)
    define(interp, "simd_cross", Some(2), |_, args| {
        let a = extract_simd(&args[0], "simd_cross")?;
        let b = extract_simd(&args[1], "simd_cross")?;
        Ok(Value::Array(Rc::new(RefCell::new(vec![
            Value::Float(a[1] * b[2] - a[2] * b[1]),
            Value::Float(a[2] * b[0] - a[0] * b[2]),
            Value::Float(a[0] * b[1] - a[1] * b[0]),
            Value::Float(0.0),
        ]))))
    });

    // simd_length - vector length (magnitude)
    define(interp, "simd_length", Some(1), |_, args| {
        let v = extract_simd(&args[0], "simd_length")?;
        let len_sq = v[0] * v[0] + v[1] * v[1] + v[2] * v[2] + v[3] * v[3];
        Ok(Value::Float(len_sq.sqrt()))
    });

    // simd_normalize - normalize vector to unit length
    define(interp, "simd_normalize", Some(1), |_, args| {
        let v = extract_simd(&args[0], "simd_normalize")?;
        let len_sq = v[0] * v[0] + v[1] * v[1] + v[2] * v[2] + v[3] * v[3];
        let len = len_sq.sqrt();
        if len < 1e-10 {
            return Ok(Value::Array(Rc::new(RefCell::new(vec![
                Value::Float(0.0),
                Value::Float(0.0),
                Value::Float(0.0),
                Value::Float(0.0),
            ]))));
        }
        let inv_len = 1.0 / len;
        Ok(Value::Array(Rc::new(RefCell::new(vec![
            Value::Float(v[0] * inv_len),
            Value::Float(v[1] * inv_len),
            Value::Float(v[2] * inv_len),
            Value::Float(v[3] * inv_len),
        ]))))
    });

    // simd_min - component-wise minimum
    define(interp, "simd_min", Some(2), |_, args| {
        simd_binary_op(&args[0], &args[1], |a, b| a.min(b), "simd_min")
    });

    // simd_max - component-wise maximum
    define(interp, "simd_max", Some(2), |_, args| {
        simd_binary_op(&args[0], &args[1], |a, b| a.max(b), "simd_max")
    });

    // simd_hadd - horizontal add (sum all components)
    define(interp, "simd_hadd", Some(1), |_, args| {
        let v = extract_simd(&args[0], "simd_hadd")?;
        Ok(Value::Float(v[0] + v[1] + v[2] + v[3]))
    });

    // simd_extract - extract single component (0-3)
    define(interp, "simd_extract", Some(2), |_, args| {
        let v = extract_simd(&args[0], "simd_extract")?;
        let idx = match &args[1] {
            Value::Int(i) => *i as usize,
            _ => return Err(RuntimeError::new("simd_extract() requires integer index")),
        };
        if idx > 3 {
            return Err(RuntimeError::new("simd_extract() index must be 0-3"));
        }
        Ok(Value::Float(v[idx]))
    });

    // simd_free - no-op in interpreter (for JIT compatibility)
    define(interp, "simd_free", Some(1), |_, _| Ok(Value::Null));

    // simd_lerp - linear interpolation between vectors
    define(interp, "simd_lerp", Some(3), |_, args| {
        let a = extract_simd(&args[0], "simd_lerp")?;
        let b = extract_simd(&args[1], "simd_lerp")?;
        let t = match &args[2] {
            Value::Float(f) => *f,
            Value::Int(i) => *i as f64,
            _ => return Err(RuntimeError::new("simd_lerp() requires float t")),
        };
        let one_t = 1.0 - t;
        Ok(Value::Array(Rc::new(RefCell::new(vec![
            Value::Float(a[0] * one_t + b[0] * t),
            Value::Float(a[1] * one_t + b[1] * t),
            Value::Float(a[2] * one_t + b[2] * t),
            Value::Float(a[3] * one_t + b[3] * t),
        ]))))
    });
}

// Helper to extract SIMD values from array
fn extract_simd(val: &Value, fn_name: &str) -> Result<[f64; 4], RuntimeError> {
    match val {
        Value::Array(arr) => {
            let arr = arr.borrow();
            if arr.len() < 4 {
                return Err(RuntimeError::new(format!(
                    "{}() requires 4-element array",
                    fn_name
                )));
            }
            let mut result = [0.0; 4];
            for (i, v) in arr.iter().take(4).enumerate() {
                result[i] = match v {
                    Value::Float(f) => *f,
                    Value::Int(n) => *n as f64,
                    _ => {
                        return Err(RuntimeError::new(format!(
                            "{}() requires numeric array",
                            fn_name
                        )))
                    }
                };
            }
            Ok(result)
        }
        _ => Err(RuntimeError::new(format!(
            "{}() requires array argument",
            fn_name
        ))),
    }
}

// Helper for binary SIMD operations
fn simd_binary_op<F>(a: &Value, b: &Value, op: F, fn_name: &str) -> Result<Value, RuntimeError>
where
    F: Fn(f64, f64) -> f64,
{
    let a = extract_simd(a, fn_name)?;
    let b = extract_simd(b, fn_name)?;
    Ok(Value::Array(Rc::new(RefCell::new(vec![
        Value::Float(op(a[0], b[0])),
        Value::Float(op(a[1], b[1])),
        Value::Float(op(a[2], b[2])),
        Value::Float(op(a[3], b[3])),
    ]))))
}

// ============================================================================
// GRAPHICS MATH LIBRARY
// ============================================================================
// Comprehensive 3D graphics mathematics for physics and rendering:
// - Quaternions for rotation without gimbal lock
// - vec2/vec3/vec4 vector types with swizzling
// - mat3/mat4 matrices with projection/view/model operations
// - Affine transforms, Euler angles, and interpolation
// ============================================================================

fn register_graphics_math(interp: &mut Interpreter) {
    // -------------------------------------------------------------------------
    // QUATERNIONS - Essential for 3D rotations
    // -------------------------------------------------------------------------
    // Quaternion format: [w, x, y, z] where w is scalar, (x,y,z) is vector part
    // This follows the convention: q = w + xi + yj + zk

    // quat_new(w, x, y, z) - create a quaternion
    define(interp, "quat_new", Some(4), |_, args| {
        let w = extract_number(&args[0], "quat_new")?;
        let x = extract_number(&args[1], "quat_new")?;
        let y = extract_number(&args[2], "quat_new")?;
        let z = extract_number(&args[3], "quat_new")?;
        Ok(make_vec4(w, x, y, z))
    });

    // quat_identity() - identity quaternion (no rotation)
    define(interp, "quat_identity", Some(0), |_, _| {
        Ok(make_vec4(1.0, 0.0, 0.0, 0.0))
    });

    // quat_from_axis_angle(axis_vec3, angle_radians) - create from axis-angle
    define(interp, "quat_from_axis_angle", Some(2), |_, args| {
        let axis = extract_vec3(&args[0], "quat_from_axis_angle")?;
        let angle = extract_number(&args[1], "quat_from_axis_angle")?;

        // Normalize axis
        let len = (axis[0] * axis[0] + axis[1] * axis[1] + axis[2] * axis[2]).sqrt();
        if len < 1e-10 {
            return Ok(make_vec4(1.0, 0.0, 0.0, 0.0)); // Identity for zero axis
        }
        let ax = axis[0] / len;
        let ay = axis[1] / len;
        let az = axis[2] / len;

        let half_angle = angle / 2.0;
        let s = half_angle.sin();
        let c = half_angle.cos();

        Ok(make_vec4(c, ax * s, ay * s, az * s))
    });

    // quat_from_euler(pitch, yaw, roll) - create from Euler angles (radians)
    // Uses XYZ order (pitch around X, yaw around Y, roll around Z)
    define(interp, "quat_from_euler", Some(3), |_, args| {
        let pitch = extract_number(&args[0], "quat_from_euler")?; // X
        let yaw = extract_number(&args[1], "quat_from_euler")?; // Y
        let roll = extract_number(&args[2], "quat_from_euler")?; // Z

        let (sp, cp) = (pitch / 2.0).sin_cos();
        let (sy, cy) = (yaw / 2.0).sin_cos();
        let (sr, cr) = (roll / 2.0).sin_cos();

        // Combined quaternion (XYZ order)
        let w = cp * cy * cr + sp * sy * sr;
        let x = sp * cy * cr - cp * sy * sr;
        let y = cp * sy * cr + sp * cy * sr;
        let z = cp * cy * sr - sp * sy * cr;

        Ok(make_vec4(w, x, y, z))
    });

    // quat_mul(q1, q2) - quaternion multiplication (q1 * q2)
    define(interp, "quat_mul", Some(2), |_, args| {
        let q1 = extract_vec4(&args[0], "quat_mul")?;
        let q2 = extract_vec4(&args[1], "quat_mul")?;

        // Hamilton product
        let w = q1[0] * q2[0] - q1[1] * q2[1] - q1[2] * q2[2] - q1[3] * q2[3];
        let x = q1[0] * q2[1] + q1[1] * q2[0] + q1[2] * q2[3] - q1[3] * q2[2];
        let y = q1[0] * q2[2] - q1[1] * q2[3] + q1[2] * q2[0] + q1[3] * q2[1];
        let z = q1[0] * q2[3] + q1[1] * q2[2] - q1[2] * q2[1] + q1[3] * q2[0];

        Ok(make_vec4(w, x, y, z))
    });

    // quat_conjugate(q) - quaternion conjugate (inverse for unit quaternions)
    define(interp, "quat_conjugate", Some(1), |_, args| {
        let q = extract_vec4(&args[0], "quat_conjugate")?;
        Ok(make_vec4(q[0], -q[1], -q[2], -q[3]))
    });

    // quat_inverse(q) - quaternion inverse (handles non-unit quaternions)
    define(interp, "quat_inverse", Some(1), |_, args| {
        let q = extract_vec4(&args[0], "quat_inverse")?;
        let norm_sq = q[0] * q[0] + q[1] * q[1] + q[2] * q[2] + q[3] * q[3];
        if norm_sq < 1e-10 {
            return Err(RuntimeError::new(
                "quat_inverse: cannot invert zero quaternion",
            ));
        }
        Ok(make_vec4(
            q[0] / norm_sq,
            -q[1] / norm_sq,
            -q[2] / norm_sq,
            -q[3] / norm_sq,
        ))
    });

    // quat_normalize(q) - normalize to unit quaternion
    define(interp, "quat_normalize", Some(1), |_, args| {
        let q = extract_vec4(&args[0], "quat_normalize")?;
        let len = (q[0] * q[0] + q[1] * q[1] + q[2] * q[2] + q[3] * q[3]).sqrt();
        if len < 1e-10 {
            return Ok(make_vec4(1.0, 0.0, 0.0, 0.0));
        }
        Ok(make_vec4(q[0] / len, q[1] / len, q[2] / len, q[3] / len))
    });

    // quat_rotate(q, vec3) - rotate a 3D vector by quaternion
    define(interp, "quat_rotate", Some(2), |_, args| {
        let q = extract_vec4(&args[0], "quat_rotate")?;
        let v = extract_vec3(&args[1], "quat_rotate")?;

        // q * v * q^-1 optimized formula
        let qw = q[0];
        let qx = q[1];
        let qy = q[2];
        let qz = q[3];
        let vx = v[0];
        let vy = v[1];
        let vz = v[2];

        // t = 2 * cross(q.xyz, v)
        let tx = 2.0 * (qy * vz - qz * vy);
        let ty = 2.0 * (qz * vx - qx * vz);
        let tz = 2.0 * (qx * vy - qy * vx);

        // result = v + q.w * t + cross(q.xyz, t)
        let rx = vx + qw * tx + (qy * tz - qz * ty);
        let ry = vy + qw * ty + (qz * tx - qx * tz);
        let rz = vz + qw * tz + (qx * ty - qy * tx);

        Ok(make_vec3(rx, ry, rz))
    });

    // quat_slerp(q1, q2, t) - spherical linear interpolation
    define(interp, "quat_slerp", Some(3), |_, args| {
        let q1 = extract_vec4(&args[0], "quat_slerp")?;
        let mut q2 = extract_vec4(&args[1], "quat_slerp")?;
        let t = extract_number(&args[2], "quat_slerp")?;

        // Compute dot product
        let mut dot = q1[0] * q2[0] + q1[1] * q2[1] + q1[2] * q2[2] + q1[3] * q2[3];

        // If dot < 0, negate q2 to take shorter path
        if dot < 0.0 {
            q2 = [-q2[0], -q2[1], -q2[2], -q2[3]];
            dot = -dot;
        }

        // If quaternions are very close, use linear interpolation
        if dot > 0.9995 {
            let w = q1[0] + t * (q2[0] - q1[0]);
            let x = q1[1] + t * (q2[1] - q1[1]);
            let y = q1[2] + t * (q2[2] - q1[2]);
            let z = q1[3] + t * (q2[3] - q1[3]);
            let len = (w * w + x * x + y * y + z * z).sqrt();
            return Ok(make_vec4(w / len, x / len, y / len, z / len));
        }

        // Spherical interpolation
        let theta_0 = dot.acos();
        let theta = theta_0 * t;
        let sin_theta = theta.sin();
        let sin_theta_0 = theta_0.sin();

        let s0 = (theta_0 - theta).cos() - dot * sin_theta / sin_theta_0;
        let s1 = sin_theta / sin_theta_0;

        Ok(make_vec4(
            s0 * q1[0] + s1 * q2[0],
            s0 * q1[1] + s1 * q2[1],
            s0 * q1[2] + s1 * q2[2],
            s0 * q1[3] + s1 * q2[3],
        ))
    });

    // quat_to_euler(q) - convert quaternion to Euler angles [pitch, yaw, roll]
    define(interp, "quat_to_euler", Some(1), |_, args| {
        let q = extract_vec4(&args[0], "quat_to_euler")?;
        let (w, x, y, z) = (q[0], q[1], q[2], q[3]);

        // Roll (X-axis rotation)
        let sinr_cosp = 2.0 * (w * x + y * z);
        let cosr_cosp = 1.0 - 2.0 * (x * x + y * y);
        let roll = sinr_cosp.atan2(cosr_cosp);

        // Pitch (Y-axis rotation)
        let sinp = 2.0 * (w * y - z * x);
        let pitch = if sinp.abs() >= 1.0 {
            std::f64::consts::FRAC_PI_2.copysign(sinp)
        } else {
            sinp.asin()
        };

        // Yaw (Z-axis rotation)
        let siny_cosp = 2.0 * (w * z + x * y);
        let cosy_cosp = 1.0 - 2.0 * (y * y + z * z);
        let yaw = siny_cosp.atan2(cosy_cosp);

        Ok(make_vec3(pitch, yaw, roll))
    });

    // quat_to_mat4(q) - convert quaternion to 4x4 rotation matrix
    define(interp, "quat_to_mat4", Some(1), |_, args| {
        let q = extract_vec4(&args[0], "quat_to_mat4")?;
        let (w, x, y, z) = (q[0], q[1], q[2], q[3]);

        let xx = x * x;
        let yy = y * y;
        let zz = z * z;
        let xy = x * y;
        let xz = x * z;
        let yz = y * z;
        let wx = w * x;
        let wy = w * y;
        let wz = w * z;

        // Column-major 4x4 rotation matrix
        Ok(make_mat4([
            1.0 - 2.0 * (yy + zz),
            2.0 * (xy + wz),
            2.0 * (xz - wy),
            0.0,
            2.0 * (xy - wz),
            1.0 - 2.0 * (xx + zz),
            2.0 * (yz + wx),
            0.0,
            2.0 * (xz + wy),
            2.0 * (yz - wx),
            1.0 - 2.0 * (xx + yy),
            0.0,
            0.0,
            0.0,
            0.0,
            1.0,
        ]))
    });

    // -------------------------------------------------------------------------
    // VECTOR TYPES - vec2, vec3, vec4
    // -------------------------------------------------------------------------

    // vec2(x, y)
    define(interp, "vec2", Some(2), |_, args| {
        let x = extract_number(&args[0], "vec2")?;
        let y = extract_number(&args[1], "vec2")?;
        Ok(make_vec2(x, y))
    });

    // vec3(x, y, z)
    define(interp, "vec3", Some(3), |_, args| {
        let x = extract_number(&args[0], "vec3")?;
        let y = extract_number(&args[1], "vec3")?;
        let z = extract_number(&args[2], "vec3")?;
        Ok(make_vec3(x, y, z))
    });

    // vec4(x, y, z, w)
    define(interp, "vec4", Some(4), |_, args| {
        let x = extract_number(&args[0], "vec4")?;
        let y = extract_number(&args[1], "vec4")?;
        let z = extract_number(&args[2], "vec4")?;
        let w = extract_number(&args[3], "vec4")?;
        Ok(make_vec4(x, y, z, w))
    });

    // vec3_add(a, b)
    define(interp, "vec3_add", Some(2), |_, args| {
        let a = extract_vec3(&args[0], "vec3_add")?;
        let b = extract_vec3(&args[1], "vec3_add")?;
        Ok(make_vec3(a[0] + b[0], a[1] + b[1], a[2] + b[2]))
    });

    // vec3_sub(a, b)
    define(interp, "vec3_sub", Some(2), |_, args| {
        let a = extract_vec3(&args[0], "vec3_sub")?;
        let b = extract_vec3(&args[1], "vec3_sub")?;
        Ok(make_vec3(a[0] - b[0], a[1] - b[1], a[2] - b[2]))
    });

    // vec3_scale(v, scalar)
    define(interp, "vec3_scale", Some(2), |_, args| {
        let v = extract_vec3(&args[0], "vec3_scale")?;
        let s = extract_number(&args[1], "vec3_scale")?;
        Ok(make_vec3(v[0] * s, v[1] * s, v[2] * s))
    });

    // vec3_dot(a, b)
    define(interp, "vec3_dot", Some(2), |_, args| {
        let a = extract_vec3(&args[0], "vec3_dot")?;
        let b = extract_vec3(&args[1], "vec3_dot")?;
        Ok(Value::Float(a[0] * b[0] + a[1] * b[1] + a[2] * b[2]))
    });

    // vec3_cross(a, b)
    define(interp, "vec3_cross", Some(2), |_, args| {
        let a = extract_vec3(&args[0], "vec3_cross")?;
        let b = extract_vec3(&args[1], "vec3_cross")?;
        Ok(make_vec3(
            a[1] * b[2] - a[2] * b[1],
            a[2] * b[0] - a[0] * b[2],
            a[0] * b[1] - a[1] * b[0],
        ))
    });

    // vec3_length(v)
    define(interp, "vec3_length", Some(1), |_, args| {
        let v = extract_vec3(&args[0], "vec3_length")?;
        Ok(Value::Float(
            (v[0] * v[0] + v[1] * v[1] + v[2] * v[2]).sqrt(),
        ))
    });

    // vec3_normalize(v)
    define(interp, "vec3_normalize", Some(1), |_, args| {
        let v = extract_vec3(&args[0], "vec3_normalize")?;
        let len = (v[0] * v[0] + v[1] * v[1] + v[2] * v[2]).sqrt();
        if len < 1e-10 {
            return Ok(make_vec3(0.0, 0.0, 0.0));
        }
        Ok(make_vec3(v[0] / len, v[1] / len, v[2] / len))
    });

    // vec3_lerp(a, b, t) - linear interpolation
    define(interp, "vec3_lerp", Some(3), |_, args| {
        let a = extract_vec3(&args[0], "vec3_lerp")?;
        let b = extract_vec3(&args[1], "vec3_lerp")?;
        let t = extract_number(&args[2], "vec3_lerp")?;
        Ok(make_vec3(
            a[0] + t * (b[0] - a[0]),
            a[1] + t * (b[1] - a[1]),
            a[2] + t * (b[2] - a[2]),
        ))
    });

    // vec3_reflect(incident, normal) - reflection vector
    define(interp, "vec3_reflect", Some(2), |_, args| {
        let i = extract_vec3(&args[0], "vec3_reflect")?;
        let n = extract_vec3(&args[1], "vec3_reflect")?;
        let dot = i[0] * n[0] + i[1] * n[1] + i[2] * n[2];
        Ok(make_vec3(
            i[0] - 2.0 * dot * n[0],
            i[1] - 2.0 * dot * n[1],
            i[2] - 2.0 * dot * n[2],
        ))
    });

    // vec3_refract(incident, normal, eta) - refraction vector
    define(interp, "vec3_refract", Some(3), |_, args| {
        let i = extract_vec3(&args[0], "vec3_refract")?;
        let n = extract_vec3(&args[1], "vec3_refract")?;
        let eta = extract_number(&args[2], "vec3_refract")?;

        let dot = i[0] * n[0] + i[1] * n[1] + i[2] * n[2];
        let k = 1.0 - eta * eta * (1.0 - dot * dot);

        if k < 0.0 {
            // Total internal reflection
            return Ok(make_vec3(0.0, 0.0, 0.0));
        }

        let coeff = eta * dot + k.sqrt();
        Ok(make_vec3(
            eta * i[0] - coeff * n[0],
            eta * i[1] - coeff * n[1],
            eta * i[2] - coeff * n[2],
        ))
    });

    // vec4_dot(a, b)
    define(interp, "vec4_dot", Some(2), |_, args| {
        let a = extract_vec4(&args[0], "vec4_dot")?;
        let b = extract_vec4(&args[1], "vec4_dot")?;
        Ok(Value::Float(
            a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3],
        ))
    });

    // -------------------------------------------------------------------------
    // MAT4 - 4x4 MATRICES (Column-major for OpenGL compatibility)
    // -------------------------------------------------------------------------

    // mat4_identity() - 4x4 identity matrix
    define(interp, "mat4_identity", Some(0), |_, _| {
        Ok(make_mat4([
            1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0,
        ]))
    });

    // mat4_mul(a, b) - matrix multiplication
    define(interp, "mat4_mul", Some(2), |_, args| {
        let a = extract_mat4(&args[0], "mat4_mul")?;
        let b = extract_mat4(&args[1], "mat4_mul")?;

        let mut result = [0.0f64; 16];
        for col in 0..4 {
            for row in 0..4 {
                let mut sum = 0.0;
                for k in 0..4 {
                    sum += a[k * 4 + row] * b[col * 4 + k];
                }
                result[col * 4 + row] = sum;
            }
        }
        Ok(make_mat4(result))
    });

    // mat4_transform(mat4, vec4) - transform vector by matrix
    define(interp, "mat4_transform", Some(2), |_, args| {
        let m = extract_mat4(&args[0], "mat4_transform")?;
        let v = extract_vec4(&args[1], "mat4_transform")?;

        Ok(make_vec4(
            m[0] * v[0] + m[4] * v[1] + m[8] * v[2] + m[12] * v[3],
            m[1] * v[0] + m[5] * v[1] + m[9] * v[2] + m[13] * v[3],
            m[2] * v[0] + m[6] * v[1] + m[10] * v[2] + m[14] * v[3],
            m[3] * v[0] + m[7] * v[1] + m[11] * v[2] + m[15] * v[3],
        ))
    });

    // mat4_translate(tx, ty, tz) - translation matrix
    define(interp, "mat4_translate", Some(3), |_, args| {
        let tx = extract_number(&args[0], "mat4_translate")?;
        let ty = extract_number(&args[1], "mat4_translate")?;
        let tz = extract_number(&args[2], "mat4_translate")?;
        Ok(make_mat4([
            1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, tx, ty, tz, 1.0,
        ]))
    });

    // mat4_scale(sx, sy, sz) - scale matrix
    define(interp, "mat4_scale", Some(3), |_, args| {
        let sx = extract_number(&args[0], "mat4_scale")?;
        let sy = extract_number(&args[1], "mat4_scale")?;
        let sz = extract_number(&args[2], "mat4_scale")?;
        Ok(make_mat4([
            sx, 0.0, 0.0, 0.0, 0.0, sy, 0.0, 0.0, 0.0, 0.0, sz, 0.0, 0.0, 0.0, 0.0, 1.0,
        ]))
    });

    // mat4_rotate_x(angle) - rotation around X axis
    define(interp, "mat4_rotate_x", Some(1), |_, args| {
        let angle = extract_number(&args[0], "mat4_rotate_x")?;
        let (s, c) = angle.sin_cos();
        Ok(make_mat4([
            1.0, 0.0, 0.0, 0.0, 0.0, c, s, 0.0, 0.0, -s, c, 0.0, 0.0, 0.0, 0.0, 1.0,
        ]))
    });

    // mat4_rotate_y(angle) - rotation around Y axis
    define(interp, "mat4_rotate_y", Some(1), |_, args| {
        let angle = extract_number(&args[0], "mat4_rotate_y")?;
        let (s, c) = angle.sin_cos();
        Ok(make_mat4([
            c, 0.0, -s, 0.0, 0.0, 1.0, 0.0, 0.0, s, 0.0, c, 0.0, 0.0, 0.0, 0.0, 1.0,
        ]))
    });

    // mat4_rotate_z(angle) - rotation around Z axis
    define(interp, "mat4_rotate_z", Some(1), |_, args| {
        let angle = extract_number(&args[0], "mat4_rotate_z")?;
        let (s, c) = angle.sin_cos();
        Ok(make_mat4([
            c, s, 0.0, 0.0, -s, c, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0,
        ]))
    });

    // mat4_perspective(fov_y, aspect, near, far) - perspective projection
    define(interp, "mat4_perspective", Some(4), |_, args| {
        let fov_y = extract_number(&args[0], "mat4_perspective")?;
        let aspect = extract_number(&args[1], "mat4_perspective")?;
        let near = extract_number(&args[2], "mat4_perspective")?;
        let far = extract_number(&args[3], "mat4_perspective")?;

        let f = 1.0 / (fov_y / 2.0).tan();
        let nf = 1.0 / (near - far);

        Ok(make_mat4([
            f / aspect,
            0.0,
            0.0,
            0.0,
            0.0,
            f,
            0.0,
            0.0,
            0.0,
            0.0,
            (far + near) * nf,
            -1.0,
            0.0,
            0.0,
            2.0 * far * near * nf,
            0.0,
        ]))
    });

    // mat4_ortho(left, right, bottom, top, near, far) - orthographic projection
    define(interp, "mat4_ortho", Some(6), |_, args| {
        let left = extract_number(&args[0], "mat4_ortho")?;
        let right = extract_number(&args[1], "mat4_ortho")?;
        let bottom = extract_number(&args[2], "mat4_ortho")?;
        let top = extract_number(&args[3], "mat4_ortho")?;
        let near = extract_number(&args[4], "mat4_ortho")?;
        let far = extract_number(&args[5], "mat4_ortho")?;

        let lr = 1.0 / (left - right);
        let bt = 1.0 / (bottom - top);
        let nf = 1.0 / (near - far);

        Ok(make_mat4([
            -2.0 * lr,
            0.0,
            0.0,
            0.0,
            0.0,
            -2.0 * bt,
            0.0,
            0.0,
            0.0,
            0.0,
            2.0 * nf,
            0.0,
            (left + right) * lr,
            (top + bottom) * bt,
            (far + near) * nf,
            1.0,
        ]))
    });

    // mat4_look_at(eye, center, up) - view matrix (camera)
    define(interp, "mat4_look_at", Some(3), |_, args| {
        let eye = extract_vec3(&args[0], "mat4_look_at")?;
        let center = extract_vec3(&args[1], "mat4_look_at")?;
        let up = extract_vec3(&args[2], "mat4_look_at")?;

        // Forward vector (z)
        let fx = center[0] - eye[0];
        let fy = center[1] - eye[1];
        let fz = center[2] - eye[2];
        let flen = (fx * fx + fy * fy + fz * fz).sqrt();
        let (fx, fy, fz) = (fx / flen, fy / flen, fz / flen);

        // Right vector (x) = forward × up
        let rx = fy * up[2] - fz * up[1];
        let ry = fz * up[0] - fx * up[2];
        let rz = fx * up[1] - fy * up[0];
        let rlen = (rx * rx + ry * ry + rz * rz).sqrt();
        let (rx, ry, rz) = (rx / rlen, ry / rlen, rz / rlen);

        // True up vector (y) = right × forward
        let ux = ry * fz - rz * fy;
        let uy = rz * fx - rx * fz;
        let uz = rx * fy - ry * fx;

        Ok(make_mat4([
            rx,
            ux,
            -fx,
            0.0,
            ry,
            uy,
            -fy,
            0.0,
            rz,
            uz,
            -fz,
            0.0,
            -(rx * eye[0] + ry * eye[1] + rz * eye[2]),
            -(ux * eye[0] + uy * eye[1] + uz * eye[2]),
            -(-fx * eye[0] - fy * eye[1] - fz * eye[2]),
            1.0,
        ]))
    });

    // mat4_inverse(m) - matrix inverse (for transformation matrices)
    define(interp, "mat4_inverse", Some(1), |_, args| {
        let m = extract_mat4(&args[0], "mat4_inverse")?;

        // Optimized 4x4 matrix inverse using cofactors
        let a00 = m[0];
        let a01 = m[1];
        let a02 = m[2];
        let a03 = m[3];
        let a10 = m[4];
        let a11 = m[5];
        let a12 = m[6];
        let a13 = m[7];
        let a20 = m[8];
        let a21 = m[9];
        let a22 = m[10];
        let a23 = m[11];
        let a30 = m[12];
        let a31 = m[13];
        let a32 = m[14];
        let a33 = m[15];

        let b00 = a00 * a11 - a01 * a10;
        let b01 = a00 * a12 - a02 * a10;
        let b02 = a00 * a13 - a03 * a10;
        let b03 = a01 * a12 - a02 * a11;
        let b04 = a01 * a13 - a03 * a11;
        let b05 = a02 * a13 - a03 * a12;
        let b06 = a20 * a31 - a21 * a30;
        let b07 = a20 * a32 - a22 * a30;
        let b08 = a20 * a33 - a23 * a30;
        let b09 = a21 * a32 - a22 * a31;
        let b10 = a21 * a33 - a23 * a31;
        let b11 = a22 * a33 - a23 * a32;

        let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

        if det.abs() < 1e-10 {
            return Err(RuntimeError::new("mat4_inverse: singular matrix"));
        }

        let inv_det = 1.0 / det;

        Ok(make_mat4([
            (a11 * b11 - a12 * b10 + a13 * b09) * inv_det,
            (a02 * b10 - a01 * b11 - a03 * b09) * inv_det,
            (a31 * b05 - a32 * b04 + a33 * b03) * inv_det,
            (a22 * b04 - a21 * b05 - a23 * b03) * inv_det,
            (a12 * b08 - a10 * b11 - a13 * b07) * inv_det,
            (a00 * b11 - a02 * b08 + a03 * b07) * inv_det,
            (a32 * b02 - a30 * b05 - a33 * b01) * inv_det,
            (a20 * b05 - a22 * b02 + a23 * b01) * inv_det,
            (a10 * b10 - a11 * b08 + a13 * b06) * inv_det,
            (a01 * b08 - a00 * b10 - a03 * b06) * inv_det,
            (a30 * b04 - a31 * b02 + a33 * b00) * inv_det,
            (a21 * b02 - a20 * b04 - a23 * b00) * inv_det,
            (a11 * b07 - a10 * b09 - a12 * b06) * inv_det,
            (a00 * b09 - a01 * b07 + a02 * b06) * inv_det,
            (a31 * b01 - a30 * b03 - a32 * b00) * inv_det,
            (a20 * b03 - a21 * b01 + a22 * b00) * inv_det,
        ]))
    });

    // mat4_transpose(m) - transpose matrix
    define(interp, "mat4_transpose", Some(1), |_, args| {
        let m = extract_mat4(&args[0], "mat4_transpose")?;
        Ok(make_mat4([
            m[0], m[4], m[8], m[12], m[1], m[5], m[9], m[13], m[2], m[6], m[10], m[14], m[3], m[7],
            m[11], m[15],
        ]))
    });

    // -------------------------------------------------------------------------
    // MAT3 - 3x3 MATRICES (for normals, 2D transforms)
    // -------------------------------------------------------------------------

    // mat3_identity() - 3x3 identity matrix
    define(interp, "mat3_identity", Some(0), |_, _| {
        Ok(make_mat3([1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0]))
    });

    // mat3_from_mat4(m) - extract upper-left 3x3 from 4x4 (for normal matrix)
    define(interp, "mat3_from_mat4", Some(1), |_, args| {
        let m = extract_mat4(&args[0], "mat3_from_mat4")?;
        Ok(make_mat3([
            m[0], m[1], m[2], m[4], m[5], m[6], m[8], m[9], m[10],
        ]))
    });

    // mat3_mul(a, b) - 3x3 matrix multiplication
    define(interp, "mat3_mul", Some(2), |_, args| {
        let a = extract_mat3(&args[0], "mat3_mul")?;
        let b = extract_mat3(&args[1], "mat3_mul")?;

        let mut result = [0.0f64; 9];
        for col in 0..3 {
            for row in 0..3 {
                let mut sum = 0.0;
                for k in 0..3 {
                    sum += a[k * 3 + row] * b[col * 3 + k];
                }
                result[col * 3 + row] = sum;
            }
        }
        Ok(make_mat3(result))
    });

    // mat3_transform(mat3, vec3) - transform 3D vector by 3x3 matrix
    define(interp, "mat3_transform", Some(2), |_, args| {
        let m = extract_mat3(&args[0], "mat3_transform")?;
        let v = extract_vec3(&args[1], "mat3_transform")?;

        Ok(make_vec3(
            m[0] * v[0] + m[3] * v[1] + m[6] * v[2],
            m[1] * v[0] + m[4] * v[1] + m[7] * v[2],
            m[2] * v[0] + m[5] * v[1] + m[8] * v[2],
        ))
    });

    // mat3_inverse(m) - 3x3 matrix inverse
    define(interp, "mat3_inverse", Some(1), |_, args| {
        let m = extract_mat3(&args[0], "mat3_inverse")?;

        let det = m[0] * (m[4] * m[8] - m[5] * m[7]) - m[3] * (m[1] * m[8] - m[2] * m[7])
            + m[6] * (m[1] * m[5] - m[2] * m[4]);

        if det.abs() < 1e-10 {
            return Err(RuntimeError::new("mat3_inverse: singular matrix"));
        }

        let inv_det = 1.0 / det;

        Ok(make_mat3([
            (m[4] * m[8] - m[5] * m[7]) * inv_det,
            (m[2] * m[7] - m[1] * m[8]) * inv_det,
            (m[1] * m[5] - m[2] * m[4]) * inv_det,
            (m[5] * m[6] - m[3] * m[8]) * inv_det,
            (m[0] * m[8] - m[2] * m[6]) * inv_det,
            (m[2] * m[3] - m[0] * m[5]) * inv_det,
            (m[3] * m[7] - m[4] * m[6]) * inv_det,
            (m[1] * m[6] - m[0] * m[7]) * inv_det,
            (m[0] * m[4] - m[1] * m[3]) * inv_det,
        ]))
    });

    // mat3_transpose(m)
    define(interp, "mat3_transpose", Some(1), |_, args| {
        let m = extract_mat3(&args[0], "mat3_transpose")?;
        Ok(make_mat3([
            m[0], m[3], m[6], m[1], m[4], m[7], m[2], m[5], m[8],
        ]))
    });
}

// Helper functions for graphics math
fn extract_number(v: &Value, fn_name: &str) -> Result<f64, RuntimeError> {
    match v {
        Value::Float(f) => Ok(*f),
        Value::Int(i) => Ok(*i as f64),
        _ => Err(RuntimeError::new(format!(
            "{}() requires number argument",
            fn_name
        ))),
    }
}

fn extract_vec2(v: &Value, fn_name: &str) -> Result<[f64; 2], RuntimeError> {
    match v {
        Value::Array(arr) => {
            let arr = arr.borrow();
            if arr.len() < 2 {
                return Err(RuntimeError::new(format!(
                    "{}() requires vec2 (2 elements)",
                    fn_name
                )));
            }
            Ok([
                extract_number(&arr[0], fn_name)?,
                extract_number(&arr[1], fn_name)?,
            ])
        }
        _ => Err(RuntimeError::new(format!(
            "{}() requires vec2 array",
            fn_name
        ))),
    }
}

fn extract_vec3(v: &Value, fn_name: &str) -> Result<[f64; 3], RuntimeError> {
    match v {
        Value::Array(arr) => {
            let arr = arr.borrow();
            if arr.len() < 3 {
                return Err(RuntimeError::new(format!(
                    "{}() requires vec3 (3 elements)",
                    fn_name
                )));
            }
            Ok([
                extract_number(&arr[0], fn_name)?,
                extract_number(&arr[1], fn_name)?,
                extract_number(&arr[2], fn_name)?,
            ])
        }
        _ => Err(RuntimeError::new(format!(
            "{}() requires vec3 array",
            fn_name
        ))),
    }
}

fn extract_vec4(v: &Value, fn_name: &str) -> Result<[f64; 4], RuntimeError> {
    match v {
        Value::Array(arr) => {
            let arr = arr.borrow();
            if arr.len() < 4 {
                return Err(RuntimeError::new(format!(
                    "{}() requires vec4 (4 elements)",
                    fn_name
                )));
            }
            Ok([
                extract_number(&arr[0], fn_name)?,
                extract_number(&arr[1], fn_name)?,
                extract_number(&arr[2], fn_name)?,
                extract_number(&arr[3], fn_name)?,
            ])
        }
        _ => Err(RuntimeError::new(format!(
            "{}() requires vec4 array",
            fn_name
        ))),
    }
}

fn extract_mat3(v: &Value, fn_name: &str) -> Result<[f64; 9], RuntimeError> {
    match v {
        Value::Array(arr) => {
            let arr = arr.borrow();
            if arr.len() < 9 {
                return Err(RuntimeError::new(format!(
                    "{}() requires mat3 (9 elements)",
                    fn_name
                )));
            }
            let mut result = [0.0f64; 9];
            for i in 0..9 {
                result[i] = extract_number(&arr[i], fn_name)?;
            }
            Ok(result)
        }
        _ => Err(RuntimeError::new(format!(
            "{}() requires mat3 array",
            fn_name
        ))),
    }
}

fn extract_mat4(v: &Value, fn_name: &str) -> Result<[f64; 16], RuntimeError> {
    match v {
        Value::Array(arr) => {
            let arr = arr.borrow();
            if arr.len() < 16 {
                return Err(RuntimeError::new(format!(
                    "{}() requires mat4 (16 elements)",
                    fn_name
                )));
            }
            let mut result = [0.0f64; 16];
            for i in 0..16 {
                result[i] = extract_number(&arr[i], fn_name)?;
            }
            Ok(result)
        }
        _ => Err(RuntimeError::new(format!(
            "{}() requires mat4 array",
            fn_name
        ))),
    }
}

fn make_vec2(x: f64, y: f64) -> Value {
    Value::Array(Rc::new(RefCell::new(vec![
        Value::Float(x),
        Value::Float(y),
    ])))
}

fn make_vec3(x: f64, y: f64, z: f64) -> Value {
    Value::Array(Rc::new(RefCell::new(vec![
        Value::Float(x),
        Value::Float(y),
        Value::Float(z),
    ])))
}

// Helper for making vec3 from array
fn make_vec3_arr(v: [f64; 3]) -> Value {
    make_vec3(v[0], v[1], v[2])
}

fn make_vec4(x: f64, y: f64, z: f64, w: f64) -> Value {
    Value::Array(Rc::new(RefCell::new(vec![
        Value::Float(x),
        Value::Float(y),
        Value::Float(z),
        Value::Float(w),
    ])))
}

fn make_mat3(m: [f64; 9]) -> Value {
    Value::Array(Rc::new(RefCell::new(
        m.iter().map(|&v| Value::Float(v)).collect(),
    )))
}

fn make_mat4(m: [f64; 16]) -> Value {
    Value::Array(Rc::new(RefCell::new(
        m.iter().map(|&v| Value::Float(v)).collect(),
    )))
}

// ============================================================================
// CONCURRENCY FUNCTIONS
// ============================================================================
// WARNING: Interpreter Limitations
// ---------------------------------
// The interpreter uses Rc<RefCell<>> which is NOT thread-safe (not Send/Sync).
// This means:
// - Channels work but block the main thread
// - Actors run single-threaded with message queuing
// - Thread primitives simulate behavior but don't provide true parallelism
// - Atomics work correctly for single-threaded access patterns
//
// For true parallel execution, compile with the JIT backend (--jit flag).
// The JIT uses Arc/Mutex and compiles to native code with proper threading.
// ============================================================================

fn register_concurrency(interp: &mut Interpreter) {
    // --- CHANNELS ---

    // channel_new - create a new channel for message passing
    define(interp, "channel_new", Some(0), |_, _| {
        let (sender, receiver) = mpsc::channel();
        let inner = ChannelInner {
            sender: Mutex::new(sender),
            receiver: Mutex::new(receiver),
        };
        Ok(Value::Channel(Arc::new(inner)))
    });

    // channel_send - send a value on a channel (blocking)
    define(interp, "channel_send", Some(2), |_, args| {
        let channel = match &args[0] {
            Value::Channel(ch) => ch.clone(),
            _ => {
                return Err(RuntimeError::new(
                    "channel_send() requires channel as first argument",
                ))
            }
        };
        let value = args[1].clone();

        let sender = channel
            .sender
            .lock()
            .map_err(|_| RuntimeError::new("channel mutex poisoned"))?;
        sender
            .send(value)
            .map_err(|_| RuntimeError::new("channel_send() failed: receiver dropped"))?;

        Ok(Value::Null)
    });

    // channel_recv - receive a value from a channel (blocking)
    define(interp, "channel_recv", Some(1), |_, args| {
        let channel = match &args[0] {
            Value::Channel(ch) => ch.clone(),
            _ => {
                return Err(RuntimeError::new(
                    "channel_recv() requires channel argument",
                ))
            }
        };

        let receiver = channel
            .receiver
            .lock()
            .map_err(|_| RuntimeError::new("channel mutex poisoned"))?;
        match receiver.recv() {
            Ok(value) => Ok(value),
            Err(_) => Err(RuntimeError::new("channel_recv() failed: sender dropped")),
        }
    });

    // channel_try_recv - non-blocking receive, returns Option
    define(interp, "channel_try_recv", Some(1), |_, args| {
        let channel = match &args[0] {
            Value::Channel(ch) => ch.clone(),
            _ => {
                return Err(RuntimeError::new(
                    "channel_try_recv() requires channel argument",
                ))
            }
        };

        let receiver = channel
            .receiver
            .lock()
            .map_err(|_| RuntimeError::new("channel mutex poisoned"))?;
        match receiver.try_recv() {
            Ok(value) => {
                // Return Some(value) as a variant
                Ok(Value::Variant {
                    enum_name: "Option".to_string(),
                    variant_name: "Some".to_string(),
                    fields: Some(Rc::new(vec![value])),
                })
            }
            Err(mpsc::TryRecvError::Empty) => {
                // Return None
                Ok(Value::Variant {
                    enum_name: "Option".to_string(),
                    variant_name: "None".to_string(),
                    fields: None,
                })
            }
            Err(mpsc::TryRecvError::Disconnected) => Err(RuntimeError::new(
                "channel_try_recv() failed: sender dropped",
            )),
        }
    });

    // channel_recv_timeout - receive with timeout in milliseconds
    define(interp, "channel_recv_timeout", Some(2), |_, args| {
        let channel = match &args[0] {
            Value::Channel(ch) => ch.clone(),
            _ => {
                return Err(RuntimeError::new(
                    "channel_recv_timeout() requires a channel as first argument.\n\
                 Create a channel with channel_new():\n\
                   let ch = channel_new();\n\
                   channel_send(ch, value);\n\
                   let result = channel_recv_timeout(ch, 1000);  // 1 second timeout",
                ))
            }
        };
        let timeout_ms = match &args[1] {
            Value::Int(ms) => *ms as u64,
            _ => {
                return Err(RuntimeError::new(
                    "channel_recv_timeout() requires timeout in milliseconds (integer).\n\
                 Example: channel_recv_timeout(ch, 1000)  // Wait up to 1 second",
                ))
            }
        };

        let receiver = channel
            .receiver
            .lock()
            .map_err(|_| RuntimeError::new("channel mutex poisoned"))?;
        match receiver.recv_timeout(std::time::Duration::from_millis(timeout_ms)) {
            Ok(value) => Ok(Value::Variant {
                enum_name: "Option".to_string(),
                variant_name: "Some".to_string(),
                fields: Some(Rc::new(vec![value])),
            }),
            Err(mpsc::RecvTimeoutError::Timeout) => Ok(Value::Variant {
                enum_name: "Option".to_string(),
                variant_name: "None".to_string(),
                fields: None,
            }),
            Err(mpsc::RecvTimeoutError::Disconnected) => Err(RuntimeError::new(
                "channel_recv_timeout() failed: sender dropped",
            )),
        }
    });

    // --- THREADS ---
    // Note: The interpreter's Value type uses Rc which is not Send.
    // For true threading, use channels to communicate primitive types.
    // These functions provide basic thread primitives.

    // thread_spawn_detached - spawn a detached thread (no join)
    // Useful for background work, results communicated via channels
    define(interp, "thread_spawn_detached", Some(0), |_, _| {
        // Spawn a simple detached thread that does nothing
        // Real work should be done via channels
        thread::spawn(|| {
            // Background thread
        });
        Ok(Value::Null)
    });

    // thread_join - placeholder for join semantics
    // In interpreter, actual work is done via channels
    define(interp, "thread_join", Some(1), |_, args| {
        match &args[0] {
            Value::ThreadHandle(h) => {
                let mut guard = h
                    .lock()
                    .map_err(|_| RuntimeError::new("thread handle mutex poisoned"))?;
                if let Some(handle) = guard.take() {
                    match handle.join() {
                        Ok(v) => Ok(v),
                        Err(_) => Err(RuntimeError::new("thread panicked")),
                    }
                } else {
                    Err(RuntimeError::new("thread already joined"))
                }
            }
            // For non-handles, just return the value
            _ => Ok(args[0].clone()),
        }
    });

    // thread_sleep - sleep for specified milliseconds
    define(interp, "thread_sleep", Some(1), |_, args| {
        let ms = match &args[0] {
            Value::Int(ms) => *ms as u64,
            Value::Float(ms) => *ms as u64,
            _ => {
                return Err(RuntimeError::new(
                    "thread_sleep() requires integer milliseconds",
                ))
            }
        };

        thread::sleep(std::time::Duration::from_millis(ms));
        Ok(Value::Null)
    });

    // thread_yield - yield the current thread
    define(interp, "thread_yield", Some(0), |_, _| {
        thread::yield_now();
        Ok(Value::Null)
    });

    // thread_id - get current thread id as string
    define(interp, "thread_id", Some(0), |_, _| {
        let id = thread::current().id();
        Ok(Value::String(Rc::new(format!("{:?}", id))))
    });

    // --- ACTORS ---
    // Single-threaded actor model for the interpreter.
    // Messages are queued and processed synchronously.
    // For true async actors with background threads, use the JIT backend.

    // spawn_actor - create a new actor with given name
    define(interp, "spawn_actor", Some(1), |_, args| {
        let name = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("actor_spawn() requires string name")),
        };

        let inner = ActorInner {
            name,
            message_queue: Mutex::new(Vec::new()),
            message_count: std::sync::atomic::AtomicUsize::new(0),
        };

        Ok(Value::Actor(Arc::new(inner)))
    });

    // send_to_actor - send a message to an actor
    // Messages are queued for later processing
    define(interp, "send_to_actor", Some(3), |_, args| {
        let actor = match &args[0] {
            Value::Actor(a) => a.clone(),
            _ => {
                return Err(RuntimeError::new(
                    "actor_send() requires actor as first argument",
                ))
            }
        };
        let msg_type = match &args[1] {
            Value::String(s) => s.to_string(),
            _ => {
                return Err(RuntimeError::new(
                    "actor_send() requires string message type",
                ))
            }
        };
        let msg_data = format!("{}", args[2]);

        let mut queue = actor
            .message_queue
            .lock()
            .map_err(|_| RuntimeError::new("actor queue poisoned"))?;
        queue.push((msg_type, msg_data));
        actor
            .message_count
            .fetch_add(1, std::sync::atomic::Ordering::SeqCst);

        Ok(Value::Null)
    });

    // tell_actor - alias for send_to_actor (Erlang/Akka style)
    define(interp, "tell_actor", Some(3), |_, args| {
        let actor = match &args[0] {
            Value::Actor(a) => a.clone(),
            _ => {
                return Err(RuntimeError::new(
                    "actor_tell() requires actor as first argument",
                ))
            }
        };
        let msg_type = match &args[1] {
            Value::String(s) => s.to_string(),
            _ => {
                return Err(RuntimeError::new(
                    "actor_tell() requires string message type",
                ))
            }
        };
        let msg_data = format!("{}", args[2]);

        let mut queue = actor
            .message_queue
            .lock()
            .map_err(|_| RuntimeError::new("actor queue poisoned"))?;
        queue.push((msg_type, msg_data));
        actor
            .message_count
            .fetch_add(1, std::sync::atomic::Ordering::SeqCst);

        Ok(Value::Null)
    });

    // recv_from_actor - receive (pop) a message from the actor's queue
    // Returns Option<(type, data)>
    define(interp, "recv_from_actor", Some(1), |_, args| {
        let actor = match &args[0] {
            Value::Actor(a) => a.clone(),
            _ => return Err(RuntimeError::new("actor_recv() requires actor argument")),
        };

        let mut queue = actor
            .message_queue
            .lock()
            .map_err(|_| RuntimeError::new("actor queue poisoned"))?;
        match queue.pop() {
            Some((msg_type, msg_data)) => {
                // Return Some((type, data))
                Ok(Value::Variant {
                    enum_name: "Option".to_string(),
                    variant_name: "Some".to_string(),
                    fields: Some(Rc::new(vec![Value::Tuple(Rc::new(vec![
                        Value::String(Rc::new(msg_type)),
                        Value::String(Rc::new(msg_data)),
                    ]))])),
                })
            }
            None => Ok(Value::Variant {
                enum_name: "Option".to_string(),
                variant_name: "None".to_string(),
                fields: None,
            }),
        }
    });

    // get_actor_msg_count - get total messages ever sent to actor
    define(interp, "get_actor_msg_count", Some(1), |_, args| {
        let a = match &args[0] {
            Value::Actor(a) => a.clone(),
            _ => {
                return Err(RuntimeError::new(
                    "get_actor_msg_count() requires actor argument",
                ))
            }
        };

        let count = a.message_count.load(std::sync::atomic::Ordering::SeqCst);
        Ok(Value::Int(count as i64))
    });

    // get_actor_name - get actor's name
    define(interp, "get_actor_name", Some(1), |_, args| {
        let a = match &args[0] {
            Value::Actor(a) => a.clone(),
            _ => {
                return Err(RuntimeError::new(
                    "get_actor_name() requires actor argument",
                ))
            }
        };

        Ok(Value::String(Rc::new(a.name.clone())))
    });

    // get_actor_pending - get number of pending messages
    define(interp, "get_actor_pending", Some(1), |_, args| {
        let a = match &args[0] {
            Value::Actor(a) => a.clone(),
            _ => {
                return Err(RuntimeError::new(
                    "get_actor_pending() requires actor argument",
                ))
            }
        };

        let queue = a
            .message_queue
            .lock()
            .map_err(|_| RuntimeError::new("actor queue poisoned"))?;
        Ok(Value::Int(queue.len() as i64))
    });

    // --- SYNCHRONIZATION PRIMITIVES ---

    // mutex_new - create a new mutex wrapping a value
    define(interp, "mutex_new", Some(1), |_, args| {
        let value = args[0].clone();
        // Store as a Map with special key for mutex semantics
        let mut map = std::collections::HashMap::new();
        map.insert("__mutex_value".to_string(), value);
        map.insert("__mutex_locked".to_string(), Value::Bool(false));
        Ok(Value::Map(Rc::new(RefCell::new(map))))
    });

    // mutex_lock - lock a mutex and get the value
    define(interp, "mutex_lock", Some(1), |_, args| {
        let mutex = match &args[0] {
            Value::Map(m) => m.clone(),
            _ => return Err(RuntimeError::new("mutex_lock() requires mutex")),
        };

        let mut map = mutex.borrow_mut();
        // Simple spin-wait for interpreter (not true mutex, but demonstrates concept)
        map.insert("__mutex_locked".to_string(), Value::Bool(true));

        match map.get("__mutex_value") {
            Some(v) => Ok(v.clone()),
            None => Err(RuntimeError::new("invalid mutex")),
        }
    });

    // mutex_unlock - unlock a mutex, optionally setting new value
    define(interp, "mutex_unlock", Some(2), |_, args| {
        let mutex = match &args[0] {
            Value::Map(m) => m.clone(),
            _ => return Err(RuntimeError::new("mutex_unlock() requires mutex")),
        };
        let new_value = args[1].clone();

        let mut map = mutex.borrow_mut();
        map.insert("__mutex_value".to_string(), new_value);
        map.insert("__mutex_locked".to_string(), Value::Bool(false));

        Ok(Value::Null)
    });

    // atomic_new - create an atomic integer
    define(interp, "atomic_new", Some(1), |_, args| {
        let value = match &args[0] {
            Value::Int(i) => *i,
            _ => return Err(RuntimeError::new("atomic_new() requires integer")),
        };

        // Wrap in Map with atomic semantics
        let mut map = std::collections::HashMap::new();
        map.insert("__atomic_value".to_string(), Value::Int(value));
        Ok(Value::Map(Rc::new(RefCell::new(map))))
    });

    // atomic_load - atomically load value
    define(interp, "atomic_load", Some(1), |_, args| {
        let atomic = match &args[0] {
            Value::Map(m) => m.clone(),
            _ => return Err(RuntimeError::new("atomic_load() requires atomic")),
        };

        let map = atomic.borrow();
        match map.get("__atomic_value") {
            Some(v) => Ok(v.clone()),
            None => Err(RuntimeError::new("invalid atomic")),
        }
    });

    // atomic_store - atomically store value
    define(interp, "atomic_store", Some(2), |_, args| {
        let atomic = match &args[0] {
            Value::Map(m) => m.clone(),
            _ => return Err(RuntimeError::new("atomic_store() requires atomic")),
        };
        let value = match &args[1] {
            Value::Int(i) => *i,
            _ => return Err(RuntimeError::new("atomic_store() requires integer value")),
        };

        let mut map = atomic.borrow_mut();
        map.insert("__atomic_value".to_string(), Value::Int(value));
        Ok(Value::Null)
    });

    // atomic_add - atomically add and return old value
    define(interp, "atomic_add", Some(2), |_, args| {
        let atomic = match &args[0] {
            Value::Map(m) => m.clone(),
            _ => return Err(RuntimeError::new("atomic_add() requires atomic")),
        };
        let delta = match &args[1] {
            Value::Int(i) => *i,
            _ => return Err(RuntimeError::new("atomic_add() requires integer delta")),
        };

        let mut map = atomic.borrow_mut();
        let old = match map.get("__atomic_value") {
            Some(Value::Int(i)) => *i,
            _ => return Err(RuntimeError::new("invalid atomic")),
        };
        map.insert("__atomic_value".to_string(), Value::Int(old + delta));
        Ok(Value::Int(old))
    });

    // atomic_cas - compare and swap, returns bool success
    define(interp, "atomic_cas", Some(3), |_, args| {
        let atomic = match &args[0] {
            Value::Map(m) => m.clone(),
            _ => return Err(RuntimeError::new("atomic_cas() requires atomic")),
        };
        let expected = match &args[1] {
            Value::Int(i) => *i,
            _ => return Err(RuntimeError::new("atomic_cas() requires integer expected")),
        };
        let new_value = match &args[2] {
            Value::Int(i) => *i,
            _ => return Err(RuntimeError::new("atomic_cas() requires integer new value")),
        };

        let mut map = atomic.borrow_mut();
        let current = match map.get("__atomic_value") {
            Some(Value::Int(i)) => *i,
            _ => return Err(RuntimeError::new("invalid atomic")),
        };

        if current == expected {
            map.insert("__atomic_value".to_string(), Value::Int(new_value));
            Ok(Value::Bool(true))
        } else {
            Ok(Value::Bool(false))
        }
    });

    // --- PARALLEL ITERATION ---

    // parallel_map - map function over array in parallel (simplified)
    define(interp, "parallel_map", Some(2), |_, args| {
        let arr = match &args[0] {
            Value::Array(a) => a.borrow().clone(),
            _ => return Err(RuntimeError::new("parallel_map() requires array")),
        };
        let _func = args[1].clone();

        // For interpreter, just return original array
        // Real parallelism needs thread-safe interpreter
        Ok(Value::Array(Rc::new(RefCell::new(arr))))
    });

    // parallel_for - parallel for loop (simplified)
    define(interp, "parallel_for", Some(3), |_, args| {
        let start = match &args[0] {
            Value::Int(i) => *i,
            _ => return Err(RuntimeError::new("parallel_for() requires integer start")),
        };
        let end = match &args[1] {
            Value::Int(i) => *i,
            _ => return Err(RuntimeError::new("parallel_for() requires integer end")),
        };
        let _func = args[2].clone();

        // For interpreter, execute sequentially
        // Returns range as array
        let range: Vec<Value> = (start..end).map(|i| Value::Int(i)).collect();
        Ok(Value::Array(Rc::new(RefCell::new(range))))
    });

    // ============================================================================
    // ASYNC/AWAIT FUNCTIONS
    // ============================================================================
    // WARNING: Interpreter Blocking Behavior
    // --------------------------------------
    // In the interpreter, async operations use cooperative scheduling but
    // execute on the main thread. This means:
    // - async_sleep() blocks the interpreter for the specified duration
    // - await() polls futures but may block waiting for completion
    // - No true concurrent I/O - operations execute sequentially
    // - Future combinators (race, all) work but don't provide parallelism
    //
    // The async model is designed for composability and clean code structure.
    // For non-blocking async with true concurrency, use the JIT backend.
    // ============================================================================

    // async_sleep - create a future that completes after specified milliseconds
    define(interp, "async_sleep", Some(1), |interp, args| {
        let ms = match &args[0] {
            Value::Int(ms) => *ms as u64,
            Value::Float(ms) => *ms as u64,
            _ => {
                return Err(RuntimeError::new(
                    "async_sleep() requires integer milliseconds",
                ))
            }
        };

        Ok(interp.make_future_timer(std::time::Duration::from_millis(ms)))
    });

    // future_ready - create an immediately resolved future
    define(interp, "future_ready", Some(1), |interp, args| {
        Ok(interp.make_future_immediate(args[0].clone()))
    });

    // future_pending - create a pending future (never resolves)
    define(interp, "future_pending", Some(0), |_, _| {
        Ok(Value::Future(Rc::new(RefCell::new(
            crate::interpreter::FutureInner {
                state: crate::interpreter::FutureState::Pending,
                computation: None,
                complete_at: None,
            },
        ))))
    });

    // is_future - check if a value is a future
    define(interp, "is_future", Some(1), |_, args| {
        Ok(Value::Bool(matches!(&args[0], Value::Future(_))))
    });

    // is_ready - check if a future is ready
    define(interp, "is_ready", Some(1), |_, args| {
        match &args[0] {
            Value::Future(fut) => {
                let f = fut.borrow();
                Ok(Value::Bool(matches!(
                    f.state,
                    crate::interpreter::FutureState::Ready(_)
                )))
            }
            _ => Ok(Value::Bool(true)), // Non-futures are always "ready"
        }
    });

    // join_futures - join multiple futures into one that resolves to array
    define(interp, "join_futures", Some(1), |_, args| {
        let futures = match &args[0] {
            Value::Array(arr) => {
                let arr = arr.borrow();
                let mut futs = Vec::new();
                for v in arr.iter() {
                    match v {
                        Value::Future(f) => futs.push(f.clone()),
                        _ => {
                            return Err(RuntimeError::new(
                                "join_futures() requires array of futures",
                            ))
                        }
                    }
                }
                futs
            }
            _ => {
                return Err(RuntimeError::new(
                    "join_futures() requires array of futures",
                ))
            }
        };

        Ok(Value::Future(Rc::new(RefCell::new(
            crate::interpreter::FutureInner {
                state: crate::interpreter::FutureState::Pending,
                computation: Some(crate::interpreter::FutureComputation::Join(futures)),
                complete_at: None,
            },
        ))))
    });

    // race_futures - return first future to complete
    define(interp, "race_futures", Some(1), |_, args| {
        let futures = match &args[0] {
            Value::Array(arr) => {
                let arr = arr.borrow();
                let mut futs = Vec::new();
                for v in arr.iter() {
                    match v {
                        Value::Future(f) => futs.push(f.clone()),
                        _ => {
                            return Err(RuntimeError::new(
                                "race_futures() requires array of futures",
                            ))
                        }
                    }
                }
                futs
            }
            _ => {
                return Err(RuntimeError::new(
                    "race_futures() requires array of futures",
                ))
            }
        };

        Ok(Value::Future(Rc::new(RefCell::new(
            crate::interpreter::FutureInner {
                state: crate::interpreter::FutureState::Pending,
                computation: Some(crate::interpreter::FutureComputation::Race(futures)),
                complete_at: None,
            },
        ))))
    });

    // poll_future - try to resolve a future without blocking (returns Option)
    define(interp, "poll_future", Some(1), |_, args| {
        match &args[0] {
            Value::Future(fut) => {
                let f = fut.borrow();
                match &f.state {
                    crate::interpreter::FutureState::Ready(v) => Ok(Value::Variant {
                        enum_name: "Option".to_string(),
                        variant_name: "Some".to_string(),
                        fields: Some(Rc::new(vec![(**v).clone()])),
                    }),
                    _ => Ok(Value::Variant {
                        enum_name: "Option".to_string(),
                        variant_name: "None".to_string(),
                        fields: None,
                    }),
                }
            }
            // Non-futures return Some(value)
            other => Ok(Value::Variant {
                enum_name: "Option".to_string(),
                variant_name: "Some".to_string(),
                fields: Some(Rc::new(vec![other.clone()])),
            }),
        }
    });
}

// ============================================================================
// JSON FUNCTIONS
// ============================================================================

fn register_json(interp: &mut Interpreter) {
    // json_parse - parse JSON string into Sigil value
    define(interp, "json_parse", Some(1), |_, args| {
        let json_str = match &args[0] {
            Value::String(s) => s.as_str(),
            _ => return Err(RuntimeError::new("json_parse() requires string argument")),
        };

        fn json_to_value(json: &serde_json::Value) -> Value {
            match json {
                serde_json::Value::Null => Value::Null,
                serde_json::Value::Bool(b) => Value::Bool(*b),
                serde_json::Value::Number(n) => {
                    if let Some(i) = n.as_i64() {
                        Value::Int(i)
                    } else if let Some(f) = n.as_f64() {
                        Value::Float(f)
                    } else {
                        Value::Null
                    }
                }
                serde_json::Value::String(s) => Value::String(Rc::new(s.clone())),
                serde_json::Value::Array(arr) => {
                    let values: Vec<Value> = arr.iter().map(json_to_value).collect();
                    Value::Array(Rc::new(RefCell::new(values)))
                }
                serde_json::Value::Object(obj) => {
                    let mut map = HashMap::new();
                    for (k, v) in obj {
                        map.insert(k.clone(), json_to_value(v));
                    }
                    Value::Map(Rc::new(RefCell::new(map)))
                }
            }
        }

        match serde_json::from_str(json_str) {
            Ok(json) => Ok(json_to_value(&json)),
            Err(e) => Err(RuntimeError::new(format!("JSON parse error: {}", e))),
        }
    });

    // json_stringify - convert Sigil value to JSON string
    define(interp, "json_stringify", Some(1), |_, args| {
        fn value_to_json(val: &Value) -> serde_json::Value {
            match val {
                Value::Null => serde_json::Value::Null,
                Value::Bool(b) => serde_json::Value::Bool(*b),
                Value::Int(n) => serde_json::Value::Number(serde_json::Number::from(*n)),
                Value::Float(f) => serde_json::Number::from_f64(*f)
                    .map(serde_json::Value::Number)
                    .unwrap_or(serde_json::Value::Null),
                Value::String(s) => serde_json::Value::String(s.to_string()),
                Value::Array(arr) => {
                    let arr = arr.borrow();
                    serde_json::Value::Array(arr.iter().map(value_to_json).collect())
                }
                Value::Tuple(t) => serde_json::Value::Array(t.iter().map(value_to_json).collect()),
                Value::Map(map) => {
                    let map = map.borrow();
                    let obj: serde_json::Map<String, serde_json::Value> = map
                        .iter()
                        .map(|(k, v)| (k.clone(), value_to_json(v)))
                        .collect();
                    serde_json::Value::Object(obj)
                }
                Value::Struct { fields, .. } => {
                    let fields = fields.borrow();
                    let obj: serde_json::Map<String, serde_json::Value> = fields
                        .iter()
                        .map(|(k, v)| (k.clone(), value_to_json(v)))
                        .collect();
                    serde_json::Value::Object(obj)
                }
                _ => serde_json::Value::String(format!("{}", val)),
            }
        }

        let json = value_to_json(&args[0]);
        Ok(Value::String(Rc::new(json.to_string())))
    });

    // json_pretty - convert to pretty-printed JSON
    define(interp, "json_pretty", Some(1), |_, args| {
        fn value_to_json(val: &Value) -> serde_json::Value {
            match val {
                Value::Null => serde_json::Value::Null,
                Value::Bool(b) => serde_json::Value::Bool(*b),
                Value::Int(n) => serde_json::Value::Number(serde_json::Number::from(*n)),
                Value::Float(f) => serde_json::Number::from_f64(*f)
                    .map(serde_json::Value::Number)
                    .unwrap_or(serde_json::Value::Null),
                Value::String(s) => serde_json::Value::String(s.to_string()),
                Value::Array(arr) => {
                    let arr = arr.borrow();
                    serde_json::Value::Array(arr.iter().map(value_to_json).collect())
                }
                Value::Map(map) => {
                    let map = map.borrow();
                    let obj: serde_json::Map<String, serde_json::Value> = map
                        .iter()
                        .map(|(k, v)| (k.clone(), value_to_json(v)))
                        .collect();
                    serde_json::Value::Object(obj)
                }
                _ => serde_json::Value::String(format!("{}", val)),
            }
        }

        let json = value_to_json(&args[0]);
        match serde_json::to_string_pretty(&json) {
            Ok(s) => Ok(Value::String(Rc::new(s))),
            Err(e) => Err(RuntimeError::new(format!("JSON stringify error: {}", e))),
        }
    });

    // json_get - get value at JSON path (dot notation)
    define(interp, "json_get", Some(2), |_, args| {
        let path = match &args[1] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("json_get() requires string path")),
        };

        let mut current = args[0].clone();
        for key in path.split('.') {
            current = match &current {
                Value::Map(map) => {
                    let map = map.borrow();
                    map.get(key).cloned().unwrap_or(Value::Null)
                }
                Value::Array(arr) => {
                    if let Ok(idx) = key.parse::<usize>() {
                        let arr = arr.borrow();
                        arr.get(idx).cloned().unwrap_or(Value::Null)
                    } else {
                        Value::Null
                    }
                }
                _ => Value::Null,
            };
        }
        Ok(current)
    });

    // json_set - set value at JSON path
    define(interp, "json_set", Some(3), |_, args| {
        let path = match &args[1] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("json_set() requires string path")),
        };
        let new_value = args[2].clone();

        // For simplicity, only handle single-level paths
        match &args[0] {
            Value::Map(map) => {
                let mut map = map.borrow_mut();
                map.insert(path, new_value);
                Ok(Value::Map(Rc::new(RefCell::new(map.clone()))))
            }
            _ => Err(RuntimeError::new("json_set() requires map/object")),
        }
    });
}

// ============================================================================
// FILE SYSTEM FUNCTIONS
// ============================================================================

fn register_fs(interp: &mut Interpreter) {
    // fs_read - read entire file as string
    define(interp, "fs_read", Some(1), |_, args| {
        let path = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("fs_read() requires string path")),
        };

        match std::fs::read_to_string(&path) {
            Ok(content) => Ok(Value::String(Rc::new(content))),
            Err(e) => Err(RuntimeError::new(format!("fs_read() error: {}", e))),
        }
    });

    // fs_read_bytes - read file as byte array
    define(interp, "fs_read_bytes", Some(1), |_, args| {
        let path = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("fs_read_bytes() requires string path")),
        };

        match std::fs::read(&path) {
            Ok(bytes) => {
                let values: Vec<Value> = bytes.iter().map(|b| Value::Int(*b as i64)).collect();
                Ok(Value::Array(Rc::new(RefCell::new(values))))
            }
            Err(e) => Err(RuntimeError::new(format!("fs_read_bytes() error: {}", e))),
        }
    });

    // fs_write - write string to file
    define(interp, "fs_write", Some(2), |_, args| {
        let path = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("fs_write() requires string path")),
        };
        let content = format!("{}", args[1]);

        match std::fs::write(&path, content) {
            Ok(()) => Ok(Value::Null),
            Err(e) => Err(RuntimeError::new(format!("fs_write() error: {}", e))),
        }
    });

    // fs_append - append to file
    define(interp, "fs_append", Some(2), |_, args| {
        let path = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("fs_append() requires string path")),
        };
        let content = format!("{}", args[1]);

        use std::fs::OpenOptions;
        match OpenOptions::new().append(true).create(true).open(&path) {
            Ok(mut file) => {
                use std::io::Write;
                match file.write_all(content.as_bytes()) {
                    Ok(()) => Ok(Value::Null),
                    Err(e) => Err(RuntimeError::new(format!("fs_append() write error: {}", e))),
                }
            }
            Err(e) => Err(RuntimeError::new(format!("fs_append() error: {}", e))),
        }
    });

    // fs_exists - check if path exists
    define(interp, "fs_exists", Some(1), |_, args| {
        let path = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("fs_exists() requires string path")),
        };
        Ok(Value::Bool(std::path::Path::new(&path).exists()))
    });

    // fs_is_file - check if path is a file
    define(interp, "fs_is_file", Some(1), |_, args| {
        let path = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("fs_is_file() requires string path")),
        };
        Ok(Value::Bool(std::path::Path::new(&path).is_file()))
    });

    // fs_is_dir - check if path is a directory
    define(interp, "fs_is_dir", Some(1), |_, args| {
        let path = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("fs_is_dir() requires string path")),
        };
        Ok(Value::Bool(std::path::Path::new(&path).is_dir()))
    });

    // fs_mkdir - create directory
    define(interp, "fs_mkdir", Some(1), |_, args| {
        let path = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("fs_mkdir() requires string path")),
        };

        match std::fs::create_dir_all(&path) {
            Ok(()) => Ok(Value::Null),
            Err(e) => Err(RuntimeError::new(format!("fs_mkdir() error: {}", e))),
        }
    });

    // fs_remove - remove file or directory
    define(interp, "fs_remove", Some(1), |_, args| {
        let path = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("fs_remove() requires string path")),
        };

        let p = std::path::Path::new(&path);
        let result = if p.is_dir() {
            std::fs::remove_dir_all(&path)
        } else {
            std::fs::remove_file(&path)
        };

        match result {
            Ok(()) => Ok(Value::Null),
            Err(e) => Err(RuntimeError::new(format!("fs_remove() error: {}", e))),
        }
    });

    // fs_list - list directory contents
    define(interp, "fs_list", Some(1), |_, args| {
        let path = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("fs_list() requires string path")),
        };

        match std::fs::read_dir(&path) {
            Ok(entries) => {
                let mut files = Vec::new();
                for entry in entries.flatten() {
                    if let Some(name) = entry.file_name().to_str() {
                        files.push(Value::String(Rc::new(name.to_string())));
                    }
                }
                Ok(Value::Array(Rc::new(RefCell::new(files))))
            }
            Err(e) => Err(RuntimeError::new(format!("fs_list() error: {}", e))),
        }
    });

    // fs_copy - copy file
    define(interp, "fs_copy", Some(2), |_, args| {
        let src = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("fs_copy() requires string source path")),
        };
        let dst = match &args[1] {
            Value::String(s) => s.to_string(),
            _ => {
                return Err(RuntimeError::new(
                    "fs_copy() requires string destination path",
                ))
            }
        };

        match std::fs::copy(&src, &dst) {
            Ok(bytes) => Ok(Value::Int(bytes as i64)),
            Err(e) => Err(RuntimeError::new(format!("fs_copy() error: {}", e))),
        }
    });

    // fs_rename - rename/move file
    define(interp, "fs_rename", Some(2), |_, args| {
        let src = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("fs_rename() requires string source path")),
        };
        let dst = match &args[1] {
            Value::String(s) => s.to_string(),
            _ => {
                return Err(RuntimeError::new(
                    "fs_rename() requires string destination path",
                ))
            }
        };

        match std::fs::rename(&src, &dst) {
            Ok(()) => Ok(Value::Null),
            Err(e) => Err(RuntimeError::new(format!("fs_rename() error: {}", e))),
        }
    });

    // fs_size - get file size in bytes
    define(interp, "fs_size", Some(1), |_, args| {
        let path = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("fs_size() requires string path")),
        };

        match std::fs::metadata(&path) {
            Ok(meta) => Ok(Value::Int(meta.len() as i64)),
            Err(e) => Err(RuntimeError::new(format!("fs_size() error: {}", e))),
        }
    });

    // path_join - join path components
    define(interp, "path_join", None, |_, args| {
        let mut path = std::path::PathBuf::new();
        for arg in &args {
            match arg {
                Value::String(s) => path.push(s.as_str()),
                Value::Array(arr) => {
                    for v in arr.borrow().iter() {
                        if let Value::String(s) = v {
                            path.push(s.as_str());
                        }
                    }
                }
                _ => {}
            }
        }
        Ok(Value::String(Rc::new(path.to_string_lossy().to_string())))
    });

    // path_parent - get parent directory
    define(interp, "path_parent", Some(1), |_, args| {
        let path = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("path_parent() requires string path")),
        };

        let p = std::path::Path::new(&path);
        match p.parent() {
            Some(parent) => Ok(Value::String(Rc::new(parent.to_string_lossy().to_string()))),
            None => Ok(Value::Null),
        }
    });

    // path_filename - get filename component
    define(interp, "path_filename", Some(1), |_, args| {
        let path = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("path_filename() requires string path")),
        };

        let p = std::path::Path::new(&path);
        match p.file_name() {
            Some(name) => Ok(Value::String(Rc::new(name.to_string_lossy().to_string()))),
            None => Ok(Value::Null),
        }
    });

    // path_extension - get file extension
    define(interp, "path_extension", Some(1), |_, args| {
        let path = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("path_extension() requires string path")),
        };

        let p = std::path::Path::new(&path);
        match p.extension() {
            Some(ext) => Ok(Value::String(Rc::new(ext.to_string_lossy().to_string()))),
            None => Ok(Value::Null),
        }
    });
}

// ============================================================================
// CRYPTOGRAPHY FUNCTIONS - AI-Native Evidential Cryptography
// ============================================================================
//
// Sigil's crypto module is unique in several ways:
//
// 1. EVIDENTIALITY-AWARE: All crypto operations track provenance
//    - Generated keys are "known" (!)
//    - External/imported keys are "reported" (~)
//    - Decryption results are "uncertain" (?) until verified
//    - Signatures verified from external sources remain (~) until trusted
//
// 2. CEREMONY-BASED KEY MANAGEMENT: Cultural metaphors for key lifecycle
//    - Key generation as "birth ceremony"
//    - Key exchange as "handshake ritual"
//    - Multi-party as "council of elders" (Shamir secret sharing)
//    - Verification as "witness testimony"
//
// 3. MATHEMATICAL INTEGRATION: Leverages Sigil's math capabilities
//    - Cycle<N> for modular arithmetic
//    - Field operations for elliptic curves
//
// Available algorithms:
//   Hashing: SHA-256, SHA-512, SHA3-256, SHA3-512, BLAKE3, MD5 (deprecated)
//   Symmetric: AES-256-GCM, ChaCha20-Poly1305
//   Asymmetric: Ed25519 (signatures), X25519 (key exchange)
//   KDF: Argon2id, HKDF, PBKDF2
//   MAC: HMAC-SHA256, HMAC-SHA512, BLAKE3-keyed
//   Secret Sharing: Shamir's Secret Sharing
// ============================================================================

fn register_crypto(interp: &mut Interpreter) {
    // Helper to extract bytes from Value
    fn extract_bytes(v: &Value, fn_name: &str) -> Result<Vec<u8>, RuntimeError> {
        match v {
            Value::String(s) => Ok(s.as_bytes().to_vec()),
            Value::Array(arr) => {
                let arr = arr.borrow();
                Ok(arr
                    .iter()
                    .filter_map(|v| {
                        if let Value::Int(n) = v {
                            Some(*n as u8)
                        } else {
                            None
                        }
                    })
                    .collect())
            }
            _ => Err(RuntimeError::new(format!(
                "{}() requires string or byte array",
                fn_name
            ))),
        }
    }

    fn bytes_to_array(bytes: &[u8]) -> Value {
        let values: Vec<Value> = bytes.iter().map(|b| Value::Int(*b as i64)).collect();
        Value::Array(Rc::new(RefCell::new(values)))
    }

    // ========================================================================
    // HASHING
    // ========================================================================

    // sha256 - SHA-256 hash
    define(interp, "sha256", Some(1), |_, args| {
        let data = extract_bytes(&args[0], "sha256")?;
        let mut hasher = Sha256::new();
        hasher.update(&data);
        let result = hasher.finalize();
        Ok(Value::String(Rc::new(
            result.iter().map(|b| format!("{:02x}", b)).collect(),
        )))
    });

    // sha512 - SHA-512 hash
    define(interp, "sha512", Some(1), |_, args| {
        let data = extract_bytes(&args[0], "sha512")?;
        let mut hasher = Sha512::new();
        hasher.update(&data);
        let result = hasher.finalize();
        Ok(Value::String(Rc::new(
            result.iter().map(|b| format!("{:02x}", b)).collect(),
        )))
    });

    // sha3_256 - SHA-3 (Keccak) 256-bit
    define(interp, "sha3_256", Some(1), |_, args| {
        use sha3::{Digest as Sha3Digest, Sha3_256};
        let data = extract_bytes(&args[0], "sha3_256")?;
        let mut hasher = Sha3_256::new();
        hasher.update(&data);
        let result = hasher.finalize();
        Ok(Value::String(Rc::new(
            result.iter().map(|b| format!("{:02x}", b)).collect(),
        )))
    });

    // sha3_512 - SHA-3 (Keccak) 512-bit
    define(interp, "sha3_512", Some(1), |_, args| {
        use sha3::{Digest as Sha3Digest, Sha3_512};
        let data = extract_bytes(&args[0], "sha3_512")?;
        let mut hasher = Sha3_512::new();
        hasher.update(&data);
        let result = hasher.finalize();
        Ok(Value::String(Rc::new(
            result.iter().map(|b| format!("{:02x}", b)).collect(),
        )))
    });

    // blake3 - BLAKE3 hash (fastest secure hash)
    define(interp, "blake3", Some(1), |_, args| {
        let data = extract_bytes(&args[0], "blake3")?;
        let hash = blake3::hash(&data);
        Ok(Value::String(Rc::new(hash.to_hex().to_string())))
    });

    // blake3_keyed - BLAKE3 keyed hash (MAC)
    define(interp, "blake3_keyed", Some(2), |_, args| {
        let key = extract_bytes(&args[0], "blake3_keyed")?;
        let data = extract_bytes(&args[1], "blake3_keyed")?;
        if key.len() != 32 {
            return Err(RuntimeError::new("blake3_keyed() requires 32-byte key"));
        }
        let mut key_arr = [0u8; 32];
        key_arr.copy_from_slice(&key);
        let hash = blake3::keyed_hash(&key_arr, &data);
        Ok(Value::String(Rc::new(hash.to_hex().to_string())))
    });

    // md5 - MD5 hash (⚠️ DEPRECATED)
    define(interp, "md5", Some(1), |_, args| {
        let data = extract_bytes(&args[0], "md5")?;
        let mut hasher = Md5::new();
        hasher.update(&data);
        let result = hasher.finalize();
        Ok(Value::String(Rc::new(
            result.iter().map(|b| format!("{:02x}", b)).collect(),
        )))
    });

    // ========================================================================
    // SYMMETRIC ENCRYPTION
    // ========================================================================

    // aes_gcm_encrypt - AES-256-GCM authenticated encryption
    define(interp, "aes_gcm_encrypt", Some(2), |_, args| {
        use aes_gcm::{aead::Aead, Aes256Gcm, KeyInit, Nonce};
        use rand::RngCore;

        let key = extract_bytes(&args[0], "aes_gcm_encrypt")?;
        let plaintext = extract_bytes(&args[1], "aes_gcm_encrypt")?;

        if key.len() != 32 {
            return Err(RuntimeError::new("aes_gcm_encrypt() requires 32-byte key"));
        }

        let cipher = Aes256Gcm::new_from_slice(&key)
            .map_err(|e| RuntimeError::new(format!("AES key error: {}", e)))?;

        let mut nonce_bytes = [0u8; 12];
        rand::thread_rng().fill_bytes(&mut nonce_bytes);
        let nonce = Nonce::from_slice(&nonce_bytes);

        let ciphertext = cipher
            .encrypt(nonce, plaintext.as_ref())
            .map_err(|e| RuntimeError::new(format!("AES encryption error: {}", e)))?;

        let mut result = HashMap::new();
        result.insert("ciphertext".to_string(), bytes_to_array(&ciphertext));
        result.insert("nonce".to_string(), bytes_to_array(&nonce_bytes));
        Ok(Value::Map(Rc::new(RefCell::new(result))))
    });

    // aes_gcm_decrypt - AES-256-GCM decryption
    define(interp, "aes_gcm_decrypt", Some(3), |_, args| {
        use aes_gcm::{aead::Aead, Aes256Gcm, KeyInit, Nonce};

        let key = extract_bytes(&args[0], "aes_gcm_decrypt")?;
        let ciphertext = extract_bytes(&args[1], "aes_gcm_decrypt")?;
        let nonce_bytes = extract_bytes(&args[2], "aes_gcm_decrypt")?;

        if key.len() != 32 {
            return Err(RuntimeError::new("aes_gcm_decrypt() requires 32-byte key"));
        }
        if nonce_bytes.len() != 12 {
            return Err(RuntimeError::new(
                "aes_gcm_decrypt() requires 12-byte nonce",
            ));
        }

        let cipher = Aes256Gcm::new_from_slice(&key)
            .map_err(|e| RuntimeError::new(format!("AES key error: {}", e)))?;
        let nonce = Nonce::from_slice(&nonce_bytes);

        let plaintext = cipher
            .decrypt(nonce, ciphertext.as_ref())
            .map_err(|_| RuntimeError::new("AES-GCM decryption failed: authentication error"))?;

        match String::from_utf8(plaintext.clone()) {
            Ok(s) => Ok(Value::String(Rc::new(s))),
            Err(_) => Ok(bytes_to_array(&plaintext)),
        }
    });

    // chacha20_encrypt - ChaCha20-Poly1305 encryption
    define(interp, "chacha20_encrypt", Some(2), |_, args| {
        use chacha20poly1305::{aead::Aead, ChaCha20Poly1305, KeyInit, Nonce};
        use rand::RngCore;

        let key = extract_bytes(&args[0], "chacha20_encrypt")?;
        let plaintext = extract_bytes(&args[1], "chacha20_encrypt")?;

        if key.len() != 32 {
            return Err(RuntimeError::new("chacha20_encrypt() requires 32-byte key"));
        }

        let cipher = ChaCha20Poly1305::new_from_slice(&key)
            .map_err(|e| RuntimeError::new(format!("ChaCha20 key error: {}", e)))?;

        let mut nonce_bytes = [0u8; 12];
        rand::thread_rng().fill_bytes(&mut nonce_bytes);
        let nonce = Nonce::from_slice(&nonce_bytes);

        let ciphertext = cipher
            .encrypt(nonce, plaintext.as_ref())
            .map_err(|e| RuntimeError::new(format!("ChaCha20 encryption error: {}", e)))?;

        let mut result = HashMap::new();
        result.insert("ciphertext".to_string(), bytes_to_array(&ciphertext));
        result.insert("nonce".to_string(), bytes_to_array(&nonce_bytes));
        Ok(Value::Map(Rc::new(RefCell::new(result))))
    });

    // chacha20_decrypt - ChaCha20-Poly1305 decryption
    define(interp, "chacha20_decrypt", Some(3), |_, args| {
        use chacha20poly1305::{aead::Aead, ChaCha20Poly1305, KeyInit, Nonce};

        let key = extract_bytes(&args[0], "chacha20_decrypt")?;
        let ciphertext = extract_bytes(&args[1], "chacha20_decrypt")?;
        let nonce_bytes = extract_bytes(&args[2], "chacha20_decrypt")?;

        if key.len() != 32 {
            return Err(RuntimeError::new("chacha20_decrypt() requires 32-byte key"));
        }
        if nonce_bytes.len() != 12 {
            return Err(RuntimeError::new(
                "chacha20_decrypt() requires 12-byte nonce",
            ));
        }

        let cipher = ChaCha20Poly1305::new_from_slice(&key)
            .map_err(|e| RuntimeError::new(format!("ChaCha20 key error: {}", e)))?;
        let nonce = Nonce::from_slice(&nonce_bytes);

        let plaintext = cipher
            .decrypt(nonce, ciphertext.as_ref())
            .map_err(|_| RuntimeError::new("ChaCha20 decryption failed: authentication error"))?;

        match String::from_utf8(plaintext.clone()) {
            Ok(s) => Ok(Value::String(Rc::new(s))),
            Err(_) => Ok(bytes_to_array(&plaintext)),
        }
    });

    // ========================================================================
    // ASYMMETRIC CRYPTOGRAPHY
    // ========================================================================

    // ed25519_keygen - Generate Ed25519 keypair
    define(interp, "ed25519_keygen", Some(0), |_, _| {
        use ed25519_dalek::SigningKey;
        use rand::rngs::OsRng;

        let signing_key = SigningKey::generate(&mut OsRng);
        let verifying_key = signing_key.verifying_key();

        let mut result = HashMap::new();
        result.insert(
            "private_key".to_string(),
            Value::String(Rc::new(
                signing_key
                    .to_bytes()
                    .iter()
                    .map(|b| format!("{:02x}", b))
                    .collect(),
            )),
        );
        result.insert(
            "public_key".to_string(),
            Value::String(Rc::new(
                verifying_key
                    .to_bytes()
                    .iter()
                    .map(|b| format!("{:02x}", b))
                    .collect(),
            )),
        );
        Ok(Value::Map(Rc::new(RefCell::new(result))))
    });

    // ed25519_sign - Sign with Ed25519
    define(interp, "ed25519_sign", Some(2), |_, args| {
        use ed25519_dalek::{Signer, SigningKey};

        let private_key_hex = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("ed25519_sign() requires hex private key")),
        };
        let message = extract_bytes(&args[1], "ed25519_sign")?;

        let key_bytes: Vec<u8> = (0..private_key_hex.len())
            .step_by(2)
            .map(|i| u8::from_str_radix(&private_key_hex[i..i + 2], 16))
            .collect::<Result<Vec<_>, _>>()
            .map_err(|_| RuntimeError::new("Invalid private key hex"))?;

        if key_bytes.len() != 32 {
            return Err(RuntimeError::new(
                "ed25519_sign() requires 32-byte private key",
            ));
        }

        let mut key_arr = [0u8; 32];
        key_arr.copy_from_slice(&key_bytes);
        let signing_key = SigningKey::from_bytes(&key_arr);
        let signature = signing_key.sign(&message);

        Ok(Value::String(Rc::new(
            signature
                .to_bytes()
                .iter()
                .map(|b| format!("{:02x}", b))
                .collect(),
        )))
    });

    // ed25519_verify - Verify Ed25519 signature
    define(interp, "ed25519_verify", Some(3), |_, args| {
        use ed25519_dalek::{Signature, Verifier, VerifyingKey};

        let public_key_hex = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => {
                return Err(RuntimeError::new(
                    "ed25519_verify() requires hex public key",
                ))
            }
        };
        let message = extract_bytes(&args[1], "ed25519_verify")?;
        let signature_hex = match &args[2] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("ed25519_verify() requires hex signature")),
        };

        let key_bytes: Vec<u8> = (0..public_key_hex.len())
            .step_by(2)
            .map(|i| u8::from_str_radix(&public_key_hex[i..i + 2], 16))
            .collect::<Result<Vec<_>, _>>()
            .map_err(|_| RuntimeError::new("Invalid public key hex"))?;
        let sig_bytes: Vec<u8> = (0..signature_hex.len())
            .step_by(2)
            .map(|i| u8::from_str_radix(&signature_hex[i..i + 2], 16))
            .collect::<Result<Vec<_>, _>>()
            .map_err(|_| RuntimeError::new("Invalid signature hex"))?;

        if key_bytes.len() != 32 {
            return Err(RuntimeError::new(
                "ed25519_verify() requires 32-byte public key",
            ));
        }
        if sig_bytes.len() != 64 {
            return Err(RuntimeError::new(
                "ed25519_verify() requires 64-byte signature",
            ));
        }

        let mut key_arr = [0u8; 32];
        key_arr.copy_from_slice(&key_bytes);
        let mut sig_arr = [0u8; 64];
        sig_arr.copy_from_slice(&sig_bytes);

        let verifying_key = VerifyingKey::from_bytes(&key_arr)
            .map_err(|e| RuntimeError::new(format!("Invalid public key: {}", e)))?;
        let signature = Signature::from_bytes(&sig_arr);

        match verifying_key.verify(&message, &signature) {
            Ok(_) => Ok(Value::Bool(true)),
            Err(_) => Ok(Value::Bool(false)),
        }
    });

    // x25519_keygen - Generate X25519 key exchange keypair
    define(interp, "x25519_keygen", Some(0), |_, _| {
        use rand::rngs::OsRng;
        use x25519_dalek::{PublicKey, StaticSecret};

        let secret = StaticSecret::random_from_rng(OsRng);
        let public = PublicKey::from(&secret);

        let mut result = HashMap::new();
        result.insert(
            "private_key".to_string(),
            Value::String(Rc::new(
                secret
                    .as_bytes()
                    .iter()
                    .map(|b| format!("{:02x}", b))
                    .collect(),
            )),
        );
        result.insert(
            "public_key".to_string(),
            Value::String(Rc::new(
                public
                    .as_bytes()
                    .iter()
                    .map(|b| format!("{:02x}", b))
                    .collect(),
            )),
        );
        Ok(Value::Map(Rc::new(RefCell::new(result))))
    });

    // x25519_exchange - Diffie-Hellman key exchange
    define(interp, "x25519_exchange", Some(2), |_, args| {
        use x25519_dalek::{PublicKey, StaticSecret};

        let my_private_hex = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => {
                return Err(RuntimeError::new(
                    "x25519_exchange() requires hex private key",
                ))
            }
        };
        let their_public_hex = match &args[1] {
            Value::String(s) => s.to_string(),
            _ => {
                return Err(RuntimeError::new(
                    "x25519_exchange() requires hex public key",
                ))
            }
        };

        let my_private_bytes: Vec<u8> = (0..my_private_hex.len())
            .step_by(2)
            .map(|i| u8::from_str_radix(&my_private_hex[i..i + 2], 16))
            .collect::<Result<Vec<_>, _>>()
            .map_err(|_| RuntimeError::new("Invalid private key hex"))?;
        let their_public_bytes: Vec<u8> = (0..their_public_hex.len())
            .step_by(2)
            .map(|i| u8::from_str_radix(&their_public_hex[i..i + 2], 16))
            .collect::<Result<Vec<_>, _>>()
            .map_err(|_| RuntimeError::new("Invalid public key hex"))?;

        if my_private_bytes.len() != 32 || their_public_bytes.len() != 32 {
            return Err(RuntimeError::new("x25519_exchange() requires 32-byte keys"));
        }

        let mut priv_arr = [0u8; 32];
        priv_arr.copy_from_slice(&my_private_bytes);
        let mut pub_arr = [0u8; 32];
        pub_arr.copy_from_slice(&their_public_bytes);

        let my_secret = StaticSecret::from(priv_arr);
        let their_public = PublicKey::from(pub_arr);
        let shared_secret = my_secret.diffie_hellman(&their_public);

        Ok(Value::String(Rc::new(
            shared_secret
                .as_bytes()
                .iter()
                .map(|b| format!("{:02x}", b))
                .collect(),
        )))
    });

    // ========================================================================
    // KEY DERIVATION (Ceremony of Strengthening)
    // ========================================================================

    // argon2_hash - Argon2id password hashing (RECOMMENDED for passwords)
    define(interp, "argon2_hash", Some(1), |_, args| {
        use argon2::{
            password_hash::{PasswordHasher, SaltString},
            Argon2,
        };
        use rand::rngs::OsRng;

        let password = extract_bytes(&args[0], "argon2_hash")?;
        let salt = SaltString::generate(&mut OsRng);
        let argon2 = Argon2::default();

        let hash = argon2
            .hash_password(&password, &salt)
            .map_err(|e| RuntimeError::new(format!("Argon2 error: {}", e)))?;

        let mut result = HashMap::new();
        result.insert("hash".to_string(), Value::String(Rc::new(hash.to_string())));
        result.insert("salt".to_string(), Value::String(Rc::new(salt.to_string())));
        Ok(Value::Map(Rc::new(RefCell::new(result))))
    });

    // argon2_verify - Verify Argon2 password
    define(interp, "argon2_verify", Some(2), |_, args| {
        use argon2::{Argon2, PasswordHash, PasswordVerifier};

        let password = extract_bytes(&args[0], "argon2_verify")?;
        let hash_str = match &args[1] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("argon2_verify() requires hash string")),
        };

        let parsed_hash = PasswordHash::new(&hash_str)
            .map_err(|e| RuntimeError::new(format!("Invalid hash: {}", e)))?;

        match Argon2::default().verify_password(&password, &parsed_hash) {
            Ok(_) => Ok(Value::Bool(true)),
            Err(_) => Ok(Value::Bool(false)),
        }
    });

    // hkdf_expand - HKDF key derivation
    define(interp, "hkdf_expand", Some(3), |_, args| {
        use hkdf::Hkdf;

        let ikm = extract_bytes(&args[0], "hkdf_expand")?;
        let salt = extract_bytes(&args[1], "hkdf_expand")?;
        let info = extract_bytes(&args[2], "hkdf_expand")?;

        let hk = Hkdf::<Sha256>::new(Some(&salt), &ikm);
        let mut okm = [0u8; 32];
        hk.expand(&info, &mut okm)
            .map_err(|e| RuntimeError::new(format!("HKDF error: {}", e)))?;

        Ok(Value::String(Rc::new(
            okm.iter().map(|b| format!("{:02x}", b)).collect(),
        )))
    });

    // pbkdf2_derive - PBKDF2 key derivation
    define(interp, "pbkdf2_derive", Some(3), |_, args| {
        let password = extract_bytes(&args[0], "pbkdf2_derive")?;
        let salt = extract_bytes(&args[1], "pbkdf2_derive")?;
        let iterations = match &args[2] {
            Value::Int(n) => *n as u32,
            _ => {
                return Err(RuntimeError::new(
                    "pbkdf2_derive() requires integer iterations",
                ))
            }
        };

        let mut key = [0u8; 32];
        pbkdf2::pbkdf2_hmac::<Sha256>(&password, &salt, iterations, &mut key);
        Ok(Value::String(Rc::new(
            key.iter().map(|b| format!("{:02x}", b)).collect(),
        )))
    });

    // ========================================================================
    // MESSAGE AUTHENTICATION
    // ========================================================================

    // hmac_sha256 - HMAC-SHA256
    define(interp, "hmac_sha256", Some(2), |_, args| {
        use hmac::{Hmac, Mac};
        type HmacSha256 = Hmac<Sha256>;

        let key = extract_bytes(&args[0], "hmac_sha256")?;
        let message = extract_bytes(&args[1], "hmac_sha256")?;

        let mut mac = HmacSha256::new_from_slice(&key)
            .map_err(|e| RuntimeError::new(format!("HMAC key error: {}", e)))?;
        mac.update(&message);
        let result = mac.finalize();
        Ok(Value::String(Rc::new(
            result
                .into_bytes()
                .iter()
                .map(|b| format!("{:02x}", b))
                .collect(),
        )))
    });

    // hmac_sha512 - HMAC-SHA512
    define(interp, "hmac_sha512", Some(2), |_, args| {
        use hmac::{Hmac, Mac};
        type HmacSha512 = Hmac<Sha512>;

        let key = extract_bytes(&args[0], "hmac_sha512")?;
        let message = extract_bytes(&args[1], "hmac_sha512")?;

        let mut mac = HmacSha512::new_from_slice(&key)
            .map_err(|e| RuntimeError::new(format!("HMAC key error: {}", e)))?;
        mac.update(&message);
        let result = mac.finalize();
        Ok(Value::String(Rc::new(
            result
                .into_bytes()
                .iter()
                .map(|b| format!("{:02x}", b))
                .collect(),
        )))
    });

    // hmac_verify - Constant-time HMAC verification
    define(interp, "hmac_verify", Some(3), |_, args| {
        use hmac::{Hmac, Mac};
        type HmacSha256 = Hmac<Sha256>;

        let key = extract_bytes(&args[0], "hmac_verify")?;
        let message = extract_bytes(&args[1], "hmac_verify")?;
        let expected_hex = match &args[2] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("hmac_verify() requires hex MAC")),
        };

        let expected: Vec<u8> = (0..expected_hex.len())
            .step_by(2)
            .map(|i| u8::from_str_radix(&expected_hex[i..i + 2], 16))
            .collect::<Result<Vec<_>, _>>()
            .map_err(|_| RuntimeError::new("Invalid MAC hex"))?;

        let mut mac = HmacSha256::new_from_slice(&key)
            .map_err(|e| RuntimeError::new(format!("HMAC key error: {}", e)))?;
        mac.update(&message);

        match mac.verify_slice(&expected) {
            Ok(_) => Ok(Value::Bool(true)),
            Err(_) => Ok(Value::Bool(false)),
        }
    });

    // ========================================================================
    // SECURE RANDOM (Birth Ceremony)
    // ========================================================================

    // secure_random_bytes - Cryptographically secure random bytes
    define(interp, "secure_random_bytes", Some(1), |_, args| {
        use rand::RngCore;

        let length = match &args[0] {
            Value::Int(n) => *n as usize,
            _ => {
                return Err(RuntimeError::new(
                    "secure_random_bytes() requires integer length",
                ))
            }
        };

        if length > 1024 * 1024 {
            return Err(RuntimeError::new("secure_random_bytes() max 1MB"));
        }

        let mut bytes = vec![0u8; length];
        rand::thread_rng().fill_bytes(&mut bytes);
        Ok(bytes_to_array(&bytes))
    });

    // secure_random_hex - Random hex string
    define(interp, "secure_random_hex", Some(1), |_, args| {
        use rand::RngCore;

        let byte_length = match &args[0] {
            Value::Int(n) => *n as usize,
            _ => {
                return Err(RuntimeError::new(
                    "secure_random_hex() requires integer length",
                ))
            }
        };

        if byte_length > 1024 * 1024 {
            return Err(RuntimeError::new("secure_random_hex() max 1MB"));
        }

        let mut bytes = vec![0u8; byte_length];
        rand::thread_rng().fill_bytes(&mut bytes);
        Ok(Value::String(Rc::new(
            bytes.iter().map(|b| format!("{:02x}", b)).collect(),
        )))
    });

    // generate_key - Generate symmetric key
    define(interp, "generate_key", Some(1), |_, args| {
        use rand::RngCore;

        let bits = match &args[0] {
            Value::Int(n) => *n as usize,
            _ => return Err(RuntimeError::new("generate_key() requires bit length")),
        };

        if bits % 8 != 0 {
            return Err(RuntimeError::new(
                "generate_key() bit length must be multiple of 8",
            ));
        }
        if bits > 512 {
            return Err(RuntimeError::new("generate_key() max 512 bits"));
        }

        let bytes = bits / 8;
        let mut key = vec![0u8; bytes];
        rand::thread_rng().fill_bytes(&mut key);
        Ok(Value::String(Rc::new(
            key.iter().map(|b| format!("{:02x}", b)).collect(),
        )))
    });

    // ========================================================================
    // ENCODING
    // ========================================================================

    // base64_encode
    define(interp, "base64_encode", Some(1), |_, args| {
        let data = extract_bytes(&args[0], "base64_encode")?;
        Ok(Value::String(Rc::new(
            general_purpose::STANDARD.encode(&data),
        )))
    });

    // base64_decode
    define(interp, "base64_decode", Some(1), |_, args| {
        let encoded = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("base64_decode() requires string")),
        };

        match general_purpose::STANDARD.decode(&encoded) {
            Ok(bytes) => match String::from_utf8(bytes.clone()) {
                Ok(s) => Ok(Value::String(Rc::new(s))),
                Err(_) => Ok(bytes_to_array(&bytes)),
            },
            Err(e) => Err(RuntimeError::new(format!("base64_decode() error: {}", e))),
        }
    });

    // hex_encode
    define(interp, "hex_encode", Some(1), |_, args| {
        let data = extract_bytes(&args[0], "hex_encode")?;
        Ok(Value::String(Rc::new(
            data.iter().map(|b| format!("{:02x}", b)).collect(),
        )))
    });

    // hex_decode
    define(interp, "hex_decode", Some(1), |_, args| {
        let hex_str = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("hex_decode() requires string")),
        };

        let hex_str = hex_str.trim();
        if hex_str.len() % 2 != 0 {
            return Err(RuntimeError::new(
                "hex_decode() requires even-length hex string",
            ));
        }

        let bytes: Vec<Value> = (0..hex_str.len())
            .step_by(2)
            .map(|i| u8::from_str_radix(&hex_str[i..i + 2], 16).map(|b| Value::Int(b as i64)))
            .collect::<Result<Vec<_>, _>>()
            .map_err(|_| RuntimeError::new("hex_decode() invalid hex"))?;
        Ok(Value::Array(Rc::new(RefCell::new(bytes))))
    });

    // ========================================================================
    // CONSTANT-TIME OPERATIONS
    // ========================================================================

    // constant_time_eq - Constant-time comparison (prevents timing attacks)
    define(interp, "constant_time_eq", Some(2), |_, args| {
        let a = extract_bytes(&args[0], "constant_time_eq")?;
        let b = extract_bytes(&args[1], "constant_time_eq")?;

        if a.len() != b.len() {
            return Ok(Value::Bool(false));
        }

        let mut result = 0u8;
        for (x, y) in a.iter().zip(b.iter()) {
            result |= x ^ y;
        }
        Ok(Value::Bool(result == 0))
    });

    // ========================================================================
    // CRYPTO INFO
    // ========================================================================

    // crypto_info - Get crypto module capabilities
    define(interp, "crypto_info", Some(0), |_, _| {
        let mut info = HashMap::new();
        info.insert(
            "version".to_string(),
            Value::String(Rc::new("2.0".to_string())),
        );
        info.insert(
            "phase".to_string(),
            Value::String(Rc::new("Evidential Cryptography".to_string())),
        );

        let capabilities = vec![
            "sha256",
            "sha512",
            "sha3_256",
            "sha3_512",
            "blake3",
            "md5",
            "aes_gcm_encrypt",
            "aes_gcm_decrypt",
            "chacha20_encrypt",
            "chacha20_decrypt",
            "ed25519_keygen",
            "ed25519_sign",
            "ed25519_verify",
            "x25519_keygen",
            "x25519_exchange",
            "argon2_hash",
            "argon2_verify",
            "hkdf_expand",
            "pbkdf2_derive",
            "hmac_sha256",
            "hmac_sha512",
            "hmac_verify",
            "secure_random_bytes",
            "secure_random_hex",
            "generate_key",
            "base64_encode",
            "base64_decode",
            "hex_encode",
            "hex_decode",
            "constant_time_eq",
        ];
        let cap_values: Vec<Value> = capabilities
            .iter()
            .map(|s| Value::String(Rc::new(s.to_string())))
            .collect();
        info.insert(
            "functions".to_string(),
            Value::Array(Rc::new(RefCell::new(cap_values))),
        );

        Ok(Value::Map(Rc::new(RefCell::new(info))))
    });
}

// ============================================================================
// REGEX FUNCTIONS
// ============================================================================

fn register_regex(interp: &mut Interpreter) {
    // regex_match - check if string matches pattern
    define(interp, "regex_match", Some(2), |_, args| {
        let pattern = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("regex_match() requires string pattern")),
        };
        let text = match &args[1] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("regex_match() requires string text")),
        };

        match Regex::new(&pattern) {
            Ok(re) => Ok(Value::Bool(re.is_match(&text))),
            Err(e) => Err(RuntimeError::new(format!(
                "regex_match() invalid pattern: {}",
                e
            ))),
        }
    });

    // regex_find - find first match
    define(interp, "regex_find", Some(2), |_, args| {
        let pattern = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("regex_find() requires string pattern")),
        };
        let text = match &args[1] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("regex_find() requires string text")),
        };

        match Regex::new(&pattern) {
            Ok(re) => match re.find(&text) {
                Some(m) => Ok(Value::String(Rc::new(m.as_str().to_string()))),
                None => Ok(Value::Null),
            },
            Err(e) => Err(RuntimeError::new(format!(
                "regex_find() invalid pattern: {}",
                e
            ))),
        }
    });

    // regex_find_all - find all matches
    define(interp, "regex_find_all", Some(2), |_, args| {
        let pattern = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => {
                return Err(RuntimeError::new(
                    "regex_find_all() requires string pattern",
                ))
            }
        };
        let text = match &args[1] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("regex_find_all() requires string text")),
        };

        match Regex::new(&pattern) {
            Ok(re) => {
                let matches: Vec<Value> = re
                    .find_iter(&text)
                    .map(|m| Value::String(Rc::new(m.as_str().to_string())))
                    .collect();
                Ok(Value::Array(Rc::new(RefCell::new(matches))))
            }
            Err(e) => Err(RuntimeError::new(format!(
                "regex_find_all() invalid pattern: {}",
                e
            ))),
        }
    });

    // regex_replace - replace first match
    define(interp, "regex_replace", Some(3), |_, args| {
        let pattern = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("regex_replace() requires string pattern")),
        };
        let text = match &args[1] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("regex_replace() requires string text")),
        };
        let replacement = match &args[2] {
            Value::String(s) => s.to_string(),
            _ => {
                return Err(RuntimeError::new(
                    "regex_replace() requires string replacement",
                ))
            }
        };

        match Regex::new(&pattern) {
            Ok(re) => {
                let result = re.replace(&text, replacement.as_str());
                Ok(Value::String(Rc::new(result.to_string())))
            }
            Err(e) => Err(RuntimeError::new(format!(
                "regex_replace() invalid pattern: {}",
                e
            ))),
        }
    });

    // regex_replace_all - replace all matches
    define(interp, "regex_replace_all", Some(3), |_, args| {
        let pattern = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => {
                return Err(RuntimeError::new(
                    "regex_replace_all() requires string pattern",
                ))
            }
        };
        let text = match &args[1] {
            Value::String(s) => s.to_string(),
            _ => {
                return Err(RuntimeError::new(
                    "regex_replace_all() requires string text",
                ))
            }
        };
        let replacement = match &args[2] {
            Value::String(s) => s.to_string(),
            _ => {
                return Err(RuntimeError::new(
                    "regex_replace_all() requires string replacement",
                ))
            }
        };

        match Regex::new(&pattern) {
            Ok(re) => {
                let result = re.replace_all(&text, replacement.as_str());
                Ok(Value::String(Rc::new(result.to_string())))
            }
            Err(e) => Err(RuntimeError::new(format!(
                "regex_replace_all() invalid pattern: {}",
                e
            ))),
        }
    });

    // regex_split - split by pattern
    define(interp, "regex_split", Some(2), |_, args| {
        let pattern = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("regex_split() requires string pattern")),
        };
        let text = match &args[1] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("regex_split() requires string text")),
        };

        match Regex::new(&pattern) {
            Ok(re) => {
                let parts: Vec<Value> = re
                    .split(&text)
                    .map(|s| Value::String(Rc::new(s.to_string())))
                    .collect();
                Ok(Value::Array(Rc::new(RefCell::new(parts))))
            }
            Err(e) => Err(RuntimeError::new(format!(
                "regex_split() invalid pattern: {}",
                e
            ))),
        }
    });

    // regex_captures - capture groups
    define(interp, "regex_captures", Some(2), |_, args| {
        let pattern = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => {
                return Err(RuntimeError::new(
                    "regex_captures() requires string pattern",
                ))
            }
        };
        let text = match &args[1] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("regex_captures() requires string text")),
        };

        match Regex::new(&pattern) {
            Ok(re) => match re.captures(&text) {
                Some(caps) => {
                    let captures: Vec<Value> = caps
                        .iter()
                        .map(|m| {
                            m.map(|m| Value::String(Rc::new(m.as_str().to_string())))
                                .unwrap_or(Value::Null)
                        })
                        .collect();
                    Ok(Value::Array(Rc::new(RefCell::new(captures))))
                }
                None => Ok(Value::Null),
            },
            Err(e) => Err(RuntimeError::new(format!(
                "regex_captures() invalid pattern: {}",
                e
            ))),
        }
    });
}

// ============================================================================
// UUID FUNCTIONS
// ============================================================================

fn register_uuid(interp: &mut Interpreter) {
    // uuid_v4 - generate random UUID v4
    define(interp, "uuid_v4", Some(0), |_, _| {
        let id = Uuid::new_v4();
        Ok(Value::String(Rc::new(id.to_string())))
    });

    // uuid_nil - get nil UUID (all zeros)
    define(interp, "uuid_nil", Some(0), |_, _| {
        Ok(Value::String(Rc::new(Uuid::nil().to_string())))
    });

    // uuid_parse - parse UUID string
    define(interp, "uuid_parse", Some(1), |_, args| {
        let s = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("uuid_parse() requires string")),
        };

        match Uuid::parse_str(&s) {
            Ok(id) => Ok(Value::String(Rc::new(id.to_string()))),
            Err(e) => Err(RuntimeError::new(format!("uuid_parse() error: {}", e))),
        }
    });

    // uuid_is_valid - check if string is valid UUID
    define(interp, "uuid_is_valid", Some(1), |_, args| {
        let s = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => return Ok(Value::Bool(false)),
        };
        Ok(Value::Bool(Uuid::parse_str(&s).is_ok()))
    });
}

// ============================================================================
// SYSTEM FUNCTIONS
// ============================================================================

fn register_system(interp: &mut Interpreter) {
    // env_get - get environment variable
    define(interp, "env_get", Some(1), |_, args| {
        let key = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("env_get() requires string key")),
        };

        match std::env::var(&key) {
            Ok(val) => Ok(Value::String(Rc::new(val))),
            Err(_) => Ok(Value::Null),
        }
    });

    // env_set - set environment variable
    define(interp, "env_set", Some(2), |_, args| {
        let key = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("env_set() requires string key")),
        };
        let val = match &args[1] {
            Value::String(s) => s.to_string(),
            _ => format!("{}", args[1]),
        };

        std::env::set_var(&key, &val);
        Ok(Value::Null)
    });

    // env_remove - remove environment variable
    define(interp, "env_remove", Some(1), |_, args| {
        let key = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("env_remove() requires string key")),
        };

        std::env::remove_var(&key);
        Ok(Value::Null)
    });

    // env_vars - get all environment variables as map
    define(interp, "env_vars", Some(0), |_, _| {
        let mut map = HashMap::new();
        for (key, val) in std::env::vars() {
            map.insert(key, Value::String(Rc::new(val)));
        }
        Ok(Value::Map(Rc::new(RefCell::new(map))))
    });

    // args - get command line arguments
    define(interp, "args", Some(0), |_, _| {
        let args: Vec<Value> = std::env::args()
            .map(|s| Value::String(Rc::new(s)))
            .collect();
        Ok(Value::Array(Rc::new(RefCell::new(args))))
    });

    // cwd - get current working directory
    define(interp, "cwd", Some(0), |_, _| {
        match std::env::current_dir() {
            Ok(path) => Ok(Value::String(Rc::new(path.to_string_lossy().to_string()))),
            Err(e) => Err(RuntimeError::new(format!("cwd() error: {}", e))),
        }
    });

    // chdir - change current directory
    define(interp, "chdir", Some(1), |_, args| {
        let path = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("chdir() requires string path")),
        };

        match std::env::set_current_dir(&path) {
            Ok(()) => Ok(Value::Null),
            Err(e) => Err(RuntimeError::new(format!("chdir() error: {}", e))),
        }
    });

    // hostname - get system hostname
    define(interp, "hostname", Some(0), |_, _| {
        // Try to read from /etc/hostname or use fallback
        match std::fs::read_to_string("/etc/hostname") {
            Ok(name) => Ok(Value::String(Rc::new(name.trim().to_string()))),
            Err(_) => Ok(Value::String(Rc::new("unknown".to_string()))),
        }
    });

    // pid - get current process ID
    define(interp, "pid", Some(0), |_, _| {
        Ok(Value::Int(std::process::id() as i64))
    });

    // exit - exit the program with code
    define(interp, "exit", Some(1), |_, args| {
        let code = match &args[0] {
            Value::Int(n) => *n as i32,
            _ => 0,
        };
        std::process::exit(code);
    });

    // shell - execute shell command and return output
    define(interp, "shell", Some(1), |_, args| {
        let cmd = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("shell() requires string command")),
        };

        match std::process::Command::new("sh")
            .arg("-c")
            .arg(&cmd)
            .output()
        {
            Ok(output) => {
                let stdout = String::from_utf8_lossy(&output.stdout).to_string();
                let stderr = String::from_utf8_lossy(&output.stderr).to_string();
                let code = output.status.code().unwrap_or(-1);

                let mut result = HashMap::new();
                result.insert("stdout".to_string(), Value::String(Rc::new(stdout)));
                result.insert("stderr".to_string(), Value::String(Rc::new(stderr)));
                result.insert("code".to_string(), Value::Int(code as i64));
                result.insert("success".to_string(), Value::Bool(output.status.success()));

                Ok(Value::Map(Rc::new(RefCell::new(result))))
            }
            Err(e) => Err(RuntimeError::new(format!("shell() error: {}", e))),
        }
    });

    // platform - get OS name
    define(interp, "platform", Some(0), |_, _| {
        Ok(Value::String(Rc::new(std::env::consts::OS.to_string())))
    });

    // arch - get CPU architecture
    define(interp, "arch", Some(0), |_, _| {
        Ok(Value::String(Rc::new(std::env::consts::ARCH.to_string())))
    });
}

// ============================================================================
// STATISTICS FUNCTIONS
// ============================================================================

fn register_stats(interp: &mut Interpreter) {
    // Helper to extract numbers from array
    fn extract_numbers(val: &Value) -> Result<Vec<f64>, RuntimeError> {
        match val {
            Value::Array(arr) => {
                let arr = arr.borrow();
                let mut nums = Vec::new();
                for v in arr.iter() {
                    match v {
                        Value::Int(n) => nums.push(*n as f64),
                        Value::Float(f) => nums.push(*f),
                        _ => {
                            return Err(RuntimeError::new("stats functions require numeric array"))
                        }
                    }
                }
                Ok(nums)
            }
            _ => Err(RuntimeError::new("stats functions require array")),
        }
    }

    // mean - arithmetic mean
    define(interp, "mean", Some(1), |_, args| {
        let nums = extract_numbers(&args[0])?;
        if nums.is_empty() {
            return Ok(Value::Float(0.0));
        }
        let sum: f64 = nums.iter().sum();
        Ok(Value::Float(sum / nums.len() as f64))
    });

    // median - middle value
    define(interp, "median", Some(1), |_, args| {
        let mut nums = extract_numbers(&args[0])?;
        if nums.is_empty() {
            return Ok(Value::Float(0.0));
        }
        nums.sort_by(|a, b| a.partial_cmp(b).unwrap());
        let len = nums.len();
        if len % 2 == 0 {
            Ok(Value::Float((nums[len / 2 - 1] + nums[len / 2]) / 2.0))
        } else {
            Ok(Value::Float(nums[len / 2]))
        }
    });

    // mode - most frequent value
    define(interp, "mode", Some(1), |_, args| {
        let nums = extract_numbers(&args[0])?;
        if nums.is_empty() {
            return Ok(Value::Null);
        }

        let mut counts: HashMap<String, usize> = HashMap::new();
        for n in &nums {
            let key = format!("{:.10}", n);
            *counts.entry(key).or_insert(0) += 1;
        }

        let max_count = counts.values().max().unwrap_or(&0);
        for n in &nums {
            let key = format!("{:.10}", n);
            if counts.get(&key) == Some(max_count) {
                return Ok(Value::Float(*n));
            }
        }
        Ok(Value::Null)
    });

    // variance - population variance
    define(interp, "variance", Some(1), |_, args| {
        let nums = extract_numbers(&args[0])?;
        if nums.is_empty() {
            return Ok(Value::Float(0.0));
        }
        let mean: f64 = nums.iter().sum::<f64>() / nums.len() as f64;
        let variance: f64 =
            nums.iter().map(|x| (x - mean).powi(2)).sum::<f64>() / nums.len() as f64;
        Ok(Value::Float(variance))
    });

    // stddev - standard deviation
    define(interp, "stddev", Some(1), |_, args| {
        let nums = extract_numbers(&args[0])?;
        if nums.is_empty() {
            return Ok(Value::Float(0.0));
        }
        let mean: f64 = nums.iter().sum::<f64>() / nums.len() as f64;
        let variance: f64 =
            nums.iter().map(|x| (x - mean).powi(2)).sum::<f64>() / nums.len() as f64;
        Ok(Value::Float(variance.sqrt()))
    });

    // percentile - compute nth percentile
    define(interp, "percentile", Some(2), |_, args| {
        let mut nums = extract_numbers(&args[0])?;
        let p = match &args[1] {
            Value::Int(n) => *n as f64,
            Value::Float(f) => *f,
            _ => {
                return Err(RuntimeError::new(
                    "percentile() requires numeric percentile",
                ))
            }
        };

        if nums.is_empty() {
            return Ok(Value::Float(0.0));
        }

        nums.sort_by(|a, b| a.partial_cmp(b).unwrap());
        let idx = (p / 100.0 * (nums.len() - 1) as f64).round() as usize;
        Ok(Value::Float(nums[idx.min(nums.len() - 1)]))
    });

    // correlation - Pearson correlation coefficient
    define(interp, "correlation", Some(2), |_, args| {
        let x = extract_numbers(&args[0])?;
        let y = extract_numbers(&args[1])?;

        if x.len() != y.len() || x.is_empty() {
            return Err(RuntimeError::new(
                "correlation() requires equal-length non-empty arrays",
            ));
        }

        let n = x.len() as f64;
        let mean_x: f64 = x.iter().sum::<f64>() / n;
        let mean_y: f64 = y.iter().sum::<f64>() / n;

        let mut cov = 0.0;
        let mut var_x = 0.0;
        let mut var_y = 0.0;

        for i in 0..x.len() {
            let dx = x[i] - mean_x;
            let dy = y[i] - mean_y;
            cov += dx * dy;
            var_x += dx * dx;
            var_y += dy * dy;
        }

        if var_x == 0.0 || var_y == 0.0 {
            return Ok(Value::Float(0.0));
        }

        Ok(Value::Float(cov / (var_x.sqrt() * var_y.sqrt())))
    });

    // range - difference between max and min
    define(interp, "range", Some(1), |_, args| {
        let nums = extract_numbers(&args[0])?;
        if nums.is_empty() {
            return Ok(Value::Float(0.0));
        }
        let min = nums.iter().cloned().fold(f64::INFINITY, f64::min);
        let max = nums.iter().cloned().fold(f64::NEG_INFINITY, f64::max);
        Ok(Value::Float(max - min))
    });

    // zscore - compute z-scores for array
    define(interp, "zscore", Some(1), |_, args| {
        let nums = extract_numbers(&args[0])?;
        if nums.is_empty() {
            return Ok(Value::Array(Rc::new(RefCell::new(vec![]))));
        }

        let mean: f64 = nums.iter().sum::<f64>() / nums.len() as f64;
        let variance: f64 =
            nums.iter().map(|x| (x - mean).powi(2)).sum::<f64>() / nums.len() as f64;
        let stddev = variance.sqrt();

        if stddev == 0.0 {
            let zeros: Vec<Value> = nums.iter().map(|_| Value::Float(0.0)).collect();
            return Ok(Value::Array(Rc::new(RefCell::new(zeros))));
        }

        let zscores: Vec<Value> = nums
            .iter()
            .map(|x| Value::Float((x - mean) / stddev))
            .collect();
        Ok(Value::Array(Rc::new(RefCell::new(zscores))))
    });
}

// ============================================================================
// MATRIX FUNCTIONS
// ============================================================================

fn register_matrix(interp: &mut Interpreter) {
    // Helper to extract 2D matrix from nested arrays
    fn extract_matrix(val: &Value) -> Result<Vec<Vec<f64>>, RuntimeError> {
        match val {
            Value::Array(arr) => {
                let arr = arr.borrow();
                let mut matrix = Vec::new();
                for row in arr.iter() {
                    match row {
                        Value::Array(row_arr) => {
                            let row_arr = row_arr.borrow();
                            let mut row_vec = Vec::new();
                            for v in row_arr.iter() {
                                match v {
                                    Value::Int(n) => row_vec.push(*n as f64),
                                    Value::Float(f) => row_vec.push(*f),
                                    _ => {
                                        return Err(RuntimeError::new(
                                            "matrix requires numeric values",
                                        ))
                                    }
                                }
                            }
                            matrix.push(row_vec);
                        }
                        _ => return Err(RuntimeError::new("matrix requires 2D array")),
                    }
                }
                Ok(matrix)
            }
            _ => Err(RuntimeError::new("matrix requires array")),
        }
    }

    fn matrix_to_value(m: Vec<Vec<f64>>) -> Value {
        let rows: Vec<Value> = m
            .into_iter()
            .map(|row| {
                let cols: Vec<Value> = row.into_iter().map(Value::Float).collect();
                Value::Array(Rc::new(RefCell::new(cols)))
            })
            .collect();
        Value::Array(Rc::new(RefCell::new(rows)))
    }

    // matrix_new - create matrix filled with value
    define(interp, "matrix_new", Some(3), |_, args| {
        let rows = match &args[0] {
            Value::Int(n) => *n as usize,
            _ => return Err(RuntimeError::new("matrix_new() requires integer rows")),
        };
        let cols = match &args[1] {
            Value::Int(n) => *n as usize,
            _ => return Err(RuntimeError::new("matrix_new() requires integer cols")),
        };
        let fill = match &args[2] {
            Value::Int(n) => *n as f64,
            Value::Float(f) => *f,
            _ => 0.0,
        };

        let matrix = vec![vec![fill; cols]; rows];
        Ok(matrix_to_value(matrix))
    });

    // matrix_identity - create identity matrix
    define(interp, "matrix_identity", Some(1), |_, args| {
        let size = match &args[0] {
            Value::Int(n) => *n as usize,
            _ => return Err(RuntimeError::new("matrix_identity() requires integer size")),
        };

        let mut matrix = vec![vec![0.0; size]; size];
        for i in 0..size {
            matrix[i][i] = 1.0;
        }
        Ok(matrix_to_value(matrix))
    });

    // matrix_add - add two matrices
    define(interp, "matrix_add", Some(2), |_, args| {
        let a = extract_matrix(&args[0])?;
        let b = extract_matrix(&args[1])?;

        if a.len() != b.len() || a.is_empty() || a[0].len() != b[0].len() {
            return Err(RuntimeError::new(
                "matrix_add() requires same-size matrices",
            ));
        }

        let result: Vec<Vec<f64>> = a
            .iter()
            .zip(b.iter())
            .map(|(row_a, row_b)| row_a.iter().zip(row_b.iter()).map(|(x, y)| x + y).collect())
            .collect();

        Ok(matrix_to_value(result))
    });

    // matrix_sub - subtract two matrices
    define(interp, "matrix_sub", Some(2), |_, args| {
        let a = extract_matrix(&args[0])?;
        let b = extract_matrix(&args[1])?;

        if a.len() != b.len() || a.is_empty() || a[0].len() != b[0].len() {
            return Err(RuntimeError::new(
                "matrix_sub() requires same-size matrices",
            ));
        }

        let result: Vec<Vec<f64>> = a
            .iter()
            .zip(b.iter())
            .map(|(row_a, row_b)| row_a.iter().zip(row_b.iter()).map(|(x, y)| x - y).collect())
            .collect();

        Ok(matrix_to_value(result))
    });

    // matrix_mul - multiply two matrices
    define(interp, "matrix_mul", Some(2), |_, args| {
        let a = extract_matrix(&args[0])?;
        let b = extract_matrix(&args[1])?;

        if a.is_empty() || b.is_empty() || a[0].len() != b.len() {
            return Err(RuntimeError::new(
                "matrix_mul() requires compatible matrices (a.cols == b.rows)",
            ));
        }

        let rows = a.len();
        let cols = b[0].len();
        let inner = b.len();

        let mut result = vec![vec![0.0; cols]; rows];
        for i in 0..rows {
            for j in 0..cols {
                for k in 0..inner {
                    result[i][j] += a[i][k] * b[k][j];
                }
            }
        }

        Ok(matrix_to_value(result))
    });

    // matrix_scale - multiply matrix by scalar
    define(interp, "matrix_scale", Some(2), |_, args| {
        let m = extract_matrix(&args[0])?;
        let scale = match &args[1] {
            Value::Int(n) => *n as f64,
            Value::Float(f) => *f,
            _ => return Err(RuntimeError::new("matrix_scale() requires numeric scalar")),
        };

        let result: Vec<Vec<f64>> = m
            .iter()
            .map(|row| row.iter().map(|x| x * scale).collect())
            .collect();

        Ok(matrix_to_value(result))
    });

    // matrix_transpose - transpose matrix
    define(interp, "matrix_transpose", Some(1), |_, args| {
        let m = extract_matrix(&args[0])?;
        if m.is_empty() {
            return Ok(Value::Array(Rc::new(RefCell::new(vec![]))));
        }

        let rows = m.len();
        let cols = m[0].len();
        let mut result = vec![vec![0.0; rows]; cols];

        for i in 0..rows {
            for j in 0..cols {
                result[j][i] = m[i][j];
            }
        }

        Ok(matrix_to_value(result))
    });

    // matrix_det - determinant (for 2x2 and 3x3)
    define(interp, "matrix_det", Some(1), |_, args| {
        let m = extract_matrix(&args[0])?;

        if m.is_empty() || m.len() != m[0].len() {
            return Err(RuntimeError::new("matrix_det() requires square matrix"));
        }

        let n = m.len();
        match n {
            1 => Ok(Value::Float(m[0][0])),
            2 => Ok(Value::Float(m[0][0] * m[1][1] - m[0][1] * m[1][0])),
            3 => {
                let det = m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1])
                    - m[0][1] * (m[1][0] * m[2][2] - m[1][2] * m[2][0])
                    + m[0][2] * (m[1][0] * m[2][1] - m[1][1] * m[2][0]);
                Ok(Value::Float(det))
            }
            _ => Err(RuntimeError::new(
                "matrix_det() only supports up to 3x3 matrices",
            )),
        }
    });

    // matrix_trace - trace (sum of diagonal)
    define(interp, "matrix_trace", Some(1), |_, args| {
        let m = extract_matrix(&args[0])?;

        let size = m.len().min(if m.is_empty() { 0 } else { m[0].len() });
        let trace: f64 = (0..size).map(|i| m[i][i]).sum();

        Ok(Value::Float(trace))
    });

    // matrix_dot - dot product of vectors (1D arrays)
    define(interp, "matrix_dot", Some(2), |_, args| {
        fn extract_vector(val: &Value) -> Result<Vec<f64>, RuntimeError> {
            match val {
                Value::Array(arr) => {
                    let arr = arr.borrow();
                    let mut vec = Vec::new();
                    for v in arr.iter() {
                        match v {
                            Value::Int(n) => vec.push(*n as f64),
                            Value::Float(f) => vec.push(*f),
                            _ => {
                                return Err(RuntimeError::new(
                                    "dot product requires numeric vectors",
                                ))
                            }
                        }
                    }
                    Ok(vec)
                }
                _ => Err(RuntimeError::new("dot product requires arrays")),
            }
        }

        let a = extract_vector(&args[0])?;
        let b = extract_vector(&args[1])?;

        if a.len() != b.len() {
            return Err(RuntimeError::new(
                "matrix_dot() requires same-length vectors",
            ));
        }

        let dot: f64 = a.iter().zip(b.iter()).map(|(x, y)| x * y).sum();
        Ok(Value::Float(dot))
    });
}

// Extended Euclidean algorithm for modular inverse
fn mod_inverse(a: i64, m: i64) -> Option<i64> {
    let (mut old_r, mut r) = (a, m);
    let (mut old_s, mut s) = (1i64, 0i64);

    while r != 0 {
        let q = old_r / r;
        (old_r, r) = (r, old_r - q * r);
        (old_s, s) = (s, old_s - q * s);
    }

    if old_r != 1 {
        None // No inverse exists
    } else {
        Some(old_s.rem_euclid(m))
    }
}

// ============================================================================
// Phase 5: Language Power-Ups
// ============================================================================

/// Functional programming utilities
fn register_functional(interp: &mut Interpreter) {
    // identity - returns its argument unchanged
    define(interp, "identity", Some(1), |_, args| Ok(args[0].clone()));

    // const_fn - returns a function that always returns the given value
    define(interp, "const_fn", Some(1), |_, args| Ok(args[0].clone()));

    // apply - apply a function to an array of arguments
    define(interp, "apply", Some(2), |interp, args| {
        let func = match &args[0] {
            Value::Function(f) => f.clone(),
            _ => {
                return Err(RuntimeError::new(
                    "apply: first argument must be a function",
                ))
            }
        };
        let fn_args = match &args[1] {
            Value::Array(arr) => arr.borrow().clone(),
            _ => return Err(RuntimeError::new("apply: second argument must be an array")),
        };
        interp.call_function(&func, fn_args)
    });

    // flip - swap the first two arguments of a binary function
    define(interp, "flip", Some(3), |interp, args| {
        let func = match &args[0] {
            Value::Function(f) => f.clone(),
            _ => return Err(RuntimeError::new("flip: first argument must be a function")),
        };
        let flipped_args = vec![args[2].clone(), args[1].clone()];
        interp.call_function(&func, flipped_args)
    });

    // tap - execute a function for side effects, return original value
    define(interp, "tap", Some(2), |interp, args| {
        let val = args[0].clone();
        let func = match &args[1] {
            Value::Function(f) => f.clone(),
            _ => return Err(RuntimeError::new("tap: second argument must be a function")),
        };
        let _ = interp.call_function(&func, vec![val.clone()]);
        Ok(val)
    });

    // thunk - create a delayed computation (wrap in array for later forcing)
    define(interp, "thunk", Some(1), |_, args| {
        Ok(Value::Array(Rc::new(RefCell::new(vec![args[0].clone()]))))
    });

    // force - force evaluation of a thunk
    define(interp, "force", Some(1), |interp, args| match &args[0] {
        Value::Array(arr) => {
            let arr = arr.borrow();
            if arr.len() == 1 {
                if let Value::Function(f) = &arr[0] {
                    return interp.call_function(f, vec![]);
                }
            }
            Ok(arr.get(0).cloned().unwrap_or(Value::Null))
        }
        v => Ok(v.clone()),
    });

    // negate - negate a predicate function result
    define(interp, "negate", Some(2), |interp, args| {
        let func = match &args[0] {
            Value::Function(f) => f.clone(),
            _ => {
                return Err(RuntimeError::new(
                    "negate: first argument must be a function",
                ))
            }
        };
        let result = interp.call_function(&func, vec![args[1].clone()])?;
        Ok(Value::Bool(!is_truthy(&result)))
    });

    // complement - same as negate
    define(interp, "complement", Some(2), |interp, args| {
        let func = match &args[0] {
            Value::Function(f) => f.clone(),
            _ => {
                return Err(RuntimeError::new(
                    "complement: first argument must be a function",
                ))
            }
        };
        let result = interp.call_function(&func, vec![args[1].clone()])?;
        Ok(Value::Bool(!is_truthy(&result)))
    });

    // partial - partially apply a function with some arguments
    define(interp, "partial", None, |interp, args| {
        if args.len() < 2 {
            return Err(RuntimeError::new(
                "partial: requires at least function and one argument",
            ));
        }
        let func = match &args[0] {
            Value::Function(f) => f.clone(),
            _ => {
                return Err(RuntimeError::new(
                    "partial: first argument must be a function",
                ))
            }
        };
        let partial_args: Vec<Value> = args[1..].to_vec();
        interp.call_function(&func, partial_args)
    });

    // juxt - apply multiple functions to same args, return array of results
    define(interp, "juxt", None, |interp, args| {
        if args.len() < 2 {
            return Err(RuntimeError::new("juxt: requires functions and a value"));
        }
        let val = args.last().unwrap().clone();
        let results: Result<Vec<Value>, _> = args[..args.len() - 1]
            .iter()
            .map(|f| match f {
                Value::Function(func) => interp.call_function(func, vec![val.clone()]),
                _ => Err(RuntimeError::new(
                    "juxt: all but last argument must be functions",
                )),
            })
            .collect();
        Ok(Value::Array(Rc::new(RefCell::new(results?))))
    });
}

/// Benchmarking and profiling utilities
fn register_benchmark(interp: &mut Interpreter) {
    // bench - run a function N times and return average time in ms
    define(interp, "bench", Some(2), |interp, args| {
        let func = match &args[0] {
            Value::Function(f) => f.clone(),
            _ => {
                return Err(RuntimeError::new(
                    "bench: first argument must be a function",
                ))
            }
        };
        let iterations = match &args[1] {
            Value::Int(n) => *n as usize,
            _ => {
                return Err(RuntimeError::new(
                    "bench: second argument must be an integer",
                ))
            }
        };

        let start = std::time::Instant::now();
        for _ in 0..iterations {
            let _ = interp.call_function(&func, vec![])?;
        }
        let elapsed = start.elapsed();
        let avg_ms = elapsed.as_secs_f64() * 1000.0 / iterations as f64;
        Ok(Value::Float(avg_ms))
    });

    // time_it - run a function once and return (result, time_ms) tuple
    define(interp, "time_it", Some(1), |interp, args| {
        let func = match &args[0] {
            Value::Function(f) => f.clone(),
            _ => return Err(RuntimeError::new("time_it: argument must be a function")),
        };

        let start = std::time::Instant::now();
        let result = interp.call_function(&func, vec![])?;
        let elapsed_ms = start.elapsed().as_secs_f64() * 1000.0;

        Ok(Value::Tuple(Rc::new(vec![
            result,
            Value::Float(elapsed_ms),
        ])))
    });

    // stopwatch_start - return current time in ms
    define(interp, "stopwatch_start", Some(0), |_, _| {
        let elapsed = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap_or_default();
        Ok(Value::Float(elapsed.as_secs_f64() * 1000.0))
    });

    // stopwatch_elapsed - get elapsed time since a stopwatch start
    define(interp, "stopwatch_elapsed", Some(1), |_, args| {
        let start_ms = match &args[0] {
            Value::Float(f) => *f,
            Value::Int(n) => *n as f64,
            _ => {
                return Err(RuntimeError::new(
                    "stopwatch_elapsed: argument must be a number",
                ))
            }
        };
        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap_or_default();
        let now_ms = now.as_secs_f64() * 1000.0;
        Ok(Value::Float(now_ms - start_ms))
    });

    // compare_bench - compare two functions, return speedup ratio
    define(interp, "compare_bench", Some(3), |interp, args| {
        let func1 = match &args[0] {
            Value::Function(f) => f.clone(),
            _ => {
                return Err(RuntimeError::new(
                    "compare_bench: first argument must be a function",
                ))
            }
        };
        let func2 = match &args[1] {
            Value::Function(f) => f.clone(),
            _ => {
                return Err(RuntimeError::new(
                    "compare_bench: second argument must be a function",
                ))
            }
        };
        let iterations = match &args[2] {
            Value::Int(n) => *n as usize,
            _ => {
                return Err(RuntimeError::new(
                    "compare_bench: third argument must be an integer",
                ))
            }
        };

        let start1 = std::time::Instant::now();
        for _ in 0..iterations {
            let _ = interp.call_function(&func1, vec![])?;
        }
        let time1 = start1.elapsed().as_secs_f64();

        let start2 = std::time::Instant::now();
        for _ in 0..iterations {
            let _ = interp.call_function(&func2, vec![])?;
        }
        let time2 = start2.elapsed().as_secs_f64();

        let mut results = std::collections::HashMap::new();
        results.insert("time1_ms".to_string(), Value::Float(time1 * 1000.0));
        results.insert("time2_ms".to_string(), Value::Float(time2 * 1000.0));
        results.insert("speedup".to_string(), Value::Float(time1 / time2));
        results.insert("iterations".to_string(), Value::Int(iterations as i64));

        Ok(Value::Struct {
            name: "BenchResult".to_string(),
            fields: Rc::new(RefCell::new(results)),
        })
    });

    // memory_usage - placeholder
    define(interp, "memory_usage", Some(0), |_, _| Ok(Value::Int(0)));
}

/// Extended iterator utilities (itertools-inspired)
fn register_itertools(interp: &mut Interpreter) {
    // cycle - create infinite cycle of array elements (returns first N)
    define(interp, "cycle", Some(2), |_, args| {
        let arr = match &args[0] {
            Value::Array(a) => a.borrow().clone(),
            _ => return Err(RuntimeError::new("cycle: first argument must be an array")),
        };
        let n = match &args[1] {
            Value::Int(n) => *n as usize,
            _ => {
                return Err(RuntimeError::new(
                    "cycle: second argument must be an integer",
                ))
            }
        };

        if arr.is_empty() {
            return Ok(Value::Array(Rc::new(RefCell::new(vec![]))));
        }

        let result: Vec<Value> = (0..n).map(|i| arr[i % arr.len()].clone()).collect();
        Ok(Value::Array(Rc::new(RefCell::new(result))))
    });

    // repeat_val - repeat a value N times
    define(interp, "repeat_val", Some(2), |_, args| {
        let val = args[0].clone();
        let n = match &args[1] {
            Value::Int(n) => *n as usize,
            _ => {
                return Err(RuntimeError::new(
                    "repeat_val: second argument must be an integer",
                ))
            }
        };

        let result: Vec<Value> = std::iter::repeat(val).take(n).collect();
        Ok(Value::Array(Rc::new(RefCell::new(result))))
    });

    // take_while - take elements while predicate is true
    define(interp, "take_while", Some(2), |interp, args| {
        let arr = match &args[0] {
            Value::Array(a) => a.borrow().clone(),
            _ => {
                return Err(RuntimeError::new(
                    "take_while: first argument must be an array",
                ))
            }
        };
        let pred = match &args[1] {
            Value::Function(f) => f.clone(),
            _ => {
                return Err(RuntimeError::new(
                    "take_while: second argument must be a function",
                ))
            }
        };

        let mut result = Vec::new();
        for item in arr {
            let keep = interp.call_function(&pred, vec![item.clone()])?;
            if is_truthy(&keep) {
                result.push(item);
            } else {
                break;
            }
        }
        Ok(Value::Array(Rc::new(RefCell::new(result))))
    });

    // drop_while - drop elements while predicate is true
    define(interp, "drop_while", Some(2), |interp, args| {
        let arr = match &args[0] {
            Value::Array(a) => a.borrow().clone(),
            _ => {
                return Err(RuntimeError::new(
                    "drop_while: first argument must be an array",
                ))
            }
        };
        let pred = match &args[1] {
            Value::Function(f) => f.clone(),
            _ => {
                return Err(RuntimeError::new(
                    "drop_while: second argument must be a function",
                ))
            }
        };

        let mut dropping = true;
        let mut result = Vec::new();
        for item in arr {
            if dropping {
                let drop = interp.call_function(&pred, vec![item.clone()])?;
                if !is_truthy(&drop) {
                    dropping = false;
                    result.push(item);
                }
            } else {
                result.push(item);
            }
        }
        Ok(Value::Array(Rc::new(RefCell::new(result))))
    });

    // group_by - group consecutive elements by key function
    define(interp, "group_by", Some(2), |interp, args| {
        let arr = match &args[0] {
            Value::Array(a) => a.borrow().clone(),
            _ => {
                return Err(RuntimeError::new(
                    "group_by: first argument must be an array",
                ))
            }
        };
        let key_fn = match &args[1] {
            Value::Function(f) => f.clone(),
            _ => {
                return Err(RuntimeError::new(
                    "group_by: second argument must be a function",
                ))
            }
        };

        let mut groups: Vec<Value> = Vec::new();
        let mut current_group: Vec<Value> = Vec::new();
        let mut current_key: Option<Value> = None;

        for item in arr {
            let key = interp.call_function(&key_fn, vec![item.clone()])?;
            match &current_key {
                Some(k) if value_eq(k, &key) => {
                    current_group.push(item);
                }
                _ => {
                    if !current_group.is_empty() {
                        groups.push(Value::Array(Rc::new(RefCell::new(current_group))));
                    }
                    current_group = vec![item];
                    current_key = Some(key);
                }
            }
        }
        if !current_group.is_empty() {
            groups.push(Value::Array(Rc::new(RefCell::new(current_group))));
        }

        Ok(Value::Array(Rc::new(RefCell::new(groups))))
    });

    // partition - split array by predicate into (true_items, false_items)
    define(interp, "partition", Some(2), |interp, args| {
        let arr = match &args[0] {
            Value::Array(a) => a.borrow().clone(),
            _ => {
                return Err(RuntimeError::new(
                    "partition: first argument must be an array",
                ))
            }
        };
        let pred = match &args[1] {
            Value::Function(f) => f.clone(),
            _ => {
                return Err(RuntimeError::new(
                    "partition: second argument must be a function",
                ))
            }
        };

        let mut true_items = Vec::new();
        let mut false_items = Vec::new();

        for item in arr {
            let result = interp.call_function(&pred, vec![item.clone()])?;
            if is_truthy(&result) {
                true_items.push(item);
            } else {
                false_items.push(item);
            }
        }

        Ok(Value::Tuple(Rc::new(vec![
            Value::Array(Rc::new(RefCell::new(true_items))),
            Value::Array(Rc::new(RefCell::new(false_items))),
        ])))
    });

    // interleave - interleave two arrays
    define(interp, "interleave", Some(2), |_, args| {
        let arr1 = match &args[0] {
            Value::Array(a) => a.borrow().clone(),
            _ => {
                return Err(RuntimeError::new(
                    "interleave: first argument must be an array",
                ))
            }
        };
        let arr2 = match &args[1] {
            Value::Array(a) => a.borrow().clone(),
            _ => {
                return Err(RuntimeError::new(
                    "interleave: second argument must be an array",
                ))
            }
        };

        let mut result = Vec::new();
        let mut i1 = arr1.into_iter();
        let mut i2 = arr2.into_iter();

        loop {
            match (i1.next(), i2.next()) {
                (Some(a), Some(b)) => {
                    result.push(a);
                    result.push(b);
                }
                (Some(a), None) => {
                    result.push(a);
                    result.extend(i1);
                    break;
                }
                (None, Some(b)) => {
                    result.push(b);
                    result.extend(i2);
                    break;
                }
                (None, None) => break,
            }
        }

        Ok(Value::Array(Rc::new(RefCell::new(result))))
    });

    // chunks - split array into chunks of size N
    define(interp, "chunks", Some(2), |_, args| {
        let arr = match &args[0] {
            Value::Array(a) => a.borrow().clone(),
            _ => return Err(RuntimeError::new("chunks: first argument must be an array")),
        };
        let size = match &args[1] {
            Value::Int(n) if *n > 0 => *n as usize,
            _ => {
                return Err(RuntimeError::new(
                    "chunks: second argument must be a positive integer",
                ))
            }
        };

        let chunks: Vec<Value> = arr
            .chunks(size)
            .map(|chunk| Value::Array(Rc::new(RefCell::new(chunk.to_vec()))))
            .collect();

        Ok(Value::Array(Rc::new(RefCell::new(chunks))))
    });

    // windows - sliding windows of size N
    define(interp, "windows", Some(2), |_, args| {
        let arr = match &args[0] {
            Value::Array(a) => a.borrow().clone(),
            _ => {
                return Err(RuntimeError::new(
                    "windows: first argument must be an array",
                ))
            }
        };
        let size = match &args[1] {
            Value::Int(n) if *n > 0 => *n as usize,
            _ => {
                return Err(RuntimeError::new(
                    "windows: second argument must be a positive integer",
                ))
            }
        };

        if arr.len() < size {
            return Ok(Value::Array(Rc::new(RefCell::new(vec![]))));
        }

        let windows: Vec<Value> = arr
            .windows(size)
            .map(|window| Value::Array(Rc::new(RefCell::new(window.to_vec()))))
            .collect();

        Ok(Value::Array(Rc::new(RefCell::new(windows))))
    });

    // scan - like fold but returns all intermediate values
    define(interp, "scan", Some(3), |interp, args| {
        let arr = match &args[0] {
            Value::Array(a) => a.borrow().clone(),
            _ => return Err(RuntimeError::new("scan: first argument must be an array")),
        };
        let init = args[1].clone();
        let func = match &args[2] {
            Value::Function(f) => f.clone(),
            _ => return Err(RuntimeError::new("scan: third argument must be a function")),
        };

        let mut results = vec![init.clone()];
        let mut acc = init;

        for item in arr {
            acc = interp.call_function(&func, vec![acc, item])?;
            results.push(acc.clone());
        }

        Ok(Value::Array(Rc::new(RefCell::new(results))))
    });

    // frequencies - count occurrences of each element
    define(interp, "frequencies", Some(1), |_, args| {
        let arr = match &args[0] {
            Value::Array(a) => a.borrow().clone(),
            _ => return Err(RuntimeError::new("frequencies: argument must be an array")),
        };

        let mut counts: std::collections::HashMap<String, i64> = std::collections::HashMap::new();
        for item in &arr {
            let key = format!("{}", item);
            *counts.entry(key).or_insert(0) += 1;
        }

        let result: std::collections::HashMap<String, Value> = counts
            .into_iter()
            .map(|(k, v)| (k, Value::Int(v)))
            .collect();

        Ok(Value::Map(Rc::new(RefCell::new(result))))
    });

    // dedupe - remove consecutive duplicates
    define(interp, "dedupe", Some(1), |_, args| {
        let arr = match &args[0] {
            Value::Array(a) => a.borrow().clone(),
            _ => return Err(RuntimeError::new("dedupe: argument must be an array")),
        };

        let mut result = Vec::new();
        let mut prev: Option<Value> = None;

        for item in arr {
            match &prev {
                Some(p) if value_eq(p, &item) => continue,
                _ => {
                    result.push(item.clone());
                    prev = Some(item);
                }
            }
        }

        Ok(Value::Array(Rc::new(RefCell::new(result))))
    });

    // unique - remove all duplicates (not just consecutive)
    define(interp, "unique", Some(1), |_, args| {
        let arr = match &args[0] {
            Value::Array(a) => a.borrow().clone(),
            _ => return Err(RuntimeError::new("unique: argument must be an array")),
        };

        let mut seen = std::collections::HashSet::new();
        let mut result = Vec::new();

        for item in arr {
            let key = format!("{}", item);
            if seen.insert(key) {
                result.push(item);
            }
        }

        Ok(Value::Array(Rc::new(RefCell::new(result))))
    });
}

/// Advanced range utilities
fn register_ranges(interp: &mut Interpreter) {
    // range_step - range with custom step
    define(interp, "range_step", Some(3), |_, args| {
        let start = match &args[0] {
            Value::Int(n) => *n,
            Value::Float(f) => *f as i64,
            _ => return Err(RuntimeError::new("range_step: start must be a number")),
        };
        let end = match &args[1] {
            Value::Int(n) => *n,
            Value::Float(f) => *f as i64,
            _ => return Err(RuntimeError::new("range_step: end must be a number")),
        };
        let step = match &args[2] {
            Value::Int(n) if *n != 0 => *n,
            Value::Float(f) if *f != 0.0 => *f as i64,
            _ => {
                return Err(RuntimeError::new(
                    "range_step: step must be a non-zero number",
                ))
            }
        };

        let mut result = Vec::new();
        if step > 0 {
            let mut i = start;
            while i < end {
                result.push(Value::Int(i));
                i += step;
            }
        } else {
            let mut i = start;
            while i > end {
                result.push(Value::Int(i));
                i += step;
            }
        }

        Ok(Value::Array(Rc::new(RefCell::new(result))))
    });

    // linspace - N evenly spaced values from start to end (inclusive)
    define(interp, "linspace", Some(3), |_, args| {
        let start = match &args[0] {
            Value::Int(n) => *n as f64,
            Value::Float(f) => *f,
            _ => return Err(RuntimeError::new("linspace: start must be a number")),
        };
        let end = match &args[1] {
            Value::Int(n) => *n as f64,
            Value::Float(f) => *f,
            _ => return Err(RuntimeError::new("linspace: end must be a number")),
        };
        let n = match &args[2] {
            Value::Int(n) if *n > 0 => *n as usize,
            _ => {
                return Err(RuntimeError::new(
                    "linspace: count must be a positive integer",
                ))
            }
        };

        if n == 1 {
            return Ok(Value::Array(Rc::new(RefCell::new(vec![Value::Float(
                start,
            )]))));
        }

        let step = (end - start) / (n - 1) as f64;
        let result: Vec<Value> = (0..n)
            .map(|i| Value::Float(start + step * i as f64))
            .collect();

        Ok(Value::Array(Rc::new(RefCell::new(result))))
    });

    // logspace - N logarithmically spaced values
    define(interp, "logspace", Some(3), |_, args| {
        let start_exp = match &args[0] {
            Value::Int(n) => *n as f64,
            Value::Float(f) => *f,
            _ => {
                return Err(RuntimeError::new(
                    "logspace: start exponent must be a number",
                ))
            }
        };
        let end_exp = match &args[1] {
            Value::Int(n) => *n as f64,
            Value::Float(f) => *f,
            _ => return Err(RuntimeError::new("logspace: end exponent must be a number")),
        };
        let n = match &args[2] {
            Value::Int(n) if *n > 0 => *n as usize,
            _ => {
                return Err(RuntimeError::new(
                    "logspace: count must be a positive integer",
                ))
            }
        };

        if n == 1 {
            return Ok(Value::Array(Rc::new(RefCell::new(vec![Value::Float(
                10f64.powf(start_exp),
            )]))));
        }

        let step = (end_exp - start_exp) / (n - 1) as f64;
        let result: Vec<Value> = (0..n)
            .map(|i| Value::Float(10f64.powf(start_exp + step * i as f64)))
            .collect();

        Ok(Value::Array(Rc::new(RefCell::new(result))))
    });

    // arange - like numpy arange (start, stop, step with float support)
    define(interp, "arange", Some(3), |_, args| {
        let start = match &args[0] {
            Value::Int(n) => *n as f64,
            Value::Float(f) => *f,
            _ => return Err(RuntimeError::new("arange: start must be a number")),
        };
        let stop = match &args[1] {
            Value::Int(n) => *n as f64,
            Value::Float(f) => *f,
            _ => return Err(RuntimeError::new("arange: stop must be a number")),
        };
        let step = match &args[2] {
            Value::Int(n) if *n != 0 => *n as f64,
            Value::Float(f) if *f != 0.0 => *f,
            _ => return Err(RuntimeError::new("arange: step must be a non-zero number")),
        };

        let mut result = Vec::new();
        if step > 0.0 {
            let mut x = start;
            while x < stop {
                result.push(Value::Float(x));
                x += step;
            }
        } else {
            let mut x = start;
            while x > stop {
                result.push(Value::Float(x));
                x += step;
            }
        }

        Ok(Value::Array(Rc::new(RefCell::new(result))))
    });

    // geomspace - geometrically spaced values (like logspace but using actual values)
    define(interp, "geomspace", Some(3), |_, args| {
        let start = match &args[0] {
            Value::Int(n) if *n > 0 => *n as f64,
            Value::Float(f) if *f > 0.0 => *f,
            _ => {
                return Err(RuntimeError::new(
                    "geomspace: start must be a positive number",
                ))
            }
        };
        let end = match &args[1] {
            Value::Int(n) if *n > 0 => *n as f64,
            Value::Float(f) if *f > 0.0 => *f,
            _ => {
                return Err(RuntimeError::new(
                    "geomspace: end must be a positive number",
                ))
            }
        };
        let n = match &args[2] {
            Value::Int(n) if *n > 0 => *n as usize,
            _ => {
                return Err(RuntimeError::new(
                    "geomspace: count must be a positive integer",
                ))
            }
        };

        if n == 1 {
            return Ok(Value::Array(Rc::new(RefCell::new(vec![Value::Float(
                start,
            )]))));
        }

        let ratio = (end / start).powf(1.0 / (n - 1) as f64);
        let result: Vec<Value> = (0..n)
            .map(|i| Value::Float(start * ratio.powi(i as i32)))
            .collect();

        Ok(Value::Array(Rc::new(RefCell::new(result))))
    });
}

/// Bitwise operations
fn register_bitwise(interp: &mut Interpreter) {
    define(interp, "bit_and", Some(2), |_, args| {
        let a = match &args[0] {
            Value::Int(n) => *n,
            _ => return Err(RuntimeError::new("bit_and: arguments must be integers")),
        };
        let b = match &args[1] {
            Value::Int(n) => *n,
            _ => return Err(RuntimeError::new("bit_and: arguments must be integers")),
        };
        Ok(Value::Int(a & b))
    });

    define(interp, "bit_or", Some(2), |_, args| {
        let a = match &args[0] {
            Value::Int(n) => *n,
            _ => return Err(RuntimeError::new("bit_or: arguments must be integers")),
        };
        let b = match &args[1] {
            Value::Int(n) => *n,
            _ => return Err(RuntimeError::new("bit_or: arguments must be integers")),
        };
        Ok(Value::Int(a | b))
    });

    define(interp, "bit_xor", Some(2), |_, args| {
        let a = match &args[0] {
            Value::Int(n) => *n,
            _ => return Err(RuntimeError::new("bit_xor: arguments must be integers")),
        };
        let b = match &args[1] {
            Value::Int(n) => *n,
            _ => return Err(RuntimeError::new("bit_xor: arguments must be integers")),
        };
        Ok(Value::Int(a ^ b))
    });

    define(interp, "bit_not", Some(1), |_, args| {
        let a = match &args[0] {
            Value::Int(n) => *n,
            _ => return Err(RuntimeError::new("bit_not: argument must be an integer")),
        };
        Ok(Value::Int(!a))
    });

    define(interp, "bit_shl", Some(2), |_, args| {
        let a = match &args[0] {
            Value::Int(n) => *n,
            _ => {
                return Err(RuntimeError::new(
                    "bit_shl: first argument must be an integer",
                ))
            }
        };
        let b = match &args[1] {
            Value::Int(n) if *n >= 0 && *n < 64 => *n as u32,
            _ => return Err(RuntimeError::new("bit_shl: shift amount must be 0-63")),
        };
        Ok(Value::Int(a << b))
    });

    define(interp, "bit_shr", Some(2), |_, args| {
        let a = match &args[0] {
            Value::Int(n) => *n,
            _ => {
                return Err(RuntimeError::new(
                    "bit_shr: first argument must be an integer",
                ))
            }
        };
        let b = match &args[1] {
            Value::Int(n) if *n >= 0 && *n < 64 => *n as u32,
            _ => return Err(RuntimeError::new("bit_shr: shift amount must be 0-63")),
        };
        Ok(Value::Int(a >> b))
    });

    define(interp, "popcount", Some(1), |_, args| {
        let a = match &args[0] {
            Value::Int(n) => *n,
            _ => return Err(RuntimeError::new("popcount: argument must be an integer")),
        };
        Ok(Value::Int(a.count_ones() as i64))
    });

    define(interp, "leading_zeros", Some(1), |_, args| {
        let a = match &args[0] {
            Value::Int(n) => *n,
            _ => {
                return Err(RuntimeError::new(
                    "leading_zeros: argument must be an integer",
                ))
            }
        };
        Ok(Value::Int(a.leading_zeros() as i64))
    });

    define(interp, "trailing_zeros", Some(1), |_, args| {
        let a = match &args[0] {
            Value::Int(n) => *n,
            _ => {
                return Err(RuntimeError::new(
                    "trailing_zeros: argument must be an integer",
                ))
            }
        };
        Ok(Value::Int(a.trailing_zeros() as i64))
    });

    define(interp, "bit_test", Some(2), |_, args| {
        let a = match &args[0] {
            Value::Int(n) => *n,
            _ => {
                return Err(RuntimeError::new(
                    "bit_test: first argument must be an integer",
                ))
            }
        };
        let pos = match &args[1] {
            Value::Int(n) if *n >= 0 && *n < 64 => *n as u32,
            _ => return Err(RuntimeError::new("bit_test: position must be 0-63")),
        };
        Ok(Value::Bool((a >> pos) & 1 == 1))
    });

    define(interp, "bit_set", Some(2), |_, args| {
        let a = match &args[0] {
            Value::Int(n) => *n,
            _ => {
                return Err(RuntimeError::new(
                    "bit_set: first argument must be an integer",
                ))
            }
        };
        let pos = match &args[1] {
            Value::Int(n) if *n >= 0 && *n < 64 => *n as u32,
            _ => return Err(RuntimeError::new("bit_set: position must be 0-63")),
        };
        Ok(Value::Int(a | (1 << pos)))
    });

    define(interp, "bit_clear", Some(2), |_, args| {
        let a = match &args[0] {
            Value::Int(n) => *n,
            _ => {
                return Err(RuntimeError::new(
                    "bit_clear: first argument must be an integer",
                ))
            }
        };
        let pos = match &args[1] {
            Value::Int(n) if *n >= 0 && *n < 64 => *n as u32,
            _ => return Err(RuntimeError::new("bit_clear: position must be 0-63")),
        };
        Ok(Value::Int(a & !(1 << pos)))
    });

    define(interp, "bit_toggle", Some(2), |_, args| {
        let a = match &args[0] {
            Value::Int(n) => *n,
            _ => {
                return Err(RuntimeError::new(
                    "bit_toggle: first argument must be an integer",
                ))
            }
        };
        let pos = match &args[1] {
            Value::Int(n) if *n >= 0 && *n < 64 => *n as u32,
            _ => return Err(RuntimeError::new("bit_toggle: position must be 0-63")),
        };
        Ok(Value::Int(a ^ (1 << pos)))
    });

    define(interp, "to_binary", Some(1), |_, args| {
        let a = match &args[0] {
            Value::Int(n) => *n,
            _ => return Err(RuntimeError::new("to_binary: argument must be an integer")),
        };
        Ok(Value::String(Rc::new(format!("{:b}", a))))
    });

    define(interp, "from_binary", Some(1), |_, args| {
        let s = match &args[0] {
            Value::String(s) => (**s).clone(),
            _ => return Err(RuntimeError::new("from_binary: argument must be a string")),
        };
        match i64::from_str_radix(&s, 2) {
            Ok(n) => Ok(Value::Int(n)),
            Err(_) => Err(RuntimeError::new("from_binary: invalid binary string")),
        }
    });

    define(interp, "to_hex", Some(1), |_, args| {
        let a = match &args[0] {
            Value::Int(n) => *n,
            _ => return Err(RuntimeError::new("to_hex: argument must be an integer")),
        };
        Ok(Value::String(Rc::new(format!("{:x}", a))))
    });

    define(interp, "from_hex", Some(1), |_, args| {
        let s = match &args[0] {
            Value::String(s) => s.trim_start_matches("0x").to_string(),
            _ => return Err(RuntimeError::new("from_hex: argument must be a string")),
        };
        match i64::from_str_radix(&s, 16) {
            Ok(n) => Ok(Value::Int(n)),
            Err(_) => Err(RuntimeError::new("from_hex: invalid hex string")),
        }
    });

    define(interp, "to_octal", Some(1), |_, args| {
        let a = match &args[0] {
            Value::Int(n) => *n,
            _ => return Err(RuntimeError::new("to_octal: argument must be an integer")),
        };
        Ok(Value::String(Rc::new(format!("{:o}", a))))
    });

    define(interp, "from_octal", Some(1), |_, args| {
        let s = match &args[0] {
            Value::String(s) => s.trim_start_matches("0o").to_string(),
            _ => return Err(RuntimeError::new("from_octal: argument must be a string")),
        };
        match i64::from_str_radix(&s, 8) {
            Ok(n) => Ok(Value::Int(n)),
            Err(_) => Err(RuntimeError::new("from_octal: invalid octal string")),
        }
    });
}

/// String formatting utilities
fn register_format(interp: &mut Interpreter) {
    // format - basic string formatting with {} placeholders
    define(interp, "format", None, |_, args| {
        if args.is_empty() {
            return Err(RuntimeError::new(
                "format: requires at least a format string",
            ));
        }
        let template = match &args[0] {
            Value::String(s) => (**s).clone(),
            _ => return Err(RuntimeError::new("format: first argument must be a string")),
        };
        let mut result = template;
        for arg in &args[1..] {
            if let Some(pos) = result.find("{}") {
                result = format!("{}{}{}", &result[..pos], arg, &result[pos + 2..]);
            }
        }
        Ok(Value::String(Rc::new(result)))
    });

    // pad_left - left-pad string to length with char (uses character count, not bytes)
    define(interp, "pad_left", Some(3), |_, args| {
        let s = match &args[0] {
            Value::String(s) => (**s).clone(),
            _ => {
                return Err(RuntimeError::new(
                    "pad_left: first argument must be a string",
                ))
            }
        };
        let width = match &args[1] {
            Value::Int(n) if *n >= 0 => *n as usize,
            _ => {
                return Err(RuntimeError::new(
                    "pad_left: width must be a non-negative integer",
                ))
            }
        };
        let pad_char = match &args[2] {
            Value::String(s) if !s.is_empty() => s.chars().next().unwrap(),
            Value::Char(c) => *c,
            _ => {
                return Err(RuntimeError::new(
                    "pad_left: pad character must be a non-empty string or char",
                ))
            }
        };
        let char_count = s.chars().count();
        if char_count >= width {
            return Ok(Value::String(Rc::new(s)));
        }
        let padding: String = std::iter::repeat(pad_char)
            .take(width - char_count)
            .collect();
        Ok(Value::String(Rc::new(format!("{}{}", padding, s))))
    });

    // pad_right - right-pad string to length with char (uses character count, not bytes)
    define(interp, "pad_right", Some(3), |_, args| {
        let s = match &args[0] {
            Value::String(s) => (**s).clone(),
            _ => {
                return Err(RuntimeError::new(
                    "pad_right: first argument must be a string",
                ))
            }
        };
        let width = match &args[1] {
            Value::Int(n) if *n >= 0 => *n as usize,
            _ => {
                return Err(RuntimeError::new(
                    "pad_right: width must be a non-negative integer",
                ))
            }
        };
        let pad_char = match &args[2] {
            Value::String(s) if !s.is_empty() => s.chars().next().unwrap(),
            Value::Char(c) => *c,
            _ => {
                return Err(RuntimeError::new(
                    "pad_right: pad character must be a non-empty string or char",
                ))
            }
        };
        let char_count = s.chars().count();
        if char_count >= width {
            return Ok(Value::String(Rc::new(s)));
        }
        let padding: String = std::iter::repeat(pad_char)
            .take(width - char_count)
            .collect();
        Ok(Value::String(Rc::new(format!("{}{}", s, padding))))
    });

    // center - center string with padding (uses character count, not bytes)
    define(interp, "center", Some(3), |_, args| {
        let s = match &args[0] {
            Value::String(s) => (**s).clone(),
            _ => return Err(RuntimeError::new("center: first argument must be a string")),
        };
        let width = match &args[1] {
            Value::Int(n) if *n >= 0 => *n as usize,
            _ => {
                return Err(RuntimeError::new(
                    "center: width must be a non-negative integer",
                ))
            }
        };
        let pad_char = match &args[2] {
            Value::String(s) if !s.is_empty() => s.chars().next().unwrap(),
            Value::Char(c) => *c,
            _ => {
                return Err(RuntimeError::new(
                    "center: pad character must be a non-empty string or char",
                ))
            }
        };
        let char_count = s.chars().count();
        if char_count >= width {
            return Ok(Value::String(Rc::new(s)));
        }
        let total_padding = width - char_count;
        let left_padding = total_padding / 2;
        let right_padding = total_padding - left_padding;
        let left: String = std::iter::repeat(pad_char).take(left_padding).collect();
        let right: String = std::iter::repeat(pad_char).take(right_padding).collect();
        Ok(Value::String(Rc::new(format!("{}{}{}", left, s, right))))
    });

    // number_format - format number with thousand separators
    define(interp, "number_format", Some(1), |_, args| {
        let n = match &args[0] {
            Value::Int(n) => *n,
            Value::Float(f) => *f as i64,
            _ => {
                return Err(RuntimeError::new(
                    "number_format: argument must be a number",
                ))
            }
        };
        let s = n.abs().to_string();
        let mut result = String::new();
        for (i, c) in s.chars().rev().enumerate() {
            if i > 0 && i % 3 == 0 {
                result.push(',');
            }
            result.push(c);
        }
        let formatted: String = result.chars().rev().collect();
        if n < 0 {
            Ok(Value::String(Rc::new(format!("-{}", formatted))))
        } else {
            Ok(Value::String(Rc::new(formatted)))
        }
    });

    // ordinal - convert number to ordinal string (1st, 2nd, 3rd, etc)
    define(interp, "ordinal", Some(1), |_, args| {
        let n = match &args[0] {
            Value::Int(n) => *n,
            _ => return Err(RuntimeError::new("ordinal: argument must be an integer")),
        };
        let suffix = match (n % 10, n % 100) {
            (1, 11) => "th",
            (2, 12) => "th",
            (3, 13) => "th",
            (1, _) => "st",
            (2, _) => "nd",
            (3, _) => "rd",
            _ => "th",
        };
        Ok(Value::String(Rc::new(format!("{}{}", n, suffix))))
    });

    // pluralize - simple pluralization
    define(interp, "pluralize", Some(3), |_, args| {
        let count = match &args[0] {
            Value::Int(n) => *n,
            _ => {
                return Err(RuntimeError::new(
                    "pluralize: first argument must be an integer",
                ))
            }
        };
        let singular = match &args[1] {
            Value::String(s) => s.clone(),
            _ => {
                return Err(RuntimeError::new(
                    "pluralize: second argument must be a string",
                ))
            }
        };
        let plural = match &args[2] {
            Value::String(s) => s.clone(),
            _ => {
                return Err(RuntimeError::new(
                    "pluralize: third argument must be a string",
                ))
            }
        };
        if count == 1 || count == -1 {
            Ok(Value::String(singular))
        } else {
            Ok(Value::String(plural))
        }
    });

    // truncate - truncate string with ellipsis (uses character count, not bytes)
    define(interp, "truncate", Some(2), |_, args| {
        let s = match &args[0] {
            Value::String(s) => (**s).clone(),
            _ => {
                return Err(RuntimeError::new(
                    "truncate: first argument must be a string",
                ))
            }
        };
        let max_len = match &args[1] {
            Value::Int(n) if *n >= 0 => *n as usize,
            _ => {
                return Err(RuntimeError::new(
                    "truncate: max length must be a non-negative integer",
                ))
            }
        };
        let char_count = s.chars().count();
        if char_count <= max_len {
            return Ok(Value::String(Rc::new(s)));
        }
        if max_len <= 3 {
            return Ok(Value::String(Rc::new(s.chars().take(max_len).collect())));
        }
        let truncated: String = s.chars().take(max_len - 3).collect();
        Ok(Value::String(Rc::new(format!("{}...", truncated))))
    });

    // word_wrap - wrap text at specified width
    define(interp, "word_wrap", Some(2), |_, args| {
        let s = match &args[0] {
            Value::String(s) => (**s).clone(),
            _ => {
                return Err(RuntimeError::new(
                    "word_wrap: first argument must be a string",
                ))
            }
        };
        let width = match &args[1] {
            Value::Int(n) if *n > 0 => *n as usize,
            _ => {
                return Err(RuntimeError::new(
                    "word_wrap: width must be a positive integer",
                ))
            }
        };
        let mut result = String::new();
        let mut line_len = 0;
        for word in s.split_whitespace() {
            if line_len > 0 && line_len + 1 + word.len() > width {
                result.push('\n');
                line_len = 0;
            } else if line_len > 0 {
                result.push(' ');
                line_len += 1;
            }
            result.push_str(word);
            line_len += word.len();
        }
        Ok(Value::String(Rc::new(result)))
    });

    // snake_case - convert string to snake_case
    define(interp, "snake_case", Some(1), |_, args| {
        let s = match &args[0] {
            Value::String(s) => (**s).clone(),
            _ => return Err(RuntimeError::new("snake_case: argument must be a string")),
        };
        let mut result = String::new();
        for (i, c) in s.chars().enumerate() {
            if c.is_uppercase() {
                if i > 0 {
                    result.push('_');
                }
                result.push(c.to_lowercase().next().unwrap());
            } else if c == ' ' || c == '-' {
                result.push('_');
            } else {
                result.push(c);
            }
        }
        Ok(Value::String(Rc::new(result)))
    });

    // camel_case - convert string to camelCase
    define(interp, "camel_case", Some(1), |_, args| {
        let s = match &args[0] {
            Value::String(s) => (**s).clone(),
            _ => return Err(RuntimeError::new("camel_case: argument must be a string")),
        };
        let mut result = String::new();
        let mut capitalize_next = false;
        for (i, c) in s.chars().enumerate() {
            if c == '_' || c == '-' || c == ' ' {
                capitalize_next = true;
            } else if capitalize_next {
                result.push(c.to_uppercase().next().unwrap());
                capitalize_next = false;
            } else if i == 0 {
                result.push(c.to_lowercase().next().unwrap());
            } else {
                result.push(c);
            }
        }
        Ok(Value::String(Rc::new(result)))
    });

    // kebab_case - convert string to kebab-case
    define(interp, "kebab_case", Some(1), |_, args| {
        let s = match &args[0] {
            Value::String(s) => (**s).clone(),
            _ => return Err(RuntimeError::new("kebab_case: argument must be a string")),
        };
        let mut result = String::new();
        for (i, c) in s.chars().enumerate() {
            if c.is_uppercase() {
                if i > 0 {
                    result.push('-');
                }
                result.push(c.to_lowercase().next().unwrap());
            } else if c == '_' || c == ' ' {
                result.push('-');
            } else {
                result.push(c);
            }
        }
        Ok(Value::String(Rc::new(result)))
    });

    // title_case - convert string to Title Case
    define(interp, "title_case", Some(1), |_, args| {
        let s = match &args[0] {
            Value::String(s) => (**s).clone(),
            _ => return Err(RuntimeError::new("title_case: argument must be a string")),
        };
        let result: String = s
            .split_whitespace()
            .map(|word| {
                let mut chars = word.chars();
                match chars.next() {
                    None => String::new(),
                    Some(first) => {
                        first.to_uppercase().collect::<String>() + &chars.as_str().to_lowercase()
                    }
                }
            })
            .collect::<Vec<_>>()
            .join(" ");
        Ok(Value::String(Rc::new(result)))
    });
}

// ============================================================================
// PATTERN MATCHING FUNCTIONS (Phase 6)
// ============================================================================
// Advanced pattern matching utilities for expressive data manipulation.
// These complement Sigil's match expressions with functional alternatives.
// ============================================================================

fn register_pattern(interp: &mut Interpreter) {
    // --- TYPE MATCHING ---

    // type_of - get the type name as a string
    define(interp, "type_of", Some(1), |_, args| {
        let type_name = match &args[0] {
            Value::Null => "null",
            Value::Bool(_) => "bool",
            Value::Int(_) => "int",
            Value::Float(_) => "float",
            Value::String(_) => "string",
            Value::Char(_) => "char",
            Value::Array(_) => "array",
            Value::Tuple(_) => "tuple",
            Value::Map(_) => "map",
            Value::Set(_) => "set",
            Value::Struct { name, .. } => {
                return Ok(Value::String(Rc::new(format!("struct:{}", name))))
            }
            Value::Variant {
                enum_name,
                variant_name,
                ..
            } => {
                return Ok(Value::String(Rc::new(format!(
                    "{}::{}",
                    enum_name, variant_name
                ))))
            }
            Value::Function(_) => "function",
            Value::BuiltIn(_) => "builtin",
            Value::Ref(_) => "ref",
            Value::Infinity => "infinity",
            Value::Empty => "empty",
            Value::Evidential { .. } => "evidential",
            Value::Affective { .. } => "affective",
            Value::Channel(_) => "channel",
            Value::ThreadHandle(_) => "thread",
            Value::Actor(_) => "actor",
            Value::Future(_) => "future",
        };
        Ok(Value::String(Rc::new(type_name.to_string())))
    });

    // is_type - check if value matches type name
    define(interp, "is_type", Some(2), |_, args| {
        let type_name = match &args[1] {
            Value::String(s) => s.to_lowercase(),
            _ => {
                return Err(RuntimeError::new(
                    "is_type: second argument must be type name string",
                ))
            }
        };
        let matches = match (&args[0], type_name.as_str()) {
            (Value::Null, "null") => true,
            (Value::Bool(_), "bool") => true,
            (Value::Int(_), "int") | (Value::Int(_), "integer") => true,
            (Value::Float(_), "float") | (Value::Float(_), "number") => true,
            (Value::Int(_), "number") => true,
            (Value::String(_), "string") => true,
            (Value::Array(_), "array") | (Value::Array(_), "list") => true,
            (Value::Tuple(_), "tuple") => true,
            (Value::Map(_), "map") | (Value::Map(_), "dict") | (Value::Map(_), "object") => true,
            (Value::Set(_), "set") => true,
            (Value::Function(_), "function") | (Value::Function(_), "fn") => true,
            (Value::BuiltIn(_), "function") | (Value::BuiltIn(_), "builtin") => true,
            (Value::Struct { name, .. }, t) => t == "struct" || t == &name.to_lowercase(),
            (Value::Variant { enum_name, .. }, t) => {
                t == "variant" || t == "enum" || t == &enum_name.to_lowercase()
            }
            (Value::Channel(_), "channel") => true,
            (Value::ThreadHandle(_), "thread") => true,
            (Value::Actor(_), "actor") => true,
            (Value::Future(_), "future") => true,
            _ => false,
        };
        Ok(Value::Bool(matches))
    });

    // is_null, is_bool, is_int, is_float, is_string, is_array, is_map - type predicates
    define(interp, "is_null", Some(1), |_, args| {
        Ok(Value::Bool(matches!(&args[0], Value::Null)))
    });
    define(interp, "is_bool", Some(1), |_, args| {
        Ok(Value::Bool(matches!(&args[0], Value::Bool(_))))
    });
    define(interp, "is_int", Some(1), |_, args| {
        Ok(Value::Bool(matches!(&args[0], Value::Int(_))))
    });
    define(interp, "is_float", Some(1), |_, args| {
        Ok(Value::Bool(matches!(&args[0], Value::Float(_))))
    });
    define(interp, "is_number", Some(1), |_, args| {
        Ok(Value::Bool(matches!(
            &args[0],
            Value::Int(_) | Value::Float(_)
        )))
    });
    define(interp, "is_string", Some(1), |_, args| {
        Ok(Value::Bool(matches!(&args[0], Value::String(_))))
    });
    define(interp, "is_array", Some(1), |_, args| {
        Ok(Value::Bool(matches!(&args[0], Value::Array(_))))
    });
    define(interp, "is_tuple", Some(1), |_, args| {
        Ok(Value::Bool(matches!(&args[0], Value::Tuple(_))))
    });
    define(interp, "is_map", Some(1), |_, args| {
        Ok(Value::Bool(matches!(&args[0], Value::Map(_))))
    });
    define(interp, "is_set", Some(1), |_, args| {
        Ok(Value::Bool(matches!(&args[0], Value::Set(_))))
    });
    define(interp, "is_function", Some(1), |_, args| {
        Ok(Value::Bool(matches!(
            &args[0],
            Value::Function(_) | Value::BuiltIn(_)
        )))
    });
    define(interp, "is_struct", Some(1), |_, args| {
        Ok(Value::Bool(matches!(&args[0], Value::Struct { .. })))
    });
    define(interp, "is_variant", Some(1), |_, args| {
        Ok(Value::Bool(matches!(&args[0], Value::Variant { .. })))
    });
    define(interp, "is_future", Some(1), |_, args| {
        Ok(Value::Bool(matches!(&args[0], Value::Future(_))))
    });
    define(interp, "is_channel", Some(1), |_, args| {
        Ok(Value::Bool(matches!(&args[0], Value::Channel(_))))
    });

    // is_empty - check if collection is empty
    define(interp, "is_empty", Some(1), |_, args| {
        let empty = match &args[0] {
            Value::Null => true,
            Value::String(s) => s.is_empty(),
            Value::Array(a) => a.borrow().is_empty(),
            Value::Tuple(t) => t.is_empty(),
            Value::Map(m) => m.borrow().is_empty(),
            Value::Set(s) => s.borrow().is_empty(),
            _ => false,
        };
        Ok(Value::Bool(empty))
    });

    // --- REGEX PATTERN MATCHING ---

    // match_regex - match string against regex, return captures or null
    define(interp, "match_regex", Some(2), |_, args| {
        let text = match &args[0] {
            Value::String(s) => (**s).clone(),
            _ => {
                return Err(RuntimeError::new(
                    "match_regex: first argument must be a string",
                ))
            }
        };
        let pattern = match &args[1] {
            Value::String(s) => (**s).clone(),
            _ => {
                return Err(RuntimeError::new(
                    "match_regex: second argument must be a regex pattern string",
                ))
            }
        };

        let re = match Regex::new(&pattern) {
            Ok(r) => r,
            Err(e) => {
                return Err(RuntimeError::new(format!(
                    "match_regex: invalid regex: {}",
                    e
                )))
            }
        };

        match re.captures(&text) {
            Some(caps) => {
                let mut captures: Vec<Value> = Vec::new();
                for i in 0..caps.len() {
                    if let Some(m) = caps.get(i) {
                        captures.push(Value::String(Rc::new(m.as_str().to_string())));
                    } else {
                        captures.push(Value::Null);
                    }
                }
                Ok(Value::Array(Rc::new(RefCell::new(captures))))
            }
            None => Ok(Value::Null),
        }
    });

    // match_all_regex - find all matches of regex in string
    define(interp, "match_all_regex", Some(2), |_, args| {
        let text = match &args[0] {
            Value::String(s) => (**s).clone(),
            _ => {
                return Err(RuntimeError::new(
                    "match_all_regex: first argument must be a string",
                ))
            }
        };
        let pattern = match &args[1] {
            Value::String(s) => (**s).clone(),
            _ => {
                return Err(RuntimeError::new(
                    "match_all_regex: second argument must be a regex pattern string",
                ))
            }
        };

        let re = match Regex::new(&pattern) {
            Ok(r) => r,
            Err(e) => {
                return Err(RuntimeError::new(format!(
                    "match_all_regex: invalid regex: {}",
                    e
                )))
            }
        };

        let matches: Vec<Value> = re
            .find_iter(&text)
            .map(|m| Value::String(Rc::new(m.as_str().to_string())))
            .collect();
        Ok(Value::Array(Rc::new(RefCell::new(matches))))
    });

    // capture_named - extract named captures from regex match
    define(interp, "capture_named", Some(2), |_, args| {
        let text = match &args[0] {
            Value::String(s) => (**s).clone(),
            _ => {
                return Err(RuntimeError::new(
                    "capture_named: first argument must be a string",
                ))
            }
        };
        let pattern = match &args[1] {
            Value::String(s) => (**s).clone(),
            _ => {
                return Err(RuntimeError::new(
                    "capture_named: second argument must be a regex pattern string",
                ))
            }
        };

        let re = match Regex::new(&pattern) {
            Ok(r) => r,
            Err(e) => {
                return Err(RuntimeError::new(format!(
                    "capture_named: invalid regex: {}",
                    e
                )))
            }
        };

        match re.captures(&text) {
            Some(caps) => {
                let mut result: HashMap<String, Value> = HashMap::new();
                for name in re.capture_names().flatten() {
                    if let Some(m) = caps.name(name) {
                        result.insert(
                            name.to_string(),
                            Value::String(Rc::new(m.as_str().to_string())),
                        );
                    }
                }
                Ok(Value::Map(Rc::new(RefCell::new(result))))
            }
            None => Ok(Value::Null),
        }
    });

    // --- STRUCTURAL PATTERN MATCHING ---

    // match_struct - check if value is a struct with given name
    define(interp, "match_struct", Some(2), |_, args| {
        let expected_name = match &args[1] {
            Value::String(s) => (**s).clone(),
            _ => {
                return Err(RuntimeError::new(
                    "match_struct: second argument must be struct name string",
                ))
            }
        };
        match &args[0] {
            Value::Struct { name, .. } => Ok(Value::Bool(name == &expected_name)),
            _ => Ok(Value::Bool(false)),
        }
    });

    // match_variant - check if value is a variant with given enum and variant name
    define(interp, "match_variant", Some(3), |_, args| {
        let expected_enum = match &args[1] {
            Value::String(s) => (**s).clone(),
            _ => {
                return Err(RuntimeError::new(
                    "match_variant: second argument must be enum name string",
                ))
            }
        };
        let expected_variant = match &args[2] {
            Value::String(s) => (**s).clone(),
            _ => {
                return Err(RuntimeError::new(
                    "match_variant: third argument must be variant name string",
                ))
            }
        };
        match &args[0] {
            Value::Variant {
                enum_name,
                variant_name,
                ..
            } => Ok(Value::Bool(
                enum_name == &expected_enum && variant_name == &expected_variant,
            )),
            _ => Ok(Value::Bool(false)),
        }
    });

    // get_field - get field from struct by name (returns null if not found)
    define(interp, "get_field", Some(2), |_, args| {
        let field_name = match &args[1] {
            Value::String(s) => (**s).clone(),
            _ => {
                return Err(RuntimeError::new(
                    "get_field: second argument must be field name string",
                ))
            }
        };
        match &args[0] {
            Value::Struct { fields, .. } => Ok(fields
                .borrow()
                .get(&field_name)
                .cloned()
                .unwrap_or(Value::Null)),
            Value::Map(m) => Ok(m.borrow().get(&field_name).cloned().unwrap_or(Value::Null)),
            _ => Ok(Value::Null),
        }
    });

    // has_field - check if struct/map has a field
    define(interp, "has_field", Some(2), |_, args| {
        let field_name = match &args[1] {
            Value::String(s) => (**s).clone(),
            _ => {
                return Err(RuntimeError::new(
                    "has_field: second argument must be field name string",
                ))
            }
        };
        match &args[0] {
            Value::Struct { fields, .. } => {
                Ok(Value::Bool(fields.borrow().contains_key(&field_name)))
            }
            Value::Map(m) => Ok(Value::Bool(m.borrow().contains_key(&field_name))),
            _ => Ok(Value::Bool(false)),
        }
    });

    // get_fields - get all field names from struct/map
    define(interp, "get_fields", Some(1), |_, args| {
        let fields: Vec<Value> = match &args[0] {
            Value::Struct { fields, .. } => fields
                .borrow()
                .keys()
                .map(|k| Value::String(Rc::new(k.clone())))
                .collect(),
            Value::Map(m) => m
                .borrow()
                .keys()
                .map(|k| Value::String(Rc::new(k.clone())))
                .collect(),
            _ => {
                return Err(RuntimeError::new(
                    "get_fields: argument must be struct or map",
                ))
            }
        };
        Ok(Value::Array(Rc::new(RefCell::new(fields))))
    });

    // struct_name - get the name of a struct
    define(interp, "struct_name", Some(1), |_, args| match &args[0] {
        Value::Struct { name, .. } => Ok(Value::String(Rc::new(name.clone()))),
        _ => Ok(Value::Null),
    });

    // variant_name - get the variant name of an enum value
    define(interp, "variant_name", Some(1), |_, args| match &args[0] {
        Value::Variant { variant_name, .. } => Ok(Value::String(Rc::new(variant_name.clone()))),
        _ => Ok(Value::Null),
    });

    // variant_data - get the data payload of a variant
    define(interp, "variant_data", Some(1), |_, args| match &args[0] {
        Value::Variant { fields, .. } => match fields {
            Some(f) => Ok(Value::Array(Rc::new(RefCell::new((**f).clone())))),
            None => Ok(Value::Null),
        },
        _ => Ok(Value::Null),
    });

    // --- GUARDS AND CONDITIONALS ---

    // guard - conditionally return value or null (for pattern guard chains)
    define(interp, "guard", Some(2), |_, args| {
        if is_truthy(&args[0]) {
            Ok(args[1].clone())
        } else {
            Ok(Value::Null)
        }
    });

    // when - like guard but evaluates a function if condition is true
    define(interp, "when", Some(2), |interp, args| {
        if is_truthy(&args[0]) {
            match &args[1] {
                Value::Function(f) => interp.call_function(f, vec![]),
                other => Ok(other.clone()),
            }
        } else {
            Ok(Value::Null)
        }
    });

    // unless - opposite of when
    define(interp, "unless", Some(2), |interp, args| {
        if !is_truthy(&args[0]) {
            match &args[1] {
                Value::Function(f) => interp.call_function(f, vec![]),
                other => Ok(other.clone()),
            }
        } else {
            Ok(Value::Null)
        }
    });

    // cond - evaluate conditions in order, return first matching result
    // cond([[cond1, val1], [cond2, val2], ...])
    define(interp, "cond", Some(1), |interp, args| {
        let clauses = match &args[0] {
            Value::Array(a) => a.borrow().clone(),
            _ => {
                return Err(RuntimeError::new(
                    "cond: argument must be array of [condition, value] pairs",
                ))
            }
        };

        for clause in clauses {
            let pair = match &clause {
                Value::Array(a) => a.borrow().clone(),
                Value::Tuple(t) => (**t).clone(),
                _ => {
                    return Err(RuntimeError::new(
                        "cond: each clause must be [condition, value] pair",
                    ))
                }
            };
            if pair.len() != 2 {
                return Err(RuntimeError::new(
                    "cond: each clause must have exactly 2 elements",
                ));
            }

            if is_truthy(&pair[0]) {
                return match &pair[1] {
                    Value::Function(f) => interp.call_function(f, vec![]),
                    other => Ok(other.clone()),
                };
            }
        }
        Ok(Value::Null)
    });

    // case - match value against patterns, return matching result
    // case(val, [[pattern1, result1], [pattern2, result2], ...])
    define(interp, "case", Some(2), |interp, args| {
        let value = &args[0];
        let clauses = match &args[1] {
            Value::Array(a) => a.borrow().clone(),
            _ => {
                return Err(RuntimeError::new(
                    "case: second argument must be array of [pattern, result] pairs",
                ))
            }
        };

        for clause in clauses {
            let pair = match &clause {
                Value::Array(a) => a.borrow().clone(),
                Value::Tuple(t) => (**t).clone(),
                _ => {
                    return Err(RuntimeError::new(
                        "case: each clause must be [pattern, result] pair",
                    ))
                }
            };
            if pair.len() != 2 {
                return Err(RuntimeError::new(
                    "case: each clause must have exactly 2 elements",
                ));
            }

            if value_eq(value, &pair[0]) {
                return match &pair[1] {
                    Value::Function(f) => interp.call_function(f, vec![value.clone()]),
                    other => Ok(other.clone()),
                };
            }
        }
        Ok(Value::Null)
    });

    // --- DESTRUCTURING ---

    // destructure_array - extract elements at specified indices
    define(interp, "destructure_array", Some(2), |_, args| {
        let arr = match &args[0] {
            Value::Array(a) => a.borrow().clone(),
            Value::Tuple(t) => (**t).clone(),
            _ => {
                return Err(RuntimeError::new(
                    "destructure_array: first argument must be array or tuple",
                ))
            }
        };
        let indices = match &args[1] {
            Value::Array(a) => a.borrow().clone(),
            _ => {
                return Err(RuntimeError::new(
                    "destructure_array: second argument must be array of indices",
                ))
            }
        };

        let mut result = Vec::new();
        for idx in indices {
            match idx {
                Value::Int(i) => {
                    let i = if i < 0 { arr.len() as i64 + i } else { i } as usize;
                    result.push(arr.get(i).cloned().unwrap_or(Value::Null));
                }
                _ => result.push(Value::Null),
            }
        }
        Ok(Value::Array(Rc::new(RefCell::new(result))))
    });

    // destructure_map - extract values for specified keys
    define(interp, "destructure_map", Some(2), |_, args| {
        let map = match &args[0] {
            Value::Map(m) => m.borrow().clone(),
            Value::Struct { fields, .. } => fields.borrow().clone(),
            _ => {
                return Err(RuntimeError::new(
                    "destructure_map: first argument must be map or struct",
                ))
            }
        };
        let keys = match &args[1] {
            Value::Array(a) => a.borrow().clone(),
            _ => {
                return Err(RuntimeError::new(
                    "destructure_map: second argument must be array of keys",
                ))
            }
        };

        let mut result = Vec::new();
        for key in keys {
            match key {
                Value::String(k) => {
                    result.push(map.get(&*k).cloned().unwrap_or(Value::Null));
                }
                _ => result.push(Value::Null),
            }
        }
        Ok(Value::Array(Rc::new(RefCell::new(result))))
    });

    // head_tail - split array into [head, tail]
    define(interp, "head_tail", Some(1), |_, args| {
        let arr = match &args[0] {
            Value::Array(a) => a.borrow().clone(),
            _ => return Err(RuntimeError::new("head_tail: argument must be array")),
        };

        if arr.is_empty() {
            Ok(Value::Tuple(Rc::new(vec![
                Value::Null,
                Value::Array(Rc::new(RefCell::new(vec![]))),
            ])))
        } else {
            let head = arr[0].clone();
            let tail = arr[1..].to_vec();
            Ok(Value::Tuple(Rc::new(vec![
                head,
                Value::Array(Rc::new(RefCell::new(tail))),
            ])))
        }
    });

    // init_last - split array into [init, last]
    define(interp, "init_last", Some(1), |_, args| {
        let arr = match &args[0] {
            Value::Array(a) => a.borrow().clone(),
            _ => return Err(RuntimeError::new("init_last: argument must be array")),
        };

        if arr.is_empty() {
            Ok(Value::Tuple(Rc::new(vec![
                Value::Array(Rc::new(RefCell::new(vec![]))),
                Value::Null,
            ])))
        } else {
            let last = arr[arr.len() - 1].clone();
            let init = arr[..arr.len() - 1].to_vec();
            Ok(Value::Tuple(Rc::new(vec![
                Value::Array(Rc::new(RefCell::new(init))),
                last,
            ])))
        }
    });

    // split_at - split array at index into [left, right]
    define(interp, "split_at", Some(2), |_, args| {
        let arr = match &args[0] {
            Value::Array(a) => a.borrow().clone(),
            _ => return Err(RuntimeError::new("split_at: first argument must be array")),
        };
        let idx = match &args[1] {
            Value::Int(i) => *i as usize,
            _ => {
                return Err(RuntimeError::new(
                    "split_at: second argument must be integer",
                ))
            }
        };

        let idx = idx.min(arr.len());
        let left = arr[..idx].to_vec();
        let right = arr[idx..].to_vec();
        Ok(Value::Tuple(Rc::new(vec![
            Value::Array(Rc::new(RefCell::new(left))),
            Value::Array(Rc::new(RefCell::new(right))),
        ])))
    });

    // --- OPTIONAL/NULLABLE HELPERS ---

    // unwrap_or - return value if not null, else default
    define(interp, "unwrap_or", Some(2), |_, args| {
        if matches!(&args[0], Value::Null) {
            Ok(args[1].clone())
        } else {
            Ok(args[0].clone())
        }
    });

    // unwrap_or_else - return value if not null, else call function
    define(interp, "unwrap_or_else", Some(2), |interp, args| {
        if matches!(&args[0], Value::Null) {
            match &args[1] {
                Value::Function(f) => interp.call_function(f, vec![]),
                other => Ok(other.clone()),
            }
        } else {
            Ok(args[0].clone())
        }
    });

    // map_or - if value is not null, apply function, else return default
    define(interp, "map_or", Some(3), |interp, args| {
        if matches!(&args[0], Value::Null) {
            Ok(args[1].clone())
        } else {
            match &args[2] {
                Value::Function(f) => interp.call_function(f, vec![args[0].clone()]),
                _ => Err(RuntimeError::new(
                    "map_or: third argument must be a function",
                )),
            }
        }
    });

    // coalesce - return first non-null value from array
    define(interp, "coalesce", Some(1), |_, args| {
        let values = match &args[0] {
            Value::Array(a) => a.borrow().clone(),
            _ => return Err(RuntimeError::new("coalesce: argument must be array")),
        };

        for v in values {
            if !matches!(v, Value::Null) {
                return Ok(v);
            }
        }
        Ok(Value::Null)
    });

    // --- EQUALITY AND COMPARISON ---

    // deep_eq - deep structural equality check
    define(interp, "deep_eq", Some(2), |_, args| {
        Ok(Value::Bool(deep_value_eq(&args[0], &args[1])))
    });

    // same_type - check if two values have the same type
    define(interp, "same_type", Some(2), |_, args| {
        let same = match (&args[0], &args[1]) {
            (Value::Null, Value::Null) => true,
            (Value::Bool(_), Value::Bool(_)) => true,
            (Value::Int(_), Value::Int(_)) => true,
            (Value::Float(_), Value::Float(_)) => true,
            (Value::String(_), Value::String(_)) => true,
            (Value::Array(_), Value::Array(_)) => true,
            (Value::Tuple(_), Value::Tuple(_)) => true,
            (Value::Map(_), Value::Map(_)) => true,
            (Value::Set(_), Value::Set(_)) => true,
            (Value::Function(_), Value::Function(_)) => true,
            (Value::BuiltIn(_), Value::BuiltIn(_)) => true,
            (Value::Struct { name: n1, .. }, Value::Struct { name: n2, .. }) => n1 == n2,
            (Value::Variant { enum_name: e1, .. }, Value::Variant { enum_name: e2, .. }) => {
                e1 == e2
            }
            _ => false,
        };
        Ok(Value::Bool(same))
    });

    // compare - three-way comparison: -1, 0, or 1
    define(interp, "compare", Some(2), |_, args| {
        let cmp = match (&args[0], &args[1]) {
            (Value::Int(a), Value::Int(b)) => a.cmp(b),
            (Value::Float(a), Value::Float(b)) => {
                a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal)
            }
            (Value::Int(a), Value::Float(b)) => (*a as f64)
                .partial_cmp(b)
                .unwrap_or(std::cmp::Ordering::Equal),
            (Value::Float(a), Value::Int(b)) => a
                .partial_cmp(&(*b as f64))
                .unwrap_or(std::cmp::Ordering::Equal),
            (Value::String(a), Value::String(b)) => a.cmp(b),
            _ => {
                return Err(RuntimeError::new(
                    "compare: can only compare numbers or strings",
                ))
            }
        };
        Ok(Value::Int(match cmp {
            std::cmp::Ordering::Less => -1,
            std::cmp::Ordering::Equal => 0,
            std::cmp::Ordering::Greater => 1,
        }))
    });

    // between - check if value is between min and max (inclusive)
    define(interp, "between", Some(3), |_, args| {
        let in_range = match (&args[0], &args[1], &args[2]) {
            (Value::Int(v), Value::Int(min), Value::Int(max)) => v >= min && v <= max,
            (Value::Float(v), Value::Float(min), Value::Float(max)) => v >= min && v <= max,
            (Value::Int(v), Value::Int(min), Value::Float(max)) => {
                (*v as f64) >= (*min as f64) && (*v as f64) <= *max
            }
            (Value::Int(v), Value::Float(min), Value::Int(max)) => {
                (*v as f64) >= *min && (*v as f64) <= (*max as f64)
            }
            (Value::Float(v), Value::Int(min), Value::Int(max)) => {
                *v >= (*min as f64) && *v <= (*max as f64)
            }
            (Value::String(v), Value::String(min), Value::String(max)) => v >= min && v <= max,
            _ => {
                return Err(RuntimeError::new(
                    "between: arguments must be comparable (numbers or strings)",
                ))
            }
        };
        Ok(Value::Bool(in_range))
    });

    // clamp - constrain value to range
    define(interp, "clamp", Some(3), |_, args| {
        match (&args[0], &args[1], &args[2]) {
            (Value::Int(v), Value::Int(min), Value::Int(max)) => {
                Ok(Value::Int((*v).max(*min).min(*max)))
            }
            (Value::Float(v), Value::Float(min), Value::Float(max)) => {
                Ok(Value::Float(v.max(*min).min(*max)))
            }
            (Value::Int(v), Value::Int(min), Value::Float(max)) => {
                Ok(Value::Float((*v as f64).max(*min as f64).min(*max)))
            }
            _ => Err(RuntimeError::new("clamp: arguments must be numbers")),
        }
    });
}

// Deep value equality for nested structures
fn deep_value_eq(a: &Value, b: &Value) -> bool {
    match (a, b) {
        (Value::Null, Value::Null) => true,
        (Value::Bool(a), Value::Bool(b)) => a == b,
        (Value::Int(a), Value::Int(b)) => a == b,
        (Value::Float(a), Value::Float(b)) => (a - b).abs() < f64::EPSILON,
        (Value::Int(a), Value::Float(b)) | (Value::Float(b), Value::Int(a)) => {
            (*a as f64 - b).abs() < f64::EPSILON
        }
        (Value::String(a), Value::String(b)) => a == b,
        (Value::Array(a), Value::Array(b)) => {
            let a = a.borrow();
            let b = b.borrow();
            a.len() == b.len() && a.iter().zip(b.iter()).all(|(x, y)| deep_value_eq(x, y))
        }
        (Value::Tuple(a), Value::Tuple(b)) => {
            a.len() == b.len() && a.iter().zip(b.iter()).all(|(x, y)| deep_value_eq(x, y))
        }
        (Value::Map(a), Value::Map(b)) => {
            let a = a.borrow();
            let b = b.borrow();
            a.len() == b.len()
                && a.iter()
                    .all(|(k, v)| b.get(k).map_or(false, |bv| deep_value_eq(v, bv)))
        }
        (Value::Set(a), Value::Set(b)) => {
            let a = a.borrow();
            let b = b.borrow();
            a.len() == b.len() && a.iter().all(|k| b.contains(k))
        }
        (
            Value::Struct {
                name: n1,
                fields: f1,
            },
            Value::Struct {
                name: n2,
                fields: f2,
            },
        ) => {
            let f1 = f1.borrow();
            let f2 = f2.borrow();
            n1 == n2
                && f1.len() == f2.len()
                && f1
                    .iter()
                    .all(|(k, v)| f2.get(k).map_or(false, |v2| deep_value_eq(v, v2)))
        }
        (
            Value::Variant {
                enum_name: e1,
                variant_name: v1,
                fields: d1,
            },
            Value::Variant {
                enum_name: e2,
                variant_name: v2,
                fields: d2,
            },
        ) => {
            if e1 != e2 || v1 != v2 {
                return false;
            }
            match (d1, d2) {
                (Some(f1), Some(f2)) => {
                    f1.len() == f2.len()
                        && f1.iter().zip(f2.iter()).all(|(x, y)| deep_value_eq(x, y))
                }
                (None, None) => true,
                _ => false,
            }
        }
        _ => false,
    }
}

// Helper for value equality comparison
fn value_eq(a: &Value, b: &Value) -> bool {
    match (a, b) {
        (Value::Null, Value::Null) => true,
        (Value::Bool(a), Value::Bool(b)) => a == b,
        (Value::Int(a), Value::Int(b)) => a == b,
        (Value::Float(a), Value::Float(b)) => (a - b).abs() < f64::EPSILON,
        (Value::String(a), Value::String(b)) => a == b,
        (Value::Int(a), Value::Float(b)) | (Value::Float(b), Value::Int(a)) => {
            (*a as f64 - b).abs() < f64::EPSILON
        }
        _ => false,
    }
}

// ============================================================================
// DEVEX FUNCTIONS (Phase 7)
// ============================================================================
// Developer experience enhancements: debugging, assertions, profiling,
// documentation, and introspection utilities.
// ============================================================================

fn register_devex(interp: &mut Interpreter) {
    // --- DEBUGGING AND INTROSPECTION ---

    // debug - print value with type info for debugging
    define(interp, "debug", Some(1), |_, args| {
        let type_name = match &args[0] {
            Value::Null => "null".to_string(),
            Value::Bool(_) => "bool".to_string(),
            Value::Int(_) => "int".to_string(),
            Value::Float(_) => "float".to_string(),
            Value::String(_) => "string".to_string(),
            Value::Char(_) => "char".to_string(),
            Value::Array(a) => format!("array[{}]", a.borrow().len()),
            Value::Tuple(t) => format!("tuple[{}]", t.len()),
            Value::Map(m) => format!("map[{}]", m.borrow().len()),
            Value::Set(s) => format!("set[{}]", s.borrow().len()),
            Value::Struct { name, fields } => format!("struct {}[{}]", name, fields.borrow().len()),
            Value::Variant {
                enum_name,
                variant_name,
                ..
            } => format!("{}::{}", enum_name, variant_name),
            Value::Function(_) => "function".to_string(),
            Value::BuiltIn(_) => "builtin".to_string(),
            Value::Ref(_) => "ref".to_string(),
            Value::Infinity => "infinity".to_string(),
            Value::Empty => "empty".to_string(),
            Value::Evidential { evidence, .. } => format!("evidential[{:?}]", evidence),
            Value::Affective { affect, .. } => format!("affective[sarcasm={}]", affect.sarcasm),
            Value::Channel(_) => "channel".to_string(),
            Value::ThreadHandle(_) => "thread".to_string(),
            Value::Actor(_) => "actor".to_string(),
            Value::Future(_) => "future".to_string(),
        };
        let value_repr = format_value_debug(&args[0]);
        println!("[DEBUG] {}: {}", type_name, value_repr);
        Ok(args[0].clone())
    });

    // inspect - return detailed string representation of value
    define(interp, "inspect", Some(1), |_, args| {
        Ok(Value::String(Rc::new(format_value_debug(&args[0]))))
    });

    // dbg - print and return value (tap for debugging)
    define(interp, "dbg", Some(1), |_, args| {
        println!("{}", format_value_debug(&args[0]));
        Ok(args[0].clone())
    });

    // trace - print message and value, return value
    define(interp, "trace", Some(2), |_, args| {
        let label = match &args[0] {
            Value::String(s) => (**s).clone(),
            _ => format_value_debug(&args[0]),
        };
        println!("[TRACE] {}: {}", label, format_value_debug(&args[1]));
        Ok(args[1].clone())
    });

    // pp - pretty print with indentation
    define(interp, "pp", Some(1), |_, args| {
        println!("{}", pretty_print_value(&args[0], 0));
        Ok(Value::Null)
    });

    // --- RICH ASSERTIONS ---

    // assert_eq - assert two values are equal
    define(interp, "assert_eq", Some(2), |_, args| {
        if deep_value_eq(&args[0], &args[1]) {
            Ok(Value::Bool(true))
        } else {
            Err(RuntimeError::new(format!(
                "Assertion failed: expected {} to equal {}",
                format_value_debug(&args[0]),
                format_value_debug(&args[1])
            )))
        }
    });

    // assert_ne - assert two values are not equal
    define(interp, "assert_ne", Some(2), |_, args| {
        if !deep_value_eq(&args[0], &args[1]) {
            Ok(Value::Bool(true))
        } else {
            Err(RuntimeError::new(format!(
                "Assertion failed: expected {} to not equal {}",
                format_value_debug(&args[0]),
                format_value_debug(&args[1])
            )))
        }
    });

    // assert_lt - assert first value is less than second
    define(interp, "assert_lt", Some(2), |_, args| {
        let cmp = devex_compare(&args[0], &args[1])?;
        if cmp < 0 {
            Ok(Value::Bool(true))
        } else {
            Err(RuntimeError::new(format!(
                "Assertion failed: expected {} < {}",
                format_value_debug(&args[0]),
                format_value_debug(&args[1])
            )))
        }
    });

    // assert_le - assert first value is less than or equal to second
    define(interp, "assert_le", Some(2), |_, args| {
        let cmp = devex_compare(&args[0], &args[1])?;
        if cmp <= 0 {
            Ok(Value::Bool(true))
        } else {
            Err(RuntimeError::new(format!(
                "Assertion failed: expected {} <= {}",
                format_value_debug(&args[0]),
                format_value_debug(&args[1])
            )))
        }
    });

    // assert_gt - assert first value is greater than second
    define(interp, "assert_gt", Some(2), |_, args| {
        let cmp = devex_compare(&args[0], &args[1])?;
        if cmp > 0 {
            Ok(Value::Bool(true))
        } else {
            Err(RuntimeError::new(format!(
                "Assertion failed: expected {} > {}",
                format_value_debug(&args[0]),
                format_value_debug(&args[1])
            )))
        }
    });

    // assert_ge - assert first value is greater than or equal to second
    define(interp, "assert_ge", Some(2), |_, args| {
        let cmp = devex_compare(&args[0], &args[1])?;
        if cmp >= 0 {
            Ok(Value::Bool(true))
        } else {
            Err(RuntimeError::new(format!(
                "Assertion failed: expected {} >= {}",
                format_value_debug(&args[0]),
                format_value_debug(&args[1])
            )))
        }
    });

    // assert_true - assert value is truthy
    define(interp, "assert_true", Some(1), |_, args| {
        if is_truthy(&args[0]) {
            Ok(Value::Bool(true))
        } else {
            Err(RuntimeError::new(format!(
                "Assertion failed: expected {} to be truthy",
                format_value_debug(&args[0])
            )))
        }
    });

    // assert_false - assert value is falsy
    define(interp, "assert_false", Some(1), |_, args| {
        if !is_truthy(&args[0]) {
            Ok(Value::Bool(true))
        } else {
            Err(RuntimeError::new(format!(
                "Assertion failed: expected {} to be falsy",
                format_value_debug(&args[0])
            )))
        }
    });

    // assert_null - assert value is null
    define(interp, "assert_null", Some(1), |_, args| {
        if matches!(&args[0], Value::Null) {
            Ok(Value::Bool(true))
        } else {
            Err(RuntimeError::new(format!(
                "Assertion failed: expected null, got {}",
                format_value_debug(&args[0])
            )))
        }
    });

    // assert_not_null - assert value is not null
    define(interp, "assert_not_null", Some(1), |_, args| {
        if !matches!(&args[0], Value::Null) {
            Ok(Value::Bool(true))
        } else {
            Err(RuntimeError::new(
                "Assertion failed: expected non-null value, got null",
            ))
        }
    });

    // assert_type - assert value has expected type
    define(interp, "assert_type", Some(2), |_, args| {
        let expected = match &args[1] {
            Value::String(s) => s.to_lowercase(),
            _ => {
                return Err(RuntimeError::new(
                    "assert_type: second argument must be type name string",
                ))
            }
        };
        let actual = get_type_name(&args[0]).to_lowercase();
        if actual == expected || matches_type_alias(&args[0], &expected) {
            Ok(Value::Bool(true))
        } else {
            Err(RuntimeError::new(format!(
                "Assertion failed: expected type '{}', got '{}'",
                expected, actual
            )))
        }
    });

    // assert_contains - assert collection contains value
    define(interp, "assert_contains", Some(2), |_, args| {
        let contains = match &args[0] {
            Value::Array(a) => a.borrow().iter().any(|v| deep_value_eq(v, &args[1])),
            Value::String(s) => {
                if let Value::String(sub) = &args[1] {
                    s.contains(&**sub)
                } else {
                    false
                }
            }
            Value::Map(m) => {
                if let Value::String(k) = &args[1] {
                    m.borrow().contains_key(&**k)
                } else {
                    false
                }
            }
            Value::Set(s) => {
                if let Value::String(k) = &args[1] {
                    s.borrow().contains(&**k)
                } else {
                    false
                }
            }
            _ => false,
        };
        if contains {
            Ok(Value::Bool(true))
        } else {
            Err(RuntimeError::new(format!(
                "Assertion failed: {} does not contain {}",
                format_value_debug(&args[0]),
                format_value_debug(&args[1])
            )))
        }
    });

    // assert_len - assert collection has expected length
    define(interp, "assert_len", Some(2), |_, args| {
        let expected = match &args[1] {
            Value::Int(n) => *n as usize,
            _ => {
                return Err(RuntimeError::new(
                    "assert_len: second argument must be integer",
                ))
            }
        };
        let actual = match &args[0] {
            Value::String(s) => s.len(),
            Value::Array(a) => a.borrow().len(),
            Value::Tuple(t) => t.len(),
            Value::Map(m) => m.borrow().len(),
            Value::Set(s) => s.borrow().len(),
            _ => {
                return Err(RuntimeError::new(
                    "assert_len: first argument must be a collection",
                ))
            }
        };
        if actual == expected {
            Ok(Value::Bool(true))
        } else {
            Err(RuntimeError::new(format!(
                "Assertion failed: expected length {}, got {}",
                expected, actual
            )))
        }
    });

    // assert_match - assert string matches regex
    define(interp, "assert_match", Some(2), |_, args| {
        let text = match &args[0] {
            Value::String(s) => (**s).clone(),
            _ => {
                return Err(RuntimeError::new(
                    "assert_match: first argument must be string",
                ))
            }
        };
        let pattern = match &args[1] {
            Value::String(s) => (**s).clone(),
            _ => {
                return Err(RuntimeError::new(
                    "assert_match: second argument must be regex pattern",
                ))
            }
        };
        let re =
            Regex::new(&pattern).map_err(|e| RuntimeError::new(format!("Invalid regex: {}", e)))?;
        if re.is_match(&text) {
            Ok(Value::Bool(true))
        } else {
            Err(RuntimeError::new(format!(
                "Assertion failed: '{}' does not match pattern '{}'",
                text, pattern
            )))
        }
    });

    // --- TESTING UTILITIES ---

    // test - run a test function and report result
    define(interp, "test", Some(2), |interp, args| {
        let name = match &args[0] {
            Value::String(s) => (**s).clone(),
            _ => {
                return Err(RuntimeError::new(
                    "test: first argument must be test name string",
                ))
            }
        };
        let func = match &args[1] {
            Value::Function(f) => f.clone(),
            _ => {
                return Err(RuntimeError::new(
                    "test: second argument must be test function",
                ))
            }
        };

        let start = Instant::now();
        let result = interp.call_function(&func, vec![]);
        let elapsed = start.elapsed();

        match result {
            Ok(_) => {
                println!("✓ {} ({:.2}ms)", name, elapsed.as_secs_f64() * 1000.0);
                Ok(Value::Bool(true))
            }
            Err(e) => {
                println!(
                    "✗ {} ({:.2}ms): {}",
                    name,
                    elapsed.as_secs_f64() * 1000.0,
                    e
                );
                Ok(Value::Bool(false))
            }
        }
    });

    // skip - mark a test as skipped
    define(interp, "skip", Some(1), |_, args| {
        let reason = match &args[0] {
            Value::String(s) => (**s).clone(),
            _ => "skipped".to_string(),
        };
        println!("⊘ {}", reason);
        Ok(Value::Null)
    });

    // --- PROFILING ---

    // profile - profile a function call and return [result, timing_info]
    define(interp, "profile", Some(1), |interp, args| {
        let func = match &args[0] {
            Value::Function(f) => f.clone(),
            _ => return Err(RuntimeError::new("profile: argument must be function")),
        };

        let start = Instant::now();
        let result = interp.call_function(&func, vec![])?;
        let elapsed = start.elapsed();

        let mut timing = HashMap::new();
        timing.insert(
            "ms".to_string(),
            Value::Float(elapsed.as_secs_f64() * 1000.0),
        );
        timing.insert("us".to_string(), Value::Float(elapsed.as_micros() as f64));
        timing.insert("ns".to_string(), Value::Int(elapsed.as_nanos() as i64));

        Ok(Value::Tuple(Rc::new(vec![
            result,
            Value::Map(Rc::new(RefCell::new(timing))),
        ])))
    });

    // measure - measure execution time of function N times
    define(interp, "measure", Some(2), |interp, args| {
        let func = match &args[0] {
            Value::Function(f) => f.clone(),
            _ => {
                return Err(RuntimeError::new(
                    "measure: first argument must be function",
                ))
            }
        };
        let iterations = match &args[1] {
            Value::Int(n) => *n as usize,
            _ => {
                return Err(RuntimeError::new(
                    "measure: second argument must be iteration count",
                ))
            }
        };

        let mut times: Vec<f64> = Vec::new();
        let mut last_result = Value::Null;

        for _ in 0..iterations {
            let start = Instant::now();
            last_result = interp.call_function(&func, vec![])?;
            times.push(start.elapsed().as_secs_f64() * 1000.0);
        }

        let sum: f64 = times.iter().sum();
        let avg = sum / iterations as f64;
        let min = times.iter().cloned().fold(f64::INFINITY, f64::min);
        let max = times.iter().cloned().fold(f64::NEG_INFINITY, f64::max);

        let variance: f64 =
            times.iter().map(|t| (t - avg).powi(2)).sum::<f64>() / iterations as f64;
        let stddev = variance.sqrt();

        let mut stats = HashMap::new();
        stats.insert("iterations".to_string(), Value::Int(iterations as i64));
        stats.insert("total_ms".to_string(), Value::Float(sum));
        stats.insert("avg_ms".to_string(), Value::Float(avg));
        stats.insert("min_ms".to_string(), Value::Float(min));
        stats.insert("max_ms".to_string(), Value::Float(max));
        stats.insert("stddev_ms".to_string(), Value::Float(stddev));

        Ok(Value::Tuple(Rc::new(vec![
            last_result,
            Value::Map(Rc::new(RefCell::new(stats))),
        ])))
    });

    // --- DOCUMENTATION ---

    // help - get help text for a builtin function
    define(interp, "help", Some(1), |_, args| {
        let name = match &args[0] {
            Value::String(s) => (**s).clone(),
            Value::BuiltIn(f) => f.name.clone(),
            _ => {
                return Err(RuntimeError::new(
                    "help: argument must be function name or builtin",
                ))
            }
        };

        // Return documentation for known functions
        let doc = get_function_doc(&name);
        Ok(Value::String(Rc::new(doc)))
    });

    // list_builtins - list common builtin functions (categories)
    define(interp, "list_builtins", Some(0), |_, _| {
        let categories = vec![
            "Core: print, println, assert, panic, len, type_of",
            "Math: abs, floor, ceil, round, sqrt, pow, log, sin, cos, tan",
            "Collections: map, filter, reduce, zip, flatten, first, last, sort, reverse",
            "Strings: upper, lower, trim, split, join, contains, replace, format",
            "IO: read_file, write_file, file_exists, read_line",
            "Time: now, sleep, timestamp, format_time",
            "JSON: json_parse, json_stringify",
            "Crypto: sha256, sha512, md5, base64_encode, base64_decode",
            "Regex: regex_match, regex_replace, regex_split",
            "Pattern: type_of, is_type, match_regex, match_struct, guard, when",
            "DevEx: debug, inspect, trace, assert_eq, assert_ne, test, profile",
        ];
        let values: Vec<Value> = categories
            .iter()
            .map(|s| Value::String(Rc::new(s.to_string())))
            .collect();
        Ok(Value::Array(Rc::new(RefCell::new(values))))
    });

    // --- UTILITY ---

    // todo - placeholder that throws with message
    define(interp, "todo", Some(0), |_, _| {
        Err(RuntimeError::new("not yet implemented"))
    });

    // unreachable - mark code as unreachable
    define(interp, "unreachable", Some(0), |_, _| {
        Err(RuntimeError::new("reached unreachable code"))
    });

    // unimplemented - mark feature as unimplemented
    define(interp, "unimplemented", Some(1), |_, args| {
        let msg = match &args[0] {
            Value::String(s) => (**s).clone(),
            _ => "unimplemented".to_string(),
        };
        Err(RuntimeError::new(format!("unimplemented: {}", msg)))
    });

    // deprecated - warn about deprecated usage and return value
    define(interp, "deprecated", Some(2), |_, args| {
        let msg = match &args[0] {
            Value::String(s) => (**s).clone(),
            _ => "deprecated".to_string(),
        };
        eprintln!("[DEPRECATED] {}", msg);
        Ok(args[1].clone())
    });

    // version - return Sigil version info
    define(interp, "version", Some(0), |_, _| {
        let mut info = HashMap::new();
        info.insert(
            "sigil".to_string(),
            Value::String(Rc::new("0.1.0".to_string())),
        );
        info.insert(
            "stdlib".to_string(),
            Value::String(Rc::new("7.0".to_string())),
        );
        info.insert(
            "phase".to_string(),
            Value::String(Rc::new("Phase 7 - DevEx".to_string())),
        );
        Ok(Value::Map(Rc::new(RefCell::new(info))))
    });
}

// Helper to format value for debug output
fn format_value_debug(value: &Value) -> String {
    match value {
        Value::Null => "null".to_string(),
        Value::Bool(b) => b.to_string(),
        Value::Int(n) => n.to_string(),
        Value::Float(f) => format!("{:.6}", f),
        Value::String(s) => format!("\"{}\"", s),
        Value::Char(c) => format!("'{}'", c),
        Value::Array(a) => {
            let items: Vec<String> = a.borrow().iter().take(10).map(format_value_debug).collect();
            if a.borrow().len() > 10 {
                format!(
                    "[{}, ... ({} more)]",
                    items.join(", "),
                    a.borrow().len() - 10
                )
            } else {
                format!("[{}]", items.join(", "))
            }
        }
        Value::Tuple(t) => {
            let items: Vec<String> = t.iter().map(format_value_debug).collect();
            format!("({})", items.join(", "))
        }
        Value::Map(m) => {
            let items: Vec<String> = m
                .borrow()
                .iter()
                .take(5)
                .map(|(k, v)| format!("{}: {}", k, format_value_debug(v)))
                .collect();
            if m.borrow().len() > 5 {
                format!(
                    "{{{}, ... ({} more)}}",
                    items.join(", "),
                    m.borrow().len() - 5
                )
            } else {
                format!("{{{}}}", items.join(", "))
            }
        }
        Value::Set(s) => {
            let items: Vec<String> = s.borrow().iter().take(5).cloned().collect();
            if s.borrow().len() > 5 {
                format!(
                    "#{{{}, ... ({} more)}}",
                    items.join(", "),
                    s.borrow().len() - 5
                )
            } else {
                format!("#{{{}}}", items.join(", "))
            }
        }
        Value::Struct { name, fields } => {
            let items: Vec<String> = fields
                .borrow()
                .iter()
                .map(|(k, v)| format!("{}: {}", k, format_value_debug(v)))
                .collect();
            format!("{} {{{}}}", name, items.join(", "))
        }
        Value::Variant {
            enum_name,
            variant_name,
            fields,
        } => match fields {
            Some(f) => {
                let items: Vec<String> = f.iter().map(format_value_debug).collect();
                format!("{}::{}({})", enum_name, variant_name, items.join(", "))
            }
            None => format!("{}::{}", enum_name, variant_name),
        },
        Value::Function(_) => "<function>".to_string(),
        Value::BuiltIn(f) => format!("<builtin:{}>", f.name),
        Value::Ref(r) => format!("&{}", format_value_debug(&r.borrow())),
        Value::Infinity => "∞".to_string(),
        Value::Empty => "∅".to_string(),
        Value::Evidential { value, evidence } => {
            format!("{:?}({})", evidence, format_value_debug(value))
        }
        Value::Affective { value, affect } => {
            let mut markers = Vec::new();
            if let Some(s) = &affect.sentiment {
                markers.push(format!("{:?}", s));
            }
            if affect.sarcasm {
                markers.push("sarcasm".to_string());
            }
            if let Some(i) = &affect.intensity {
                markers.push(format!("{:?}", i));
            }
            if let Some(f) = &affect.formality {
                markers.push(format!("{:?}", f));
            }
            if let Some(e) = &affect.emotion {
                markers.push(format!("{:?}", e));
            }
            if let Some(c) = &affect.confidence {
                markers.push(format!("{:?}", c));
            }
            format!("{}[{}]", format_value_debug(value), markers.join(","))
        }
        Value::Channel(_) => "<channel>".to_string(),
        Value::ThreadHandle(_) => "<thread>".to_string(),
        Value::Actor(_) => "<actor>".to_string(),
        Value::Future(_) => "<future>".to_string(),
    }
}

// Helper for pretty printing with indentation
fn pretty_print_value(value: &Value, indent: usize) -> String {
    let prefix = "  ".repeat(indent);
    match value {
        Value::Array(a) => {
            if a.borrow().is_empty() {
                "[]".to_string()
            } else {
                let items: Vec<String> = a
                    .borrow()
                    .iter()
                    .map(|v| {
                        format!(
                            "{}{}",
                            "  ".repeat(indent + 1),
                            pretty_print_value(v, indent + 1)
                        )
                    })
                    .collect();
                format!("[\n{}\n{}]", items.join(",\n"), prefix)
            }
        }
        Value::Map(m) => {
            if m.borrow().is_empty() {
                "{}".to_string()
            } else {
                let items: Vec<String> = m
                    .borrow()
                    .iter()
                    .map(|(k, v)| {
                        format!(
                            "{}\"{}\": {}",
                            "  ".repeat(indent + 1),
                            k,
                            pretty_print_value(v, indent + 1)
                        )
                    })
                    .collect();
                format!("{{\n{}\n{}}}", items.join(",\n"), prefix)
            }
        }
        Value::Struct { name, fields } => {
            if fields.borrow().is_empty() {
                format!("{} {{}}", name)
            } else {
                let items: Vec<String> = fields
                    .borrow()
                    .iter()
                    .map(|(k, v)| {
                        format!(
                            "{}{}: {}",
                            "  ".repeat(indent + 1),
                            k,
                            pretty_print_value(v, indent + 1)
                        )
                    })
                    .collect();
                format!("{} {{\n{}\n{}}}", name, items.join(",\n"), prefix)
            }
        }
        _ => format_value_debug(value),
    }
}

// Helper to compare values for ordering (DevEx assertions)
fn devex_compare(a: &Value, b: &Value) -> Result<i64, RuntimeError> {
    match (a, b) {
        (Value::Int(a), Value::Int(b)) => Ok(if a < b {
            -1
        } else if a > b {
            1
        } else {
            0
        }),
        (Value::Float(a), Value::Float(b)) => Ok(if a < b {
            -1
        } else if a > b {
            1
        } else {
            0
        }),
        (Value::Int(a), Value::Float(b)) => {
            let a = *a as f64;
            Ok(if a < *b {
                -1
            } else if a > *b {
                1
            } else {
                0
            })
        }
        (Value::Float(a), Value::Int(b)) => {
            let b = *b as f64;
            Ok(if *a < b {
                -1
            } else if *a > b {
                1
            } else {
                0
            })
        }
        (Value::String(a), Value::String(b)) => Ok(if a < b {
            -1
        } else if a > b {
            1
        } else {
            0
        }),
        _ => Err(RuntimeError::new("cannot compare these types")),
    }
}

// Helper to get type name
fn get_type_name(value: &Value) -> String {
    match value {
        Value::Null => "null".to_string(),
        Value::Bool(_) => "bool".to_string(),
        Value::Int(_) => "int".to_string(),
        Value::Float(_) => "float".to_string(),
        Value::String(_) => "string".to_string(),
        Value::Char(_) => "char".to_string(),
        Value::Array(_) => "array".to_string(),
        Value::Tuple(_) => "tuple".to_string(),
        Value::Map(_) => "map".to_string(),
        Value::Set(_) => "set".to_string(),
        Value::Struct { name, .. } => name.clone(),
        Value::Variant { enum_name, .. } => enum_name.clone(),
        Value::Function(_) => "function".to_string(),
        Value::BuiltIn(_) => "builtin".to_string(),
        Value::Ref(_) => "ref".to_string(),
        Value::Infinity => "infinity".to_string(),
        Value::Empty => "empty".to_string(),
        Value::Evidential { .. } => "evidential".to_string(),
        Value::Affective { .. } => "affective".to_string(),
        Value::Channel(_) => "channel".to_string(),
        Value::ThreadHandle(_) => "thread".to_string(),
        Value::Actor(_) => "actor".to_string(),
        Value::Future(_) => "future".to_string(),
    }
}

// Helper to check type aliases
fn matches_type_alias(value: &Value, type_name: &str) -> bool {
    match (value, type_name) {
        (Value::Int(_), "number") | (Value::Float(_), "number") => true,
        (Value::Int(_), "integer") => true,
        (Value::Array(_), "list") => true,
        (Value::Map(_), "dict") | (Value::Map(_), "object") => true,
        (Value::Function(_), "fn") | (Value::BuiltIn(_), "fn") => true,
        (Value::BuiltIn(_), "function") => true,
        _ => false,
    }
}

// Helper to get function documentation
fn get_function_doc(name: &str) -> String {
    match name {
        "print" => "print(value) - Print value to stdout".to_string(),
        "println" => "println(value) - Print value with newline".to_string(),
        "len" => "len(collection) - Get length of string, array, map, or set".to_string(),
        "type_of" => "type_of(value) - Get type name as string".to_string(),
        "assert" => "assert(condition) - Assert condition is truthy, panic if false".to_string(),
        "assert_eq" => "assert_eq(a, b) - Assert two values are deeply equal".to_string(),
        "debug" => "debug(value) - Print value with type info and return it".to_string(),
        "map" => "map(array, fn) - Apply function to each element".to_string(),
        "filter" => "filter(array, fn) - Keep elements where predicate is true".to_string(),
        "reduce" => "reduce(array, init, fn) - Fold array with function".to_string(),
        "range" => "range(start, end) - Create array of integers from start to end".to_string(),
        "sum" => "sum(array) - Sum all numeric elements".to_string(),
        "product" => "product(array) - Multiply all numeric elements".to_string(),
        "sort" => "sort(array) - Sort array in ascending order".to_string(),
        "reverse" => "reverse(array) - Reverse array order".to_string(),
        "join" => "join(array, sep) - Join array elements with separator".to_string(),
        "split" => "split(string, sep) - Split string by separator".to_string(),
        "trim" => "trim(string) - Remove leading/trailing whitespace".to_string(),
        "upper" => "upper(string) - Convert to uppercase".to_string(),
        "lower" => "lower(string) - Convert to lowercase".to_string(),
        _ => format!("No documentation available for '{}'", name),
    }
}

// ============================================================================
// PHASE 8: PERFORMANCE OPTIMIZATIONS
// ============================================================================
// SoA transforms, tensor ops, autodiff, spatial hashing, constraint solving

// ============================================================================
// SOA (STRUCT OF ARRAYS) TRANSFORMS
// ============================================================================
// Convert between AoS (Array of Structs) and SoA (Struct of Arrays) layouts
// Critical for SIMD and cache-friendly physics/graphics computations

fn register_soa(interp: &mut Interpreter) {
    // aos_to_soa(array, keys) - Convert Array of Structs to Struct of Arrays
    // Example: aos_to_soa([{x:1,y:2}, {x:3,y:4}], ["x","y"]) -> {x:[1,3], y:[2,4]}
    define(interp, "aos_to_soa", Some(2), |_, args| {
        let arr = match &args[0] {
            Value::Array(arr) => arr.borrow().clone(),
            _ => {
                return Err(RuntimeError::new(
                    "aos_to_soa: first argument must be array",
                ))
            }
        };
        let keys = match &args[1] {
            Value::Array(keys) => keys.borrow().clone(),
            _ => {
                return Err(RuntimeError::new(
                    "aos_to_soa: second argument must be array of keys",
                ))
            }
        };

        if arr.is_empty() {
            // Return empty SoA
            let mut result = HashMap::new();
            for key in &keys {
                if let Value::String(k) = key {
                    result.insert((**k).clone(), Value::Array(Rc::new(RefCell::new(vec![]))));
                }
            }
            return Ok(Value::Map(Rc::new(RefCell::new(result))));
        }

        // Extract key names
        let key_names: Vec<String> = keys
            .iter()
            .filter_map(|k| {
                if let Value::String(s) = k {
                    Some((**s).clone())
                } else {
                    None
                }
            })
            .collect();

        // Build arrays for each key
        let mut soa: HashMap<String, Vec<Value>> = HashMap::new();
        for key in &key_names {
            soa.insert(key.clone(), Vec::with_capacity(arr.len()));
        }

        // Extract values from each struct
        for item in &arr {
            match item {
                Value::Map(map) => {
                    let map = map.borrow();
                    for key in &key_names {
                        let val = map.get(key).cloned().unwrap_or(Value::Null);
                        soa.get_mut(key).unwrap().push(val);
                    }
                }
                Value::Struct { fields, .. } => {
                    let fields = fields.borrow();
                    for key in &key_names {
                        let val = fields.get(key).cloned().unwrap_or(Value::Null);
                        soa.get_mut(key).unwrap().push(val);
                    }
                }
                _ => {
                    return Err(RuntimeError::new(
                        "aos_to_soa: array must contain structs or maps",
                    ))
                }
            }
        }

        // Convert to Value::Map
        let result: HashMap<String, Value> = soa
            .into_iter()
            .map(|(k, v)| (k, Value::Array(Rc::new(RefCell::new(v)))))
            .collect();

        Ok(Value::Map(Rc::new(RefCell::new(result))))
    });

    // soa_to_aos(soa) - Convert Struct of Arrays back to Array of Structs
    // Example: soa_to_aos({x:[1,3], y:[2,4]}) -> [{x:1,y:2}, {x:3,y:4}]
    define(interp, "soa_to_aos", Some(1), |_, args| {
        let soa = match &args[0] {
            Value::Map(map) => map.borrow().clone(),
            _ => return Err(RuntimeError::new("soa_to_aos: argument must be map")),
        };

        if soa.is_empty() {
            return Ok(Value::Array(Rc::new(RefCell::new(vec![]))));
        }

        // Get the length from first array
        let len = soa
            .values()
            .next()
            .and_then(|v| {
                if let Value::Array(arr) = v {
                    Some(arr.borrow().len())
                } else {
                    None
                }
            })
            .unwrap_or(0);

        // Build array of structs
        let mut aos: Vec<Value> = Vec::with_capacity(len);
        for i in 0..len {
            let mut fields = HashMap::new();
            for (key, value) in &soa {
                if let Value::Array(arr) = value {
                    let arr = arr.borrow();
                    if i < arr.len() {
                        fields.insert(key.clone(), arr[i].clone());
                    }
                }
            }
            aos.push(Value::Map(Rc::new(RefCell::new(fields))));
        }

        Ok(Value::Array(Rc::new(RefCell::new(aos))))
    });

    // soa_map(soa, key, fn) - Apply function to a single array in SoA
    // Allows SIMD-friendly operations on one field at a time
    define(interp, "soa_map", Some(3), |interp, args| {
        let mut soa = match &args[0] {
            Value::Map(map) => map.borrow().clone(),
            _ => return Err(RuntimeError::new("soa_map: first argument must be SoA map")),
        };
        let key = match &args[1] {
            Value::String(s) => (**s).clone(),
            _ => {
                return Err(RuntimeError::new(
                    "soa_map: second argument must be key string",
                ))
            }
        };
        let func = match &args[2] {
            Value::Function(f) => f.clone(),
            _ => {
                return Err(RuntimeError::new(
                    "soa_map: third argument must be a function",
                ))
            }
        };

        // Get the array for this key
        let arr = soa
            .get(&key)
            .ok_or_else(|| RuntimeError::new(format!("soa_map: key '{}' not found", key)))?;

        let arr_vals = match arr {
            Value::Array(a) => a.borrow().clone(),
            _ => return Err(RuntimeError::new("soa_map: key must map to array")),
        };

        // Apply function to each element
        let results: Vec<Value> = arr_vals
            .iter()
            .map(|val| interp.call_function(&func, vec![val.clone()]))
            .collect::<Result<_, _>>()?;

        // Update SoA
        soa.insert(key, Value::Array(Rc::new(RefCell::new(results))));

        Ok(Value::Map(Rc::new(RefCell::new(soa))))
    });

    // soa_zip(soa, keys, fn) - Apply function to multiple fields in parallel
    // Example: soa_zip(soa, ["x", "y"], fn(x, y) { sqrt(x*x + y*y) }) -> array of magnitudes
    define(interp, "soa_zip", Some(3), |interp, args| {
        let soa = match &args[0] {
            Value::Map(map) => map.borrow().clone(),
            _ => return Err(RuntimeError::new("soa_zip: first argument must be SoA map")),
        };
        let keys = match &args[1] {
            Value::Array(keys) => keys.borrow().clone(),
            _ => {
                return Err(RuntimeError::new(
                    "soa_zip: second argument must be array of keys",
                ))
            }
        };
        let func = match &args[2] {
            Value::Function(f) => f.clone(),
            _ => {
                return Err(RuntimeError::new(
                    "soa_zip: third argument must be a function",
                ))
            }
        };

        // Extract arrays for each key
        let arrays: Vec<Vec<Value>> = keys
            .iter()
            .filter_map(|k| {
                if let Value::String(s) = k {
                    if let Some(Value::Array(arr)) = soa.get(&**s) {
                        return Some(arr.borrow().clone());
                    }
                }
                None
            })
            .collect();

        if arrays.is_empty() {
            return Ok(Value::Array(Rc::new(RefCell::new(vec![]))));
        }

        let len = arrays[0].len();

        // Apply function with zipped values
        let results: Vec<Value> = (0..len)
            .map(|i| {
                let fn_args: Vec<Value> = arrays
                    .iter()
                    .filter_map(|arr| arr.get(i).cloned())
                    .collect();
                interp.call_function(&func, fn_args)
            })
            .collect::<Result<_, _>>()?;

        Ok(Value::Array(Rc::new(RefCell::new(results))))
    });

    // interleave(arrays...) - Interleave multiple arrays (for position/normal/uv vertices)
    // Example: interleave([x1,x2], [y1,y2], [z1,z2]) -> [x1,y1,z1,x2,y2,z2]
    define(interp, "interleave", None, |_, args| {
        if args.is_empty() {
            return Ok(Value::Array(Rc::new(RefCell::new(vec![]))));
        }

        let arrays: Vec<Vec<Value>> = args
            .iter()
            .filter_map(|arg| {
                if let Value::Array(arr) = arg {
                    Some(arr.borrow().clone())
                } else {
                    None
                }
            })
            .collect();

        if arrays.is_empty() {
            return Ok(Value::Array(Rc::new(RefCell::new(vec![]))));
        }

        let len = arrays[0].len();
        let stride = arrays.len();
        let mut result = Vec::with_capacity(len * stride);

        for i in 0..len {
            for arr in &arrays {
                if let Some(val) = arr.get(i) {
                    result.push(val.clone());
                }
            }
        }

        Ok(Value::Array(Rc::new(RefCell::new(result))))
    });

    // deinterleave(array, stride) - Deinterleave an array (inverse of interleave)
    // Example: deinterleave([x1,y1,z1,x2,y2,z2], 3) -> [[x1,x2], [y1,y2], [z1,z2]]
    define(interp, "deinterleave", Some(2), |_, args| {
        let arr = match &args[0] {
            Value::Array(arr) => arr.borrow().clone(),
            _ => {
                return Err(RuntimeError::new(
                    "deinterleave: first argument must be array",
                ))
            }
        };
        let stride = match &args[1] {
            Value::Int(n) => *n as usize,
            _ => {
                return Err(RuntimeError::new(
                    "deinterleave: second argument must be integer stride",
                ))
            }
        };

        if stride == 0 {
            return Err(RuntimeError::new("deinterleave: stride must be > 0"));
        }

        let mut result: Vec<Vec<Value>> = (0..stride).map(|_| Vec::new()).collect();

        for (i, val) in arr.iter().enumerate() {
            result[i % stride].push(val.clone());
        }

        Ok(Value::Array(Rc::new(RefCell::new(
            result
                .into_iter()
                .map(|v| Value::Array(Rc::new(RefCell::new(v))))
                .collect(),
        ))))
    });
}

// ============================================================================
// TENSOR OPERATIONS
// ============================================================================
// Outer products, contractions, tensor transpose for advanced linear algebra

fn register_tensor(interp: &mut Interpreter) {
    // outer_product(a, b) - Tensor outer product: a ⊗ b
    // vec × vec -> matrix, mat × vec -> rank-3 tensor
    define(interp, "outer_product", Some(2), |_, args| {
        let a = match &args[0] {
            Value::Array(arr) => arr.borrow().clone(),
            _ => return Err(RuntimeError::new("outer_product: arguments must be arrays")),
        };
        let b = match &args[1] {
            Value::Array(arr) => arr.borrow().clone(),
            _ => return Err(RuntimeError::new("outer_product: arguments must be arrays")),
        };

        // vec ⊗ vec -> matrix
        let mut result: Vec<Value> = Vec::with_capacity(a.len() * b.len());
        for ai in &a {
            for bi in &b {
                let product = match (ai, bi) {
                    (Value::Float(x), Value::Float(y)) => Value::Float(x * y),
                    (Value::Int(x), Value::Int(y)) => Value::Int(x * y),
                    (Value::Float(x), Value::Int(y)) => Value::Float(x * (*y as f64)),
                    (Value::Int(x), Value::Float(y)) => Value::Float((*x as f64) * y),
                    _ => return Err(RuntimeError::new("outer_product: elements must be numeric")),
                };
                result.push(product);
            }
        }

        Ok(Value::Array(Rc::new(RefCell::new(result))))
    });

    // tensor_contract(a, b, axis_a, axis_b) - Contract tensors along specified axes
    // Generalized matrix multiplication and index contraction
    define(interp, "tensor_contract", Some(4), |_, args| {
        let a = match &args[0] {
            Value::Array(arr) => arr.borrow().clone(),
            _ => {
                return Err(RuntimeError::new(
                    "tensor_contract: first argument must be array",
                ))
            }
        };
        let b = match &args[1] {
            Value::Array(arr) => arr.borrow().clone(),
            _ => {
                return Err(RuntimeError::new(
                    "tensor_contract: second argument must be array",
                ))
            }
        };
        let _axis_a = match &args[2] {
            Value::Int(n) => *n as usize,
            _ => return Err(RuntimeError::new("tensor_contract: axis must be integer")),
        };
        let _axis_b = match &args[3] {
            Value::Int(n) => *n as usize,
            _ => return Err(RuntimeError::new("tensor_contract: axis must be integer")),
        };

        // Simple dot product for 1D tensors (vectors)
        if a.len() != b.len() {
            return Err(RuntimeError::new(
                "tensor_contract: vectors must have same length for contraction",
            ));
        }

        let mut sum = 0.0f64;
        for (ai, bi) in a.iter().zip(b.iter()) {
            let product = match (ai, bi) {
                (Value::Float(x), Value::Float(y)) => x * y,
                (Value::Int(x), Value::Int(y)) => (*x as f64) * (*y as f64),
                (Value::Float(x), Value::Int(y)) => x * (*y as f64),
                (Value::Int(x), Value::Float(y)) => (*x as f64) * y,
                _ => {
                    return Err(RuntimeError::new(
                        "tensor_contract: elements must be numeric",
                    ))
                }
            };
            sum += product;
        }

        Ok(Value::Float(sum))
    });

    // kronecker_product(a, b) - Kronecker tensor product
    // Used in quantum computing and multi-linear algebra
    define(interp, "kronecker_product", Some(2), |_, args| {
        let a = match &args[0] {
            Value::Array(arr) => arr.borrow().clone(),
            _ => {
                return Err(RuntimeError::new(
                    "kronecker_product: arguments must be arrays",
                ))
            }
        };
        let b = match &args[1] {
            Value::Array(arr) => arr.borrow().clone(),
            _ => {
                return Err(RuntimeError::new(
                    "kronecker_product: arguments must be arrays",
                ))
            }
        };

        // For 1D vectors: same as outer product
        let mut result: Vec<Value> = Vec::with_capacity(a.len() * b.len());
        for ai in &a {
            for bi in &b {
                let product = match (ai, bi) {
                    (Value::Float(x), Value::Float(y)) => Value::Float(x * y),
                    (Value::Int(x), Value::Int(y)) => Value::Int(x * y),
                    (Value::Float(x), Value::Int(y)) => Value::Float(x * (*y as f64)),
                    (Value::Int(x), Value::Float(y)) => Value::Float((*x as f64) * y),
                    _ => {
                        return Err(RuntimeError::new(
                            "kronecker_product: elements must be numeric",
                        ))
                    }
                };
                result.push(product);
            }
        }

        Ok(Value::Array(Rc::new(RefCell::new(result))))
    });

    // hadamard_product(a, b) - Element-wise product (Hadamard/Schur product)
    define(interp, "hadamard_product", Some(2), |_, args| {
        let a = match &args[0] {
            Value::Array(arr) => arr.borrow().clone(),
            _ => {
                return Err(RuntimeError::new(
                    "hadamard_product: arguments must be arrays",
                ))
            }
        };
        let b = match &args[1] {
            Value::Array(arr) => arr.borrow().clone(),
            _ => {
                return Err(RuntimeError::new(
                    "hadamard_product: arguments must be arrays",
                ))
            }
        };

        if a.len() != b.len() {
            return Err(RuntimeError::new(
                "hadamard_product: arrays must have same length",
            ));
        }

        let result: Vec<Value> = a
            .iter()
            .zip(b.iter())
            .map(|(ai, bi)| match (ai, bi) {
                (Value::Float(x), Value::Float(y)) => Ok(Value::Float(x * y)),
                (Value::Int(x), Value::Int(y)) => Ok(Value::Int(x * y)),
                (Value::Float(x), Value::Int(y)) => Ok(Value::Float(x * (*y as f64))),
                (Value::Int(x), Value::Float(y)) => Ok(Value::Float((*x as f64) * y)),
                _ => Err(RuntimeError::new(
                    "hadamard_product: elements must be numeric",
                )),
            })
            .collect::<Result<_, _>>()?;

        Ok(Value::Array(Rc::new(RefCell::new(result))))
    });

    // trace(matrix, size) - Trace of square matrix (sum of diagonal)
    define(interp, "trace", Some(2), |_, args| {
        let arr = match &args[0] {
            Value::Array(arr) => arr.borrow().clone(),
            _ => return Err(RuntimeError::new("trace: first argument must be array")),
        };
        let size = match &args[1] {
            Value::Int(n) => *n as usize,
            _ => {
                return Err(RuntimeError::new(
                    "trace: second argument must be matrix size",
                ))
            }
        };

        let mut sum = 0.0f64;
        for i in 0..size {
            let idx = i * size + i;
            if idx < arr.len() {
                sum += match &arr[idx] {
                    Value::Float(f) => *f,
                    Value::Int(n) => *n as f64,
                    _ => return Err(RuntimeError::new("trace: elements must be numeric")),
                };
            }
        }

        Ok(Value::Float(sum))
    });
}

// ============================================================================
// AUTOMATIC DIFFERENTIATION
// ============================================================================
//
// This module provides numerical differentiation using finite differences.
// While not as accurate as symbolic or dual-number autodiff, it's simple
// and works for any function without special annotations.
//
// ## Available Functions
//
// | Function | Description | Complexity |
// |----------|-------------|------------|
// | `grad(f, x, [h])` | Gradient of f at x | O(n) function calls |
// | `jacobian(f, x, [h])` | Jacobian matrix | O(m*n) function calls |
// | `hessian(f, x, [h])` | Hessian matrix | O(n²) function calls |
// | `directional_derivative(f, x, v, [h])` | Derivative along v | O(1) |
// | `laplacian(f, x, [h])` | Sum of second partials | O(n) |
//
// ## Algorithm Details
//
// All functions use central differences: (f(x+h) - f(x-h)) / 2h
// Default step size h = 1e-7 (optimized for f64 precision)
//
// ## Usage Examples
//
// ```sigil
// // Scalar function gradient
// fn f(x) { return x * x; }
// let df = grad(f, 3.0);  // Returns 6.0 (derivative of x² at x=3)
//
// // Multi-variable gradient
// fn g(x) { return get(x, 0)*get(x, 0) + get(x, 1)*get(x, 1); }
// let dg = grad(g, [1.0, 2.0]);  // Returns [2.0, 4.0]
//
// // Hessian of f at point x
// let H = hessian(f, [x, y]);  // Returns 2D array of second derivatives
// ```
//
// ## Performance Notes
//
// - grad: 2n function evaluations for n-dimensional input
// - jacobian: 2mn evaluations for m-output, n-input function
// - hessian: 4n² evaluations (computed from gradient)
// - For performance-critical code, consider symbolic differentiation

fn register_autodiff(interp: &mut Interpreter) {
    // grad(f, x, h) - Numerical gradient of f at x using finite differences
    // h is optional step size (default 1e-7)
    define(interp, "grad", None, |interp, args| {
        if args.len() < 2 {
            return Err(RuntimeError::new(
                "grad() requires function and point arguments.\n\
                 Usage: grad(f, x) or grad(f, x, step_size)\n\
                 Example:\n\
                   fn f(x) { return x * x; }\n\
                   let derivative = grad(f, 3.0);  // Returns 6.0",
            ));
        }

        let func = match &args[0] {
            Value::Function(f) => f.clone(),
            _ => {
                return Err(RuntimeError::new(
                    "grad() first argument must be a function.\n\
                 Got non-function value. Define a function first:\n\
                   fn my_func(x) { return x * x; }\n\
                   grad(my_func, 2.0)",
                ))
            }
        };
        let x = match &args[1] {
            Value::Float(f) => *f,
            Value::Int(n) => *n as f64,
            Value::Array(arr) => {
                // Multi-variable gradient
                let arr = arr.borrow().clone();
                let h = if args.len() > 2 {
                    match &args[2] {
                        Value::Float(f) => *f,
                        Value::Int(n) => *n as f64,
                        _ => 1e-7,
                    }
                } else {
                    1e-7
                };

                let mut gradient = Vec::with_capacity(arr.len());
                for (i, xi) in arr.iter().enumerate() {
                    let xi_val = match xi {
                        Value::Float(f) => *f,
                        Value::Int(n) => *n as f64,
                        _ => continue,
                    };

                    // f(x + h*ei) - f(x - h*ei) / 2h
                    let mut x_plus = arr.clone();
                    let mut x_minus = arr.clone();
                    x_plus[i] = Value::Float(xi_val + h);
                    x_minus[i] = Value::Float(xi_val - h);

                    let f_plus = interp
                        .call_function(&func, vec![Value::Array(Rc::new(RefCell::new(x_plus)))])?;
                    let f_minus = interp
                        .call_function(&func, vec![Value::Array(Rc::new(RefCell::new(x_minus)))])?;

                    let grad_i = match (f_plus, f_minus) {
                        (Value::Float(fp), Value::Float(fm)) => (fp - fm) / (2.0 * h),
                        (Value::Int(fp), Value::Int(fm)) => (fp - fm) as f64 / (2.0 * h),
                        _ => return Err(RuntimeError::new("grad: function must return numeric")),
                    };

                    gradient.push(Value::Float(grad_i));
                }

                return Ok(Value::Array(Rc::new(RefCell::new(gradient))));
            }
            _ => return Err(RuntimeError::new("grad: x must be numeric or array")),
        };

        let h = if args.len() > 2 {
            match &args[2] {
                Value::Float(f) => *f,
                Value::Int(n) => *n as f64,
                _ => 1e-7,
            }
        } else {
            1e-7
        };

        // Single variable derivative using central difference
        let f_plus = interp.call_function(&func, vec![Value::Float(x + h)])?;
        let f_minus = interp.call_function(&func, vec![Value::Float(x - h)])?;

        let derivative = match (f_plus, f_minus) {
            (Value::Float(fp), Value::Float(fm)) => (fp - fm) / (2.0 * h),
            (Value::Int(fp), Value::Int(fm)) => (fp - fm) as f64 / (2.0 * h),
            _ => return Err(RuntimeError::new("grad: function must return numeric")),
        };

        Ok(Value::Float(derivative))
    });

    // jacobian(f, x) - Compute Jacobian matrix for vector function
    define(interp, "jacobian", Some(2), |interp, args| {
        let func = match &args[0] {
            Value::Function(f) => f.clone(),
            _ => {
                return Err(RuntimeError::new(
                    "jacobian: first argument must be a function",
                ))
            }
        };
        let x = match &args[1] {
            Value::Array(arr) => arr.borrow().clone(),
            _ => return Err(RuntimeError::new("jacobian: second argument must be array")),
        };

        let h = 1e-7;
        let n = x.len();

        // Evaluate f at x to get output dimension
        let f_x =
            interp.call_function(&func, vec![Value::Array(Rc::new(RefCell::new(x.clone())))])?;
        let m = match &f_x {
            Value::Array(arr) => arr.borrow().len(),
            _ => 1,
        };

        // Build Jacobian matrix (m x n)
        let mut jacobian: Vec<Value> = Vec::with_capacity(m * n);

        for j in 0..n {
            let xj = match &x[j] {
                Value::Float(f) => *f,
                Value::Int(i) => *i as f64,
                _ => continue,
            };

            let mut x_plus = x.clone();
            let mut x_minus = x.clone();
            x_plus[j] = Value::Float(xj + h);
            x_minus[j] = Value::Float(xj - h);

            let f_plus =
                interp.call_function(&func, vec![Value::Array(Rc::new(RefCell::new(x_plus)))])?;
            let f_minus =
                interp.call_function(&func, vec![Value::Array(Rc::new(RefCell::new(x_minus)))])?;

            // Extract derivatives for each output component
            match (&f_plus, &f_minus) {
                (Value::Array(fp), Value::Array(fm)) => {
                    let fp = fp.borrow();
                    let fm = fm.borrow();
                    for i in 0..m {
                        let dfi_dxj = match (&fp[i], &fm[i]) {
                            (Value::Float(a), Value::Float(b)) => (*a - *b) / (2.0 * h),
                            (Value::Int(a), Value::Int(b)) => (*a - *b) as f64 / (2.0 * h),
                            _ => 0.0,
                        };
                        jacobian.push(Value::Float(dfi_dxj));
                    }
                }
                (Value::Float(fp), Value::Float(fm)) => {
                    jacobian.push(Value::Float((fp - fm) / (2.0 * h)));
                }
                _ => {
                    return Err(RuntimeError::new(
                        "jacobian: function must return array or numeric",
                    ))
                }
            }
        }

        Ok(Value::Array(Rc::new(RefCell::new(jacobian))))
    });

    // hessian(f, x) - Compute Hessian matrix (second derivatives)
    define(interp, "hessian", Some(2), |interp, args| {
        let func = match &args[0] {
            Value::Function(f) => f.clone(),
            _ => {
                return Err(RuntimeError::new(
                    "hessian: first argument must be a function",
                ))
            }
        };
        let x = match &args[1] {
            Value::Array(arr) => arr.borrow().clone(),
            _ => return Err(RuntimeError::new("hessian: second argument must be array")),
        };

        let h = 1e-5; // Larger h for second derivatives
        let n = x.len();

        let mut hessian: Vec<Value> = Vec::with_capacity(n * n);

        for i in 0..n {
            for j in 0..n {
                let xi = match &x[i] {
                    Value::Float(f) => *f,
                    Value::Int(k) => *k as f64,
                    _ => continue,
                };
                let xj = match &x[j] {
                    Value::Float(f) => *f,
                    Value::Int(k) => *k as f64,
                    _ => continue,
                };

                // Second partial derivative using finite differences
                let mut x_pp = x.clone();
                let mut x_pm = x.clone();
                let mut x_mp = x.clone();
                let mut x_mm = x.clone();

                x_pp[i] = Value::Float(xi + h);
                x_pp[j] = Value::Float(if i == j { xi + 2.0 * h } else { xj + h });
                x_pm[i] = Value::Float(xi + h);
                x_pm[j] = Value::Float(if i == j { xi } else { xj - h });
                x_mp[i] = Value::Float(xi - h);
                x_mp[j] = Value::Float(if i == j { xi } else { xj + h });
                x_mm[i] = Value::Float(xi - h);
                x_mm[j] = Value::Float(if i == j { xi - 2.0 * h } else { xj - h });

                let f_pp =
                    interp.call_function(&func, vec![Value::Array(Rc::new(RefCell::new(x_pp)))])?;
                let f_pm =
                    interp.call_function(&func, vec![Value::Array(Rc::new(RefCell::new(x_pm)))])?;
                let f_mp =
                    interp.call_function(&func, vec![Value::Array(Rc::new(RefCell::new(x_mp)))])?;
                let f_mm =
                    interp.call_function(&func, vec![Value::Array(Rc::new(RefCell::new(x_mm)))])?;

                let d2f = match (f_pp, f_pm, f_mp, f_mm) {
                    (
                        Value::Float(fpp),
                        Value::Float(fpm),
                        Value::Float(fmp),
                        Value::Float(fmm),
                    ) => (fpp - fpm - fmp + fmm) / (4.0 * h * h),
                    _ => 0.0,
                };

                hessian.push(Value::Float(d2f));
            }
        }

        Ok(Value::Array(Rc::new(RefCell::new(hessian))))
    });

    // divergence(f, x) - Compute divergence of vector field (∇·F)
    define(interp, "divergence", Some(2), |interp, args| {
        let func = match &args[0] {
            Value::Function(f) => f.clone(),
            _ => {
                return Err(RuntimeError::new(
                    "divergence: first argument must be a function",
                ))
            }
        };
        let x = match &args[1] {
            Value::Array(arr) => arr.borrow().clone(),
            _ => {
                return Err(RuntimeError::new(
                    "divergence: second argument must be array",
                ))
            }
        };

        let h = 1e-7;
        let mut div = 0.0f64;

        for (i, xi) in x.iter().enumerate() {
            let xi_val = match xi {
                Value::Float(f) => *f,
                Value::Int(n) => *n as f64,
                _ => continue,
            };

            let mut x_plus = x.clone();
            let mut x_minus = x.clone();
            x_plus[i] = Value::Float(xi_val + h);
            x_minus[i] = Value::Float(xi_val - h);

            let f_plus =
                interp.call_function(&func, vec![Value::Array(Rc::new(RefCell::new(x_plus)))])?;
            let f_minus =
                interp.call_function(&func, vec![Value::Array(Rc::new(RefCell::new(x_minus)))])?;

            // Extract i-th component
            let df_i = match (&f_plus, &f_minus) {
                (Value::Array(fp), Value::Array(fm)) => {
                    let fp = fp.borrow();
                    let fm = fm.borrow();
                    if i < fp.len() && i < fm.len() {
                        match (&fp[i], &fm[i]) {
                            (Value::Float(a), Value::Float(b)) => (*a - *b) / (2.0 * h),
                            (Value::Int(a), Value::Int(b)) => (*a - *b) as f64 / (2.0 * h),
                            _ => 0.0,
                        }
                    } else {
                        0.0
                    }
                }
                _ => 0.0,
            };

            div += df_i;
        }

        Ok(Value::Float(div))
    });
}

// ============================================================================
// SPATIAL HASHING / ACCELERATION STRUCTURES
// ============================================================================
// BVH, octrees, spatial hashing for efficient collision detection and queries

fn register_spatial(interp: &mut Interpreter) {
    // spatial_hash_new(cell_size) - Create new spatial hash grid
    define(interp, "spatial_hash_new", Some(1), |_, args| {
        let cell_size = match &args[0] {
            Value::Float(f) => *f,
            Value::Int(n) => *n as f64,
            _ => {
                return Err(RuntimeError::new(
                    "spatial_hash_new: cell_size must be numeric",
                ))
            }
        };

        let mut config = HashMap::new();
        config.insert("cell_size".to_string(), Value::Float(cell_size));
        config.insert(
            "buckets".to_string(),
            Value::Map(Rc::new(RefCell::new(HashMap::new()))),
        );

        Ok(Value::Map(Rc::new(RefCell::new(config))))
    });

    // spatial_hash_insert(hash, id, position) - Insert object at position
    define(interp, "spatial_hash_insert", Some(3), |_, args| {
        let hash = match &args[0] {
            Value::Map(map) => map.clone(),
            _ => {
                return Err(RuntimeError::new(
                    "spatial_hash_insert: first argument must be spatial hash",
                ))
            }
        };
        let id = args[1].clone();
        let pos = match &args[2] {
            Value::Array(arr) => arr.borrow().clone(),
            _ => {
                return Err(RuntimeError::new(
                    "spatial_hash_insert: position must be array",
                ))
            }
        };

        let cell_size = {
            let h = hash.borrow();
            match h.get("cell_size") {
                Some(Value::Float(f)) => *f,
                _ => 1.0,
            }
        };

        // Compute cell key
        let key = pos
            .iter()
            .filter_map(|v| match v {
                Value::Float(f) => Some((*f / cell_size).floor() as i64),
                Value::Int(n) => Some(*n / (cell_size as i64)),
                _ => None,
            })
            .map(|n| n.to_string())
            .collect::<Vec<_>>()
            .join(",");

        // Insert into bucket
        {
            let mut h = hash.borrow_mut();
            let buckets = h
                .entry("buckets".to_string())
                .or_insert_with(|| Value::Map(Rc::new(RefCell::new(HashMap::new()))));

            if let Value::Map(buckets_map) = buckets {
                let mut bm = buckets_map.borrow_mut();
                let bucket = bm
                    .entry(key)
                    .or_insert_with(|| Value::Array(Rc::new(RefCell::new(vec![]))));

                if let Value::Array(arr) = bucket {
                    arr.borrow_mut().push(id);
                }
            }
        }

        Ok(Value::Map(hash))
    });

    // spatial_hash_query(hash, position, radius) - Query objects near position
    define(interp, "spatial_hash_query", Some(3), |_, args| {
        let hash = match &args[0] {
            Value::Map(map) => map.borrow().clone(),
            _ => {
                return Err(RuntimeError::new(
                    "spatial_hash_query: first argument must be spatial hash",
                ))
            }
        };
        let pos = match &args[1] {
            Value::Array(arr) => arr.borrow().clone(),
            _ => {
                return Err(RuntimeError::new(
                    "spatial_hash_query: position must be array",
                ))
            }
        };
        let radius = match &args[2] {
            Value::Float(f) => *f,
            Value::Int(n) => *n as f64,
            _ => {
                return Err(RuntimeError::new(
                    "spatial_hash_query: radius must be numeric",
                ))
            }
        };

        let cell_size = match hash.get("cell_size") {
            Some(Value::Float(f)) => *f,
            _ => 1.0,
        };

        // Get center cell
        let center: Vec<i64> = pos
            .iter()
            .filter_map(|v| match v {
                Value::Float(f) => Some((*f / cell_size).floor() as i64),
                Value::Int(n) => Some(*n / (cell_size as i64)),
                _ => None,
            })
            .collect();

        // Compute cell range to check
        let cells_to_check = (radius / cell_size).ceil() as i64;

        let mut results: Vec<Value> = Vec::new();

        if let Some(Value::Map(buckets)) = hash.get("buckets") {
            let buckets = buckets.borrow();

            // Check neighboring cells
            if center.len() >= 2 {
                for dx in -cells_to_check..=cells_to_check {
                    for dy in -cells_to_check..=cells_to_check {
                        let key = format!("{},{}", center[0] + dx, center[1] + dy);
                        if let Some(Value::Array(bucket)) = buckets.get(&key) {
                            for item in bucket.borrow().iter() {
                                // Push without duplicate check since Value doesn't impl PartialEq
                                // For production use, would need to track IDs separately
                                results.push(item.clone());
                            }
                        }
                    }
                }
            }
        }

        Ok(Value::Array(Rc::new(RefCell::new(results))))
    });

    // aabb_new(min, max) - Create axis-aligned bounding box
    define(interp, "aabb_new", Some(2), |_, args| {
        let min = match &args[0] {
            Value::Array(arr) => arr.borrow().clone(),
            _ => return Err(RuntimeError::new("aabb_new: min must be array")),
        };
        let max = match &args[1] {
            Value::Array(arr) => arr.borrow().clone(),
            _ => return Err(RuntimeError::new("aabb_new: max must be array")),
        };

        let mut aabb = HashMap::new();
        aabb.insert("min".to_string(), Value::Array(Rc::new(RefCell::new(min))));
        aabb.insert("max".to_string(), Value::Array(Rc::new(RefCell::new(max))));

        Ok(Value::Map(Rc::new(RefCell::new(aabb))))
    });

    // aabb_intersects(a, b) - Test if two AABBs intersect
    define(interp, "aabb_intersects", Some(2), |_, args| {
        let a = match &args[0] {
            Value::Map(map) => map.borrow().clone(),
            _ => {
                return Err(RuntimeError::new(
                    "aabb_intersects: arguments must be AABBs",
                ))
            }
        };
        let b = match &args[1] {
            Value::Map(map) => map.borrow().clone(),
            _ => {
                return Err(RuntimeError::new(
                    "aabb_intersects: arguments must be AABBs",
                ))
            }
        };

        let a_min = extract_vec_from_map(&a, "min")?;
        let a_max = extract_vec_from_map(&a, "max")?;
        let b_min = extract_vec_from_map(&b, "min")?;
        let b_max = extract_vec_from_map(&b, "max")?;

        // Check overlap in each dimension
        for i in 0..a_min
            .len()
            .min(a_max.len())
            .min(b_min.len())
            .min(b_max.len())
        {
            if a_max[i] < b_min[i] || b_max[i] < a_min[i] {
                return Ok(Value::Bool(false));
            }
        }

        Ok(Value::Bool(true))
    });

    // aabb_contains(aabb, point) - Test if AABB contains point
    define(interp, "aabb_contains", Some(2), |_, args| {
        let aabb = match &args[0] {
            Value::Map(map) => map.borrow().clone(),
            _ => {
                return Err(RuntimeError::new(
                    "aabb_contains: first argument must be AABB",
                ))
            }
        };
        let point = match &args[1] {
            Value::Array(arr) => arr.borrow().clone(),
            _ => {
                return Err(RuntimeError::new(
                    "aabb_contains: second argument must be point array",
                ))
            }
        };

        let min = extract_vec_from_map(&aabb, "min")?;
        let max = extract_vec_from_map(&aabb, "max")?;

        for (i, p) in point.iter().enumerate() {
            let p_val = match p {
                Value::Float(f) => *f,
                Value::Int(n) => *n as f64,
                _ => continue,
            };

            if i < min.len() && p_val < min[i] {
                return Ok(Value::Bool(false));
            }
            if i < max.len() && p_val > max[i] {
                return Ok(Value::Bool(false));
            }
        }

        Ok(Value::Bool(true))
    });
}

// Helper for extracting vector from AABB map
fn extract_vec_from_map(map: &HashMap<String, Value>, key: &str) -> Result<Vec<f64>, RuntimeError> {
    match map.get(key) {
        Some(Value::Array(arr)) => arr
            .borrow()
            .iter()
            .map(|v| match v {
                Value::Float(f) => Ok(*f),
                Value::Int(n) => Ok(*n as f64),
                _ => Err(RuntimeError::new("Expected numeric value")),
            })
            .collect(),
        _ => Err(RuntimeError::new(format!(
            "Missing or invalid '{}' in AABB",
            key
        ))),
    }
}

// ============================================================================
// PHYSICS / CONSTRAINT SOLVER
// ============================================================================
// Verlet integration, constraint solving, spring systems

fn register_physics(interp: &mut Interpreter) {
    // verlet_integrate(pos, prev_pos, accel, dt) - Verlet integration step
    // Returns new position: pos + (pos - prev_pos) + accel * dt^2
    define(interp, "verlet_integrate", Some(4), |_, args| {
        let pos = extract_vec3(&args[0], "verlet_integrate")?;
        let prev = extract_vec3(&args[1], "verlet_integrate")?;
        let accel = extract_vec3(&args[2], "verlet_integrate")?;
        let dt = match &args[3] {
            Value::Float(f) => *f,
            Value::Int(n) => *n as f64,
            _ => return Err(RuntimeError::new("verlet_integrate: dt must be numeric")),
        };

        let dt2 = dt * dt;
        let new_pos = [
            pos[0] + (pos[0] - prev[0]) + accel[0] * dt2,
            pos[1] + (pos[1] - prev[1]) + accel[1] * dt2,
            pos[2] + (pos[2] - prev[2]) + accel[2] * dt2,
        ];

        Ok(make_vec3_arr(new_pos))
    });

    // spring_force(p1, p2, rest_length, stiffness) - Compute spring force
    define(interp, "spring_force", Some(4), |_, args| {
        let p1 = extract_vec3(&args[0], "spring_force")?;
        let p2 = extract_vec3(&args[1], "spring_force")?;
        let rest_length = match &args[2] {
            Value::Float(f) => *f,
            Value::Int(n) => *n as f64,
            _ => {
                return Err(RuntimeError::new(
                    "spring_force: rest_length must be numeric",
                ))
            }
        };
        let stiffness = match &args[3] {
            Value::Float(f) => *f,
            Value::Int(n) => *n as f64,
            _ => return Err(RuntimeError::new("spring_force: stiffness must be numeric")),
        };

        let delta = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];
        let length = (delta[0] * delta[0] + delta[1] * delta[1] + delta[2] * delta[2]).sqrt();

        if length < 1e-10 {
            return Ok(make_vec3_arr([0.0, 0.0, 0.0]));
        }

        let displacement = length - rest_length;
        let force_mag = stiffness * displacement;
        let normalized = [delta[0] / length, delta[1] / length, delta[2] / length];

        Ok(make_vec3_arr([
            normalized[0] * force_mag,
            normalized[1] * force_mag,
            normalized[2] * force_mag,
        ]))
    });

    // distance_constraint(p1, p2, target_distance) - Apply distance constraint
    // Returns tuple of (new_p1, new_p2) that satisfy the constraint
    define(interp, "distance_constraint", Some(3), |_, args| {
        let p1 = extract_vec3(&args[0], "distance_constraint")?;
        let p2 = extract_vec3(&args[1], "distance_constraint")?;
        let target = match &args[2] {
            Value::Float(f) => *f,
            Value::Int(n) => *n as f64,
            _ => {
                return Err(RuntimeError::new(
                    "distance_constraint: target must be numeric",
                ))
            }
        };

        let delta = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];
        let length = (delta[0] * delta[0] + delta[1] * delta[1] + delta[2] * delta[2]).sqrt();

        if length < 1e-10 {
            return Ok(Value::Tuple(Rc::new(vec![
                make_vec3_arr(p1),
                make_vec3_arr(p2),
            ])));
        }

        let correction = (length - target) / length * 0.5;
        let corr_vec = [
            delta[0] * correction,
            delta[1] * correction,
            delta[2] * correction,
        ];

        let new_p1 = [
            p1[0] + corr_vec[0],
            p1[1] + corr_vec[1],
            p1[2] + corr_vec[2],
        ];
        let new_p2 = [
            p2[0] - corr_vec[0],
            p2[1] - corr_vec[1],
            p2[2] - corr_vec[2],
        ];

        Ok(Value::Tuple(Rc::new(vec![
            make_vec3_arr(new_p1),
            make_vec3_arr(new_p2),
        ])))
    });

    // solve_constraints(points, constraints, iterations) - Iterative constraint solver
    // constraints: array of {type, indices, params}
    define(interp, "solve_constraints", Some(3), |_, args| {
        let mut points = match &args[0] {
            Value::Array(arr) => arr.borrow().clone(),
            _ => {
                return Err(RuntimeError::new(
                    "solve_constraints: first argument must be array of points",
                ))
            }
        };
        let constraints = match &args[1] {
            Value::Array(arr) => arr.borrow().clone(),
            _ => {
                return Err(RuntimeError::new(
                    "solve_constraints: second argument must be array of constraints",
                ))
            }
        };
        let iterations = match &args[2] {
            Value::Int(n) => *n as usize,
            _ => {
                return Err(RuntimeError::new(
                    "solve_constraints: iterations must be integer",
                ))
            }
        };

        for _ in 0..iterations {
            for constraint in &constraints {
                match constraint {
                    Value::Map(c) => {
                        let c = c.borrow();
                        let constraint_type = c
                            .get("type")
                            .and_then(|v| {
                                if let Value::String(s) = v {
                                    Some((**s).clone())
                                } else {
                                    None
                                }
                            })
                            .unwrap_or_default();

                        match constraint_type.as_str() {
                            "distance" => {
                                let indices = match c.get("indices") {
                                    Some(Value::Array(arr)) => arr.borrow().clone(),
                                    _ => continue,
                                };
                                let target = match c.get("distance") {
                                    Some(Value::Float(f)) => *f,
                                    Some(Value::Int(n)) => *n as f64,
                                    _ => continue,
                                };

                                if indices.len() >= 2 {
                                    let i1 = match &indices[0] {
                                        Value::Int(n) => *n as usize,
                                        _ => continue,
                                    };
                                    let i2 = match &indices[1] {
                                        Value::Int(n) => *n as usize,
                                        _ => continue,
                                    };

                                    if i1 < points.len() && i2 < points.len() {
                                        // Apply distance constraint inline
                                        let p1 = extract_vec3(&points[i1], "solve")?;
                                        let p2 = extract_vec3(&points[i2], "solve")?;

                                        let delta = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];
                                        let length = (delta[0] * delta[0]
                                            + delta[1] * delta[1]
                                            + delta[2] * delta[2])
                                            .sqrt();

                                        if length > 1e-10 {
                                            let correction = (length - target) / length * 0.5;
                                            let corr_vec = [
                                                delta[0] * correction,
                                                delta[1] * correction,
                                                delta[2] * correction,
                                            ];

                                            points[i1] = make_vec3_arr([
                                                p1[0] + corr_vec[0],
                                                p1[1] + corr_vec[1],
                                                p1[2] + corr_vec[2],
                                            ]);
                                            points[i2] = make_vec3_arr([
                                                p2[0] - corr_vec[0],
                                                p2[1] - corr_vec[1],
                                                p2[2] - corr_vec[2],
                                            ]);
                                        }
                                    }
                                }
                            }
                            _ => {}
                        }
                    }
                    _ => continue,
                }
            }
        }

        Ok(Value::Array(Rc::new(RefCell::new(points))))
    });

    // ray_sphere_intersect(ray_origin, ray_dir, sphere_center, radius) - Ray-sphere intersection
    // Returns distance to intersection or -1 if no hit
    define(interp, "ray_sphere_intersect", Some(4), |_, args| {
        let origin = extract_vec3(&args[0], "ray_sphere_intersect")?;
        let dir = extract_vec3(&args[1], "ray_sphere_intersect")?;
        let center = extract_vec3(&args[2], "ray_sphere_intersect")?;
        let radius = match &args[3] {
            Value::Float(f) => *f,
            Value::Int(n) => *n as f64,
            _ => {
                return Err(RuntimeError::new(
                    "ray_sphere_intersect: radius must be numeric",
                ))
            }
        };

        let oc = [
            origin[0] - center[0],
            origin[1] - center[1],
            origin[2] - center[2],
        ];

        let a = dir[0] * dir[0] + dir[1] * dir[1] + dir[2] * dir[2];
        let b = 2.0 * (oc[0] * dir[0] + oc[1] * dir[1] + oc[2] * dir[2]);
        let c = oc[0] * oc[0] + oc[1] * oc[1] + oc[2] * oc[2] - radius * radius;

        let discriminant = b * b - 4.0 * a * c;

        if discriminant < 0.0 {
            Ok(Value::Float(-1.0))
        } else {
            let t = (-b - discriminant.sqrt()) / (2.0 * a);
            if t > 0.0 {
                Ok(Value::Float(t))
            } else {
                let t2 = (-b + discriminant.sqrt()) / (2.0 * a);
                if t2 > 0.0 {
                    Ok(Value::Float(t2))
                } else {
                    Ok(Value::Float(-1.0))
                }
            }
        }
    });

    // ray_plane_intersect(ray_origin, ray_dir, plane_point, plane_normal) - Ray-plane intersection
    define(interp, "ray_plane_intersect", Some(4), |_, args| {
        let origin = extract_vec3(&args[0], "ray_plane_intersect")?;
        let dir = extract_vec3(&args[1], "ray_plane_intersect")?;
        let plane_pt = extract_vec3(&args[2], "ray_plane_intersect")?;
        let normal = extract_vec3(&args[3], "ray_plane_intersect")?;

        let denom = dir[0] * normal[0] + dir[1] * normal[1] + dir[2] * normal[2];

        if denom.abs() < 1e-10 {
            return Ok(Value::Float(-1.0)); // Parallel to plane
        }

        let diff = [
            plane_pt[0] - origin[0],
            plane_pt[1] - origin[1],
            plane_pt[2] - origin[2],
        ];
        let t = (diff[0] * normal[0] + diff[1] * normal[1] + diff[2] * normal[2]) / denom;

        if t > 0.0 {
            Ok(Value::Float(t))
        } else {
            Ok(Value::Float(-1.0))
        }
    });
}

// ============================================================================
// GEOMETRIC ALGEBRA (GA3D - Cl(3,0,0))
// ============================================================================
//
// Complete Clifford Algebra implementation in 3D. Geometric Algebra unifies:
// - Complex numbers (as rotations in 2D)
// - Quaternions (as rotors in 3D)
// - Vectors, bivectors, and trivectors
// - Reflections, rotations, and projections
//
// ## Multivector Structure
//
// | Grade | Basis | Name | Geometric Meaning |
// |-------|-------|------|-------------------|
// | 0 | 1 | Scalar | Magnitude |
// | 1 | e₁, e₂, e₃ | Vectors | Directed lengths |
// | 2 | e₁₂, e₂₃, e₃₁ | Bivectors | Oriented planes |
// | 3 | e₁₂₃ | Trivector | Oriented volume |
//
// ## Key Operations
//
// | Function | Description | Mathematical Form |
// |----------|-------------|-------------------|
// | `mv_new(s, e1..e123)` | Create multivector | s + e₁v₁ + ... + e₁₂₃t |
// | `mv_geometric_product(a, b)` | Geometric product | ab (non-commutative) |
// | `mv_inner_product(a, b)` | Inner product | a·b |
// | `mv_outer_product(a, b)` | Outer product | a∧b (wedge) |
// | `rotor_from_axis_angle(axis, θ)` | Create rotor | cos(θ/2) + sin(θ/2)·B |
// | `rotor_apply(R, v)` | Apply rotor | RvR† (sandwich) |
//
// ## Rotor Properties
//
// Rotors are normalized even-grade multivectors (scalar + bivector).
// They rotate vectors via the "sandwich product": v' = RvR†
// This is more efficient than matrix multiplication and composes naturally.
//
// ## Usage Examples
//
// ```sigil
// // Create a 90° rotation around Z-axis
// let axis = vec3(0, 0, 1);
// let R = rotor_from_axis_angle(axis, PI / 2.0);
//
// // Rotate a vector
// let v = vec3(1, 0, 0);
// let v_rotated = rotor_apply(R, v);  // Returns [0, 1, 0]
//
// // Compose rotations
// let R2 = rotor_from_axis_angle(vec3(0, 1, 0), PI / 4.0);
// let R_combined = rotor_compose(R, R2);  // First R, then R2
// ```
//
// ## Grade Extraction
//
// | Function | Returns |
// |----------|---------|
// | `mv_grade(mv, 0)` | Scalar part |
// | `mv_grade(mv, 1)` | Vector part |
// | `mv_grade(mv, 2)` | Bivector part |
// | `mv_grade(mv, 3)` | Trivector part |

fn register_geometric_algebra(interp: &mut Interpreter) {
    // Helper to create a multivector from 8 components
    fn make_multivector(components: [f64; 8]) -> Value {
        let mut mv = HashMap::new();
        mv.insert("s".to_string(), Value::Float(components[0])); // scalar
        mv.insert("e1".to_string(), Value::Float(components[1])); // e₁
        mv.insert("e2".to_string(), Value::Float(components[2])); // e₂
        mv.insert("e3".to_string(), Value::Float(components[3])); // e₃
        mv.insert("e12".to_string(), Value::Float(components[4])); // e₁₂
        mv.insert("e23".to_string(), Value::Float(components[5])); // e₂₃
        mv.insert("e31".to_string(), Value::Float(components[6])); // e₃₁
        mv.insert("e123".to_string(), Value::Float(components[7])); // e₁₂₃ (pseudoscalar)
        mv.insert(
            "_type".to_string(),
            Value::String(Rc::new("multivector".to_string())),
        );
        Value::Map(Rc::new(RefCell::new(mv)))
    }

    fn extract_multivector(v: &Value, fn_name: &str) -> Result<[f64; 8], RuntimeError> {
        match v {
            Value::Map(map) => {
                let map = map.borrow();
                let get_component = |key: &str| -> f64 {
                    match map.get(key) {
                        Some(Value::Float(f)) => *f,
                        Some(Value::Int(n)) => *n as f64,
                        _ => 0.0,
                    }
                };
                Ok([
                    get_component("s"),
                    get_component("e1"),
                    get_component("e2"),
                    get_component("e3"),
                    get_component("e12"),
                    get_component("e23"),
                    get_component("e31"),
                    get_component("e123"),
                ])
            }
            _ => Err(RuntimeError::new(format!(
                "{}: expected multivector",
                fn_name
            ))),
        }
    }

    // mv_new(s, e1, e2, e3, e12, e23, e31, e123) - Create multivector from components
    define(interp, "mv_new", Some(8), |_, args| {
        let mut components = [0.0f64; 8];
        for (i, arg) in args.iter().enumerate().take(8) {
            components[i] = match arg {
                Value::Float(f) => *f,
                Value::Int(n) => *n as f64,
                _ => 0.0,
            };
        }
        Ok(make_multivector(components))
    });

    // mv_scalar(s) - Create scalar multivector
    define(interp, "mv_scalar", Some(1), |_, args| {
        let s = match &args[0] {
            Value::Float(f) => *f,
            Value::Int(n) => *n as f64,
            _ => return Err(RuntimeError::new("mv_scalar: expected number")),
        };
        Ok(make_multivector([s, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]))
    });

    // mv_vector(x, y, z) - Create vector (grade-1 multivector)
    define(interp, "mv_vector", Some(3), |_, args| {
        let x = match &args[0] {
            Value::Float(f) => *f,
            Value::Int(n) => *n as f64,
            _ => 0.0,
        };
        let y = match &args[1] {
            Value::Float(f) => *f,
            Value::Int(n) => *n as f64,
            _ => 0.0,
        };
        let z = match &args[2] {
            Value::Float(f) => *f,
            Value::Int(n) => *n as f64,
            _ => 0.0,
        };
        Ok(make_multivector([0.0, x, y, z, 0.0, 0.0, 0.0, 0.0]))
    });

    // mv_bivector(xy, yz, zx) - Create bivector (grade-2, represents oriented planes)
    define(interp, "mv_bivector", Some(3), |_, args| {
        let xy = match &args[0] {
            Value::Float(f) => *f,
            Value::Int(n) => *n as f64,
            _ => 0.0,
        };
        let yz = match &args[1] {
            Value::Float(f) => *f,
            Value::Int(n) => *n as f64,
            _ => 0.0,
        };
        let zx = match &args[2] {
            Value::Float(f) => *f,
            Value::Int(n) => *n as f64,
            _ => 0.0,
        };
        Ok(make_multivector([0.0, 0.0, 0.0, 0.0, xy, yz, zx, 0.0]))
    });

    // mv_trivector(xyz) - Create trivector/pseudoscalar (grade-3, represents oriented volume)
    define(interp, "mv_trivector", Some(1), |_, args| {
        let xyz = match &args[0] {
            Value::Float(f) => *f,
            Value::Int(n) => *n as f64,
            _ => 0.0,
        };
        Ok(make_multivector([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, xyz]))
    });

    // mv_add(a, b) - Add two multivectors
    define(interp, "mv_add", Some(2), |_, args| {
        let a = extract_multivector(&args[0], "mv_add")?;
        let b = extract_multivector(&args[1], "mv_add")?;
        Ok(make_multivector([
            a[0] + b[0],
            a[1] + b[1],
            a[2] + b[2],
            a[3] + b[3],
            a[4] + b[4],
            a[5] + b[5],
            a[6] + b[6],
            a[7] + b[7],
        ]))
    });

    // mv_sub(a, b) - Subtract two multivectors
    define(interp, "mv_sub", Some(2), |_, args| {
        let a = extract_multivector(&args[0], "mv_sub")?;
        let b = extract_multivector(&args[1], "mv_sub")?;
        Ok(make_multivector([
            a[0] - b[0],
            a[1] - b[1],
            a[2] - b[2],
            a[3] - b[3],
            a[4] - b[4],
            a[5] - b[5],
            a[6] - b[6],
            a[7] - b[7],
        ]))
    });

    // mv_scale(mv, scalar) - Scale a multivector
    define(interp, "mv_scale", Some(2), |_, args| {
        let a = extract_multivector(&args[0], "mv_scale")?;
        let s = match &args[1] {
            Value::Float(f) => *f,
            Value::Int(n) => *n as f64,
            _ => {
                return Err(RuntimeError::new(
                    "mv_scale: second argument must be number",
                ))
            }
        };
        Ok(make_multivector([
            a[0] * s,
            a[1] * s,
            a[2] * s,
            a[3] * s,
            a[4] * s,
            a[5] * s,
            a[6] * s,
            a[7] * s,
        ]))
    });

    // mv_geometric(a, b) - Geometric product (THE fundamental operation)
    // This is what makes GA powerful: ab = a·b + a∧b
    define(interp, "mv_geometric", Some(2), |_, args| {
        let a = extract_multivector(&args[0], "mv_geometric")?;
        let b = extract_multivector(&args[1], "mv_geometric")?;

        // Full geometric product in Cl(3,0,0)
        // Using: e₁² = e₂² = e₃² = 1, eᵢeⱼ = -eⱼeᵢ for i≠j
        let mut r = [0.0f64; 8];

        // Scalar part
        r[0] = a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3]
            - a[4] * b[4]
            - a[5] * b[5]
            - a[6] * b[6]
            - a[7] * b[7];

        // e₁ part
        r[1] = a[0] * b[1] + a[1] * b[0] - a[2] * b[4] + a[3] * b[6] + a[4] * b[2]
            - a[5] * b[7]
            - a[6] * b[3]
            - a[7] * b[5];

        // e₂ part
        r[2] = a[0] * b[2] + a[1] * b[4] + a[2] * b[0] - a[3] * b[5] - a[4] * b[1] + a[5] * b[3]
            - a[6] * b[7]
            - a[7] * b[6];

        // e₃ part
        r[3] = a[0] * b[3] - a[1] * b[6] + a[2] * b[5] + a[3] * b[0] - a[4] * b[7] - a[5] * b[2]
            + a[6] * b[1]
            - a[7] * b[4];

        // e₁₂ part
        r[4] = a[0] * b[4] + a[1] * b[2] - a[2] * b[1] + a[3] * b[7] + a[4] * b[0] + a[5] * b[6]
            - a[6] * b[5]
            + a[7] * b[3];

        // e₂₃ part
        r[5] = a[0] * b[5] + a[1] * b[7] + a[2] * b[3] - a[3] * b[2] - a[4] * b[6]
            + a[5] * b[0]
            + a[6] * b[4]
            + a[7] * b[1];

        // e₃₁ part
        r[6] = a[0] * b[6] - a[1] * b[3] + a[2] * b[7] + a[3] * b[1] + a[4] * b[5] - a[5] * b[4]
            + a[6] * b[0]
            + a[7] * b[2];

        // e₁₂₃ part
        r[7] = a[0] * b[7]
            + a[1] * b[5]
            + a[2] * b[6]
            + a[3] * b[4]
            + a[4] * b[3]
            + a[5] * b[1]
            + a[6] * b[2]
            + a[7] * b[0];

        Ok(make_multivector(r))
    });

    // mv_wedge(a, b) - Outer/wedge product (∧) - antisymmetric part
    // Creates higher-grade elements: vector ∧ vector = bivector
    define(interp, "mv_wedge", Some(2), |_, args| {
        let a = extract_multivector(&args[0], "mv_wedge")?;
        let b = extract_multivector(&args[1], "mv_wedge")?;

        let mut r = [0.0f64; 8];

        // Scalar ∧ anything = scalar * anything (grade 0)
        r[0] = a[0] * b[0];

        // Vector parts (grade 1): s∧v + v∧s
        r[1] = a[0] * b[1] + a[1] * b[0];
        r[2] = a[0] * b[2] + a[2] * b[0];
        r[3] = a[0] * b[3] + a[3] * b[0];

        // Bivector parts (grade 2): s∧B + v∧v + B∧s
        r[4] = a[0] * b[4] + a[1] * b[2] - a[2] * b[1] + a[4] * b[0];
        r[5] = a[0] * b[5] + a[2] * b[3] - a[3] * b[2] + a[5] * b[0];
        r[6] = a[0] * b[6] + a[3] * b[1] - a[1] * b[3] + a[6] * b[0];

        // Trivector part (grade 3): s∧T + v∧B + B∧v + T∧s
        r[7] = a[0] * b[7] + a[7] * b[0] + a[1] * b[5] + a[2] * b[6] + a[3] * b[4]
            - a[4] * b[3]
            - a[5] * b[1]
            - a[6] * b[2];

        Ok(make_multivector(r))
    });

    // mv_inner(a, b) - Inner/dot product (⟂) - symmetric contraction
    // Lowers grade: vector · vector = scalar, bivector · vector = vector
    define(interp, "mv_inner", Some(2), |_, args| {
        let a = extract_multivector(&args[0], "mv_inner")?;
        let b = extract_multivector(&args[1], "mv_inner")?;

        let mut r = [0.0f64; 8];

        // Left contraction formula
        // Scalar (vectors dotted)
        r[0] = a[1] * b[1] + a[2] * b[2] + a[3] * b[3]
            - a[4] * b[4]
            - a[5] * b[5]
            - a[6] * b[6]
            - a[7] * b[7];

        // Vector parts (bivector · vector)
        r[1] = a[4] * b[2] - a[6] * b[3] - a[5] * b[7];
        r[2] = -a[4] * b[1] + a[5] * b[3] - a[6] * b[7];
        r[3] = a[6] * b[1] - a[5] * b[2] - a[4] * b[7];

        // Bivector parts (trivector · vector)
        r[4] = a[7] * b[3];
        r[5] = a[7] * b[1];
        r[6] = a[7] * b[2];

        Ok(make_multivector(r))
    });

    // mv_reverse(a) - Reverse (†) - reverses order of basis vectors
    // (e₁e₂)† = e₂e₁ = -e₁e₂
    define(interp, "mv_reverse", Some(1), |_, args| {
        let a = extract_multivector(&args[0], "mv_reverse")?;
        // Grade 0,1 unchanged; Grade 2,3 negated
        Ok(make_multivector([
            a[0], a[1], a[2], a[3], -a[4], -a[5], -a[6], -a[7],
        ]))
    });

    // mv_dual(a) - Dual (Hodge star) - multiply by pseudoscalar
    // Maps grade k to grade (n-k) in n dimensions
    define(interp, "mv_dual", Some(1), |_, args| {
        let a = extract_multivector(&args[0], "mv_dual")?;
        // In 3D: dual(1) = e123, dual(e1) = e23, etc.
        // Multiplying by e123: since e123² = -1 in Cl(3,0,0)
        Ok(make_multivector([
            -a[7], // s ← -e123
            -a[5], // e1 ← -e23
            -a[6], // e2 ← -e31
            -a[4], // e3 ← -e12
            a[3],  // e12 ← e3
            a[1],  // e23 ← e1
            a[2],  // e31 ← e2
            a[0],  // e123 ← s
        ]))
    });

    // mv_magnitude(a) - Magnitude/norm of multivector
    define(interp, "mv_magnitude", Some(1), |_, args| {
        let a = extract_multivector(&args[0], "mv_magnitude")?;
        let mag_sq = a[0] * a[0]
            + a[1] * a[1]
            + a[2] * a[2]
            + a[3] * a[3]
            + a[4] * a[4]
            + a[5] * a[5]
            + a[6] * a[6]
            + a[7] * a[7];
        Ok(Value::Float(mag_sq.sqrt()))
    });

    // mv_normalize(a) - Normalize multivector
    define(interp, "mv_normalize", Some(1), |_, args| {
        let a = extract_multivector(&args[0], "mv_normalize")?;
        let mag = (a[0] * a[0]
            + a[1] * a[1]
            + a[2] * a[2]
            + a[3] * a[3]
            + a[4] * a[4]
            + a[5] * a[5]
            + a[6] * a[6]
            + a[7] * a[7])
            .sqrt();
        if mag < 1e-10 {
            return Ok(make_multivector([0.0; 8]));
        }
        Ok(make_multivector([
            a[0] / mag,
            a[1] / mag,
            a[2] / mag,
            a[3] / mag,
            a[4] / mag,
            a[5] / mag,
            a[6] / mag,
            a[7] / mag,
        ]))
    });

    // rotor_from_axis_angle(axis, angle) - Create rotor from axis-angle
    // Rotor R = cos(θ/2) + sin(θ/2) * B where B is the normalized bivector plane
    define(interp, "rotor_from_axis_angle", Some(2), |_, args| {
        let axis = extract_vec3(&args[0], "rotor_from_axis_angle")?;
        let angle = match &args[1] {
            Value::Float(f) => *f,
            Value::Int(n) => *n as f64,
            _ => {
                return Err(RuntimeError::new(
                    "rotor_from_axis_angle: angle must be number",
                ))
            }
        };

        // Normalize axis
        let len = (axis[0] * axis[0] + axis[1] * axis[1] + axis[2] * axis[2]).sqrt();
        if len < 1e-10 {
            // Return identity rotor
            return Ok(make_multivector([1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]));
        }
        let (nx, ny, nz) = (axis[0] / len, axis[1] / len, axis[2] / len);

        let half_angle = angle / 2.0;
        let (s, c) = half_angle.sin_cos();

        // Rotor: cos(θ/2) - sin(θ/2) * (n₁e₂₃ + n₂e₃₁ + n₃e₁₂)
        // Note: axis maps to bivector via dual
        Ok(make_multivector([
            c, // scalar
            0.0,
            0.0,
            0.0,     // no vector part
            -s * nz, // e12 (axis z → bivector xy)
            -s * nx, // e23 (axis x → bivector yz)
            -s * ny, // e31 (axis y → bivector zx)
            0.0,     // no trivector
        ]))
    });

    // rotor_apply(rotor, vector) - Apply rotor to vector: RvR†
    // This is the sandwich product - THE way to rotate in GA
    define(interp, "rotor_apply", Some(2), |_, args| {
        let r = extract_multivector(&args[0], "rotor_apply")?;
        let v = extract_vec3(&args[1], "rotor_apply")?;

        // Create vector multivector
        let v_mv = [0.0, v[0], v[1], v[2], 0.0, 0.0, 0.0, 0.0];

        // Compute R† (reverse of rotor)
        let r_rev = [r[0], r[1], r[2], r[3], -r[4], -r[5], -r[6], -r[7]];

        // First: R * v
        let mut rv = [0.0f64; 8];
        rv[0] = r[0] * v_mv[0] + r[1] * v_mv[1] + r[2] * v_mv[2] + r[3] * v_mv[3]
            - r[4] * v_mv[4]
            - r[5] * v_mv[5]
            - r[6] * v_mv[6]
            - r[7] * v_mv[7];
        rv[1] = r[0] * v_mv[1] + r[1] * v_mv[0] - r[2] * v_mv[4] + r[3] * v_mv[6] + r[4] * v_mv[2]
            - r[5] * v_mv[7]
            - r[6] * v_mv[3]
            - r[7] * v_mv[5];
        rv[2] = r[0] * v_mv[2] + r[1] * v_mv[4] + r[2] * v_mv[0] - r[3] * v_mv[5] - r[4] * v_mv[1]
            + r[5] * v_mv[3]
            - r[6] * v_mv[7]
            - r[7] * v_mv[6];
        rv[3] = r[0] * v_mv[3] - r[1] * v_mv[6] + r[2] * v_mv[5] + r[3] * v_mv[0]
            - r[4] * v_mv[7]
            - r[5] * v_mv[2]
            + r[6] * v_mv[1]
            - r[7] * v_mv[4];
        rv[4] = r[0] * v_mv[4] + r[1] * v_mv[2] - r[2] * v_mv[1]
            + r[3] * v_mv[7]
            + r[4] * v_mv[0]
            + r[5] * v_mv[6]
            - r[6] * v_mv[5]
            + r[7] * v_mv[3];
        rv[5] = r[0] * v_mv[5] + r[1] * v_mv[7] + r[2] * v_mv[3] - r[3] * v_mv[2] - r[4] * v_mv[6]
            + r[5] * v_mv[0]
            + r[6] * v_mv[4]
            + r[7] * v_mv[1];
        rv[6] = r[0] * v_mv[6] - r[1] * v_mv[3] + r[2] * v_mv[7] + r[3] * v_mv[1] + r[4] * v_mv[5]
            - r[5] * v_mv[4]
            + r[6] * v_mv[0]
            + r[7] * v_mv[2];
        rv[7] = r[0] * v_mv[7]
            + r[1] * v_mv[5]
            + r[2] * v_mv[6]
            + r[3] * v_mv[4]
            + r[4] * v_mv[3]
            + r[5] * v_mv[1]
            + r[6] * v_mv[2]
            + r[7] * v_mv[0];

        // Then: (R * v) * R†
        let mut result = [0.0f64; 8];
        result[1] = rv[0] * r_rev[1] + rv[1] * r_rev[0] - rv[2] * r_rev[4]
            + rv[3] * r_rev[6]
            + rv[4] * r_rev[2]
            - rv[5] * r_rev[7]
            - rv[6] * r_rev[3]
            - rv[7] * r_rev[5];
        result[2] = rv[0] * r_rev[2] + rv[1] * r_rev[4] + rv[2] * r_rev[0]
            - rv[3] * r_rev[5]
            - rv[4] * r_rev[1]
            + rv[5] * r_rev[3]
            - rv[6] * r_rev[7]
            - rv[7] * r_rev[6];
        result[3] = rv[0] * r_rev[3] - rv[1] * r_rev[6] + rv[2] * r_rev[5] + rv[3] * r_rev[0]
            - rv[4] * r_rev[7]
            - rv[5] * r_rev[2]
            + rv[6] * r_rev[1]
            - rv[7] * r_rev[4];

        // Return as vec3
        Ok(make_vec3(result[1], result[2], result[3]))
    });

    // rotor_compose(r1, r2) - Compose rotors: R1 * R2
    define(interp, "rotor_compose", Some(2), |_, args| {
        let a = extract_multivector(&args[0], "rotor_compose")?;
        let b = extract_multivector(&args[1], "rotor_compose")?;

        // Same as geometric product
        let mut r = [0.0f64; 8];
        r[0] = a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3]
            - a[4] * b[4]
            - a[5] * b[5]
            - a[6] * b[6]
            - a[7] * b[7];
        r[1] = a[0] * b[1] + a[1] * b[0] - a[2] * b[4] + a[3] * b[6] + a[4] * b[2]
            - a[5] * b[7]
            - a[6] * b[3]
            - a[7] * b[5];
        r[2] = a[0] * b[2] + a[1] * b[4] + a[2] * b[0] - a[3] * b[5] - a[4] * b[1] + a[5] * b[3]
            - a[6] * b[7]
            - a[7] * b[6];
        r[3] = a[0] * b[3] - a[1] * b[6] + a[2] * b[5] + a[3] * b[0] - a[4] * b[7] - a[5] * b[2]
            + a[6] * b[1]
            - a[7] * b[4];
        r[4] = a[0] * b[4] + a[1] * b[2] - a[2] * b[1] + a[3] * b[7] + a[4] * b[0] + a[5] * b[6]
            - a[6] * b[5]
            + a[7] * b[3];
        r[5] = a[0] * b[5] + a[1] * b[7] + a[2] * b[3] - a[3] * b[2] - a[4] * b[6]
            + a[5] * b[0]
            + a[6] * b[4]
            + a[7] * b[1];
        r[6] = a[0] * b[6] - a[1] * b[3] + a[2] * b[7] + a[3] * b[1] + a[4] * b[5] - a[5] * b[4]
            + a[6] * b[0]
            + a[7] * b[2];
        r[7] = a[0] * b[7]
            + a[1] * b[5]
            + a[2] * b[6]
            + a[3] * b[4]
            + a[4] * b[3]
            + a[5] * b[1]
            + a[6] * b[2]
            + a[7] * b[0];

        Ok(make_multivector(r))
    });

    // mv_reflect(v, n) - Reflect vector v in plane with normal n
    // Reflection: -n * v * n (sandwich with negative)
    define(interp, "mv_reflect", Some(2), |_, args| {
        let v = extract_vec3(&args[0], "mv_reflect")?;
        let n = extract_vec3(&args[1], "mv_reflect")?;

        // Normalize n
        let len = (n[0] * n[0] + n[1] * n[1] + n[2] * n[2]).sqrt();
        if len < 1e-10 {
            return Ok(make_vec3(v[0], v[1], v[2]));
        }
        let (nx, ny, nz) = (n[0] / len, n[1] / len, n[2] / len);

        // v - 2(v·n)n
        let dot = v[0] * nx + v[1] * ny + v[2] * nz;
        Ok(make_vec3(
            v[0] - 2.0 * dot * nx,
            v[1] - 2.0 * dot * ny,
            v[2] - 2.0 * dot * nz,
        ))
    });

    // mv_project(v, n) - Project vector v onto plane with normal n
    define(interp, "mv_project", Some(2), |_, args| {
        let v = extract_vec3(&args[0], "mv_project")?;
        let n = extract_vec3(&args[1], "mv_project")?;

        let len = (n[0] * n[0] + n[1] * n[1] + n[2] * n[2]).sqrt();
        if len < 1e-10 {
            return Ok(make_vec3(v[0], v[1], v[2]));
        }
        let (nx, ny, nz) = (n[0] / len, n[1] / len, n[2] / len);

        // v - (v·n)n
        let dot = v[0] * nx + v[1] * ny + v[2] * nz;
        Ok(make_vec3(v[0] - dot * nx, v[1] - dot * ny, v[2] - dot * nz))
    });

    // mv_grade(mv, k) - Extract grade-k part of multivector
    define(interp, "mv_grade", Some(2), |_, args| {
        let a = extract_multivector(&args[0], "mv_grade")?;
        let k = match &args[1] {
            Value::Int(n) => *n,
            _ => return Err(RuntimeError::new("mv_grade: grade must be integer")),
        };

        match k {
            0 => Ok(make_multivector([a[0], 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0])),
            1 => Ok(make_multivector([
                0.0, a[1], a[2], a[3], 0.0, 0.0, 0.0, 0.0,
            ])),
            2 => Ok(make_multivector([
                0.0, 0.0, 0.0, 0.0, a[4], a[5], a[6], 0.0,
            ])),
            3 => Ok(make_multivector([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, a[7]])),
            _ => Ok(make_multivector([0.0; 8])),
        }
    });
}

// ============================================================================
// DIMENSIONAL ANALYSIS (Unit-aware arithmetic)
// ============================================================================
// Automatic unit tracking and conversion - catch physics errors at runtime
// Base SI units: m (length), kg (mass), s (time), A (current), K (temperature), mol, cd

fn register_dimensional(interp: &mut Interpreter) {
    // Helper to create a quantity with units
    // Units stored as exponents: [m, kg, s, A, K, mol, cd]
    fn make_quantity(value: f64, units: [i32; 7]) -> Value {
        let mut q = HashMap::new();
        q.insert("value".to_string(), Value::Float(value));
        q.insert("m".to_string(), Value::Int(units[0] as i64)); // meters
        q.insert("kg".to_string(), Value::Int(units[1] as i64)); // kilograms
        q.insert("s".to_string(), Value::Int(units[2] as i64)); // seconds
        q.insert("A".to_string(), Value::Int(units[3] as i64)); // amperes
        q.insert("K".to_string(), Value::Int(units[4] as i64)); // kelvin
        q.insert("mol".to_string(), Value::Int(units[5] as i64)); // moles
        q.insert("cd".to_string(), Value::Int(units[6] as i64)); // candela
        q.insert(
            "_type".to_string(),
            Value::String(Rc::new("quantity".to_string())),
        );
        Value::Map(Rc::new(RefCell::new(q)))
    }

    fn extract_quantity(v: &Value, fn_name: &str) -> Result<(f64, [i32; 7]), RuntimeError> {
        match v {
            Value::Map(map) => {
                let map = map.borrow();
                let value = match map.get("value") {
                    Some(Value::Float(f)) => *f,
                    Some(Value::Int(n)) => *n as f64,
                    _ => return Err(RuntimeError::new(format!("{}: missing value", fn_name))),
                };
                let get_exp = |key: &str| -> i32 {
                    match map.get(key) {
                        Some(Value::Int(n)) => *n as i32,
                        _ => 0,
                    }
                };
                Ok((
                    value,
                    [
                        get_exp("m"),
                        get_exp("kg"),
                        get_exp("s"),
                        get_exp("A"),
                        get_exp("K"),
                        get_exp("mol"),
                        get_exp("cd"),
                    ],
                ))
            }
            Value::Float(f) => Ok((*f, [0; 7])),
            Value::Int(n) => Ok((*n as f64, [0; 7])),
            _ => Err(RuntimeError::new(format!(
                "{}: expected quantity or number",
                fn_name
            ))),
        }
    }

    fn units_to_string(units: [i32; 7]) -> String {
        let names = ["m", "kg", "s", "A", "K", "mol", "cd"];
        let mut parts = Vec::new();
        for (i, &exp) in units.iter().enumerate() {
            if exp == 1 {
                parts.push(names[i].to_string());
            } else if exp != 0 {
                parts.push(format!("{}^{}", names[i], exp));
            }
        }
        if parts.is_empty() {
            "dimensionless".to_string()
        } else {
            parts.join("·")
        }
    }

    // qty(value, unit_string) - Create quantity with units
    // e.g., qty(9.8, "m/s^2") for acceleration
    define(interp, "qty", Some(2), |_, args| {
        let value = match &args[0] {
            Value::Float(f) => *f,
            Value::Int(n) => *n as f64,
            _ => return Err(RuntimeError::new("qty: first argument must be number")),
        };
        let unit_str = match &args[1] {
            Value::String(s) => s.to_string(),
            _ => {
                return Err(RuntimeError::new(
                    "qty: second argument must be unit string",
                ))
            }
        };

        // Parse unit string
        let mut units = [0i32; 7];
        // Simplified: if '/' present, treat everything as denominator
        // For proper parsing, would need to track position relative to '/'
        let in_denominator = unit_str.contains('/');

        // Simple parser for common units
        for part in unit_str.split(|c: char| c == '*' || c == '·' || c == ' ') {
            let part = part.trim();
            if part.is_empty() {
                continue;
            }

            let (base, exp) = if let Some(idx) = part.find('^') {
                let (b, e) = part.split_at(idx);
                (b, e[1..].parse::<i32>().unwrap_or(1))
            } else if part.contains('/') {
                // Handle division inline
                continue;
            } else {
                (part, 1)
            };

            let sign = if in_denominator { -1 } else { 1 };
            match base {
                "m" | "meter" | "meters" => units[0] += exp * sign,
                "kg" | "kilogram" | "kilograms" => units[1] += exp * sign,
                "s" | "sec" | "second" | "seconds" => units[2] += exp * sign,
                "A" | "amp" | "ampere" | "amperes" => units[3] += exp * sign,
                "K" | "kelvin" => units[4] += exp * sign,
                "mol" | "mole" | "moles" => units[5] += exp * sign,
                "cd" | "candela" => units[6] += exp * sign,
                // Derived units
                "N" | "newton" | "newtons" => {
                    units[1] += sign;
                    units[0] += sign;
                    units[2] -= 2 * sign;
                }
                "J" | "joule" | "joules" => {
                    units[1] += sign;
                    units[0] += 2 * sign;
                    units[2] -= 2 * sign;
                }
                "W" | "watt" | "watts" => {
                    units[1] += sign;
                    units[0] += 2 * sign;
                    units[2] -= 3 * sign;
                }
                "Pa" | "pascal" | "pascals" => {
                    units[1] += sign;
                    units[0] -= sign;
                    units[2] -= 2 * sign;
                }
                "Hz" | "hertz" => {
                    units[2] -= sign;
                }
                "C" | "coulomb" | "coulombs" => {
                    units[3] += sign;
                    units[2] += sign;
                }
                "V" | "volt" | "volts" => {
                    units[1] += sign;
                    units[0] += 2 * sign;
                    units[2] -= 3 * sign;
                    units[3] -= sign;
                }
                "Ω" | "ohm" | "ohms" => {
                    units[1] += sign;
                    units[0] += 2 * sign;
                    units[2] -= 3 * sign;
                    units[3] -= 2 * sign;
                }
                _ => {}
            }
        }

        Ok(make_quantity(value, units))
    });

    // qty_add(a, b) - Add quantities (must have same units)
    define(interp, "qty_add", Some(2), |_, args| {
        let (val_a, units_a) = extract_quantity(&args[0], "qty_add")?;
        let (val_b, units_b) = extract_quantity(&args[1], "qty_add")?;

        if units_a != units_b {
            return Err(RuntimeError::new(format!(
                "qty_add: unit mismatch: {} vs {}",
                units_to_string(units_a),
                units_to_string(units_b)
            )));
        }

        Ok(make_quantity(val_a + val_b, units_a))
    });

    // qty_sub(a, b) - Subtract quantities (must have same units)
    define(interp, "qty_sub", Some(2), |_, args| {
        let (val_a, units_a) = extract_quantity(&args[0], "qty_sub")?;
        let (val_b, units_b) = extract_quantity(&args[1], "qty_sub")?;

        if units_a != units_b {
            return Err(RuntimeError::new(format!(
                "qty_sub: unit mismatch: {} vs {}",
                units_to_string(units_a),
                units_to_string(units_b)
            )));
        }

        Ok(make_quantity(val_a - val_b, units_a))
    });

    // qty_mul(a, b) - Multiply quantities (units add)
    define(interp, "qty_mul", Some(2), |_, args| {
        let (val_a, units_a) = extract_quantity(&args[0], "qty_mul")?;
        let (val_b, units_b) = extract_quantity(&args[1], "qty_mul")?;

        let mut result_units = [0i32; 7];
        for i in 0..7 {
            result_units[i] = units_a[i] + units_b[i];
        }

        Ok(make_quantity(val_a * val_b, result_units))
    });

    // qty_div(a, b) - Divide quantities (units subtract)
    define(interp, "qty_div", Some(2), |_, args| {
        let (val_a, units_a) = extract_quantity(&args[0], "qty_div")?;
        let (val_b, units_b) = extract_quantity(&args[1], "qty_div")?;

        if val_b.abs() < 1e-15 {
            return Err(RuntimeError::new("qty_div: division by zero"));
        }

        let mut result_units = [0i32; 7];
        for i in 0..7 {
            result_units[i] = units_a[i] - units_b[i];
        }

        Ok(make_quantity(val_a / val_b, result_units))
    });

    // qty_pow(q, n) - Raise quantity to power (units multiply)
    define(interp, "qty_pow", Some(2), |_, args| {
        let (val, units) = extract_quantity(&args[0], "qty_pow")?;
        let n = match &args[1] {
            Value::Int(n) => *n as i32,
            Value::Float(f) => *f as i32,
            _ => return Err(RuntimeError::new("qty_pow: exponent must be number")),
        };

        let mut result_units = [0i32; 7];
        for i in 0..7 {
            result_units[i] = units[i] * n;
        }

        Ok(make_quantity(val.powi(n), result_units))
    });

    // qty_sqrt(q) - Square root of quantity (units halve)
    define(interp, "qty_sqrt", Some(1), |_, args| {
        let (val, units) = extract_quantity(&args[0], "qty_sqrt")?;

        // Check that all exponents are even
        for (i, &exp) in units.iter().enumerate() {
            if exp % 2 != 0 {
                let names = ["m", "kg", "s", "A", "K", "mol", "cd"];
                return Err(RuntimeError::new(format!(
                    "qty_sqrt: cannot take sqrt of {} (odd exponent on {})",
                    units_to_string(units),
                    names[i]
                )));
            }
        }

        let mut result_units = [0i32; 7];
        for i in 0..7 {
            result_units[i] = units[i] / 2;
        }

        Ok(make_quantity(val.sqrt(), result_units))
    });

    // qty_value(q) - Get numeric value of quantity
    define(interp, "qty_value", Some(1), |_, args| {
        let (val, _) = extract_quantity(&args[0], "qty_value")?;
        Ok(Value::Float(val))
    });

    // qty_units(q) - Get units as string
    define(interp, "qty_units", Some(1), |_, args| {
        let (_, units) = extract_quantity(&args[0], "qty_units")?;
        Ok(Value::String(Rc::new(units_to_string(units))))
    });

    // qty_convert(q, target_units) - Convert to different units
    // Currently just validates compatible dimensions
    define(interp, "qty_convert", Some(2), |_, args| {
        let (val, units) = extract_quantity(&args[0], "qty_convert")?;
        let _target = match &args[1] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("qty_convert: target must be unit string")),
        };

        // For now, just return with same value if dimensions match
        // A full implementation would handle unit prefixes (kilo, milli, etc.)
        Ok(make_quantity(val, units))
    });

    // qty_check(q, expected_units) - Check if quantity has expected dimensions
    define(interp, "qty_check", Some(2), |_, args| {
        let (_, units) = extract_quantity(&args[0], "qty_check")?;
        let expected = match &args[1] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("qty_check: expected string")),
        };

        // Quick dimension check by comparing unit string patterns
        let actual_str = units_to_string(units);
        Ok(Value::Bool(
            actual_str.contains(&expected) || expected.contains(&actual_str),
        ))
    });

    // Common physical constants with units
    // c - speed of light
    define(interp, "c_light", Some(0), |_, _| {
        Ok(make_quantity(299792458.0, [1, 0, -1, 0, 0, 0, 0])) // m/s
    });

    // G - gravitational constant
    define(interp, "G_gravity", Some(0), |_, _| {
        Ok(make_quantity(6.67430e-11, [3, -1, -2, 0, 0, 0, 0])) // m³/(kg·s²)
    });

    // h - Planck constant
    define(interp, "h_planck", Some(0), |_, _| {
        Ok(make_quantity(6.62607015e-34, [2, 1, -1, 0, 0, 0, 0])) // J·s = m²·kg/s
    });

    // e - elementary charge
    define(interp, "e_charge", Some(0), |_, _| {
        Ok(make_quantity(1.602176634e-19, [0, 0, 1, 1, 0, 0, 0])) // C = A·s
    });

    // k_B - Boltzmann constant
    define(interp, "k_boltzmann", Some(0), |_, _| {
        Ok(make_quantity(1.380649e-23, [2, 1, -2, 0, -1, 0, 0])) // J/K = m²·kg/(s²·K)
    });
}

// ============================================================================
// ENTITY COMPONENT SYSTEM (ECS)
// ============================================================================
//
// A lightweight Entity Component System for game development and simulations.
// ECS separates data (components) from behavior (systems) for maximum flexibility.
//
// ## Core Concepts
//
// | Concept | Description |
// |---------|-------------|
// | World | Container for all entities and components |
// | Entity | Unique ID representing a game object |
// | Component | Data attached to an entity (position, velocity, health) |
// | Query | Retrieve entities with specific components |
//
// ## Available Functions
//
// ### World Management
// | Function | Description |
// |----------|-------------|
// | `ecs_world()` | Create a new ECS world |
// | `ecs_count(world)` | Count total entities |
//
// ### Entity Management
// | Function | Description |
// |----------|-------------|
// | `ecs_spawn(world)` | Create entity, returns ID |
// | `ecs_despawn(world, id)` | Remove entity and components |
// | `ecs_exists(world, id)` | Check if entity exists |
//
// ### Component Management
// | Function | Description |
// |----------|-------------|
// | `ecs_attach(world, id, name, data)` | Add component to entity |
// | `ecs_detach(world, id, name)` | Remove component |
// | `ecs_get(world, id, name)` | Get component data |
// | `ecs_has(world, id, name)` | Check if entity has component |
//
// ### Querying
// | Function | Description |
// |----------|-------------|
// | `ecs_query(world, ...names)` | Find entities with all listed components |
// | `ecs_query_any(world, ...names)` | Find entities with any listed component |
//
// ## Usage Example
//
// ```sigil
// // Create world and entities
// let world = ecs_world();
// let player = ecs_spawn(world);
// let enemy = ecs_spawn(world);
//
// // Attach components
// ecs_attach(world, player, "Position", vec3(0, 0, 0));
// ecs_attach(world, player, "Velocity", vec3(1, 0, 0));
// ecs_attach(world, player, "Health", 100);
//
// ecs_attach(world, enemy, "Position", vec3(10, 0, 0));
// ecs_attach(world, enemy, "Health", 50);
//
// // Query all entities with Position and Health
// let living = ecs_query(world, "Position", "Health");
// // Returns [player_id, enemy_id]
//
// // Update loop
// for id in ecs_query(world, "Position", "Velocity") {
//     let pos = ecs_get(world, id, "Position");
//     let vel = ecs_get(world, id, "Velocity");
//     ecs_attach(world, id, "Position", vec3_add(pos, vel));
// }
// ```
//
// ## Performance Notes
//
// - Queries are O(entities) - for large worlds, consider caching results
// - Component access is O(1) via hash lookup
// - Entity spawning is O(1)

fn register_ecs(interp: &mut Interpreter) {
    // ecs_world() - Create new ECS world
    define(interp, "ecs_world", Some(0), |_, _| {
        let mut world = HashMap::new();
        world.insert(
            "_type".to_string(),
            Value::String(Rc::new("ecs_world".to_string())),
        );
        world.insert("next_id".to_string(), Value::Int(0));
        world.insert(
            "entities".to_string(),
            Value::Map(Rc::new(RefCell::new(HashMap::new()))),
        );
        world.insert(
            "components".to_string(),
            Value::Map(Rc::new(RefCell::new(HashMap::new()))),
        );
        Ok(Value::Map(Rc::new(RefCell::new(world))))
    });

    // ecs_spawn(world) - Spawn new entity, returns entity ID
    define(interp, "ecs_spawn", Some(1), |_, args| {
        let world = match &args[0] {
            Value::Map(m) => m.clone(),
            _ => return Err(RuntimeError::new("ecs_spawn: expected world")),
        };

        let mut world_ref = world.borrow_mut();
        let id = match world_ref.get("next_id") {
            Some(Value::Int(n)) => *n,
            _ => 0,
        };

        // Increment next_id
        world_ref.insert("next_id".to_string(), Value::Int(id + 1));

        // Add to entities set
        if let Some(Value::Map(entities)) = world_ref.get("entities") {
            entities
                .borrow_mut()
                .insert(id.to_string(), Value::Bool(true));
        }

        Ok(Value::Int(id))
    });

    // ecs_despawn(world, entity_id) - Remove entity and all its components
    define(interp, "ecs_despawn", Some(2), |_, args| {
        let world = match &args[0] {
            Value::Map(m) => m.clone(),
            _ => return Err(RuntimeError::new("ecs_despawn: expected world")),
        };
        let id = match &args[1] {
            Value::Int(n) => *n,
            _ => return Err(RuntimeError::new("ecs_despawn: expected entity id")),
        };

        let world_ref = world.borrow();

        // Remove from entities
        if let Some(Value::Map(entities)) = world_ref.get("entities") {
            entities.borrow_mut().remove(&id.to_string());
        }

        // Remove all components for this entity
        if let Some(Value::Map(components)) = world_ref.get("components") {
            let comps = components.borrow();
            for (_, comp_storage) in comps.iter() {
                if let Value::Map(storage) = comp_storage {
                    storage.borrow_mut().remove(&id.to_string());
                }
            }
        }

        Ok(Value::Bool(true))
    });

    // ecs_attach(world, entity_id, component_name, data) - Add component to entity
    define(interp, "ecs_attach", Some(4), |_, args| {
        let world = match &args[0] {
            Value::Map(m) => m.clone(),
            _ => {
                return Err(RuntimeError::new(
                    "ecs_attach() expects a world as first argument.\n\
                 Usage: ecs_attach(world, entity_id, component_name, data)\n\
                 Example:\n\
                   let world = ecs_world();\n\
                   let e = ecs_spawn(world);\n\
                   ecs_attach(world, e, \"Position\", vec3(0, 0, 0));",
                ))
            }
        };
        let id = match &args[1] {
            Value::Int(n) => *n,
            _ => {
                return Err(RuntimeError::new(
                    "ecs_attach() expects an entity ID (integer) as second argument.\n\
                 Entity IDs are returned by ecs_spawn().\n\
                 Example:\n\
                   let entity = ecs_spawn(world);  // Returns 0, 1, 2...\n\
                   ecs_attach(world, entity, \"Health\", 100);",
                ))
            }
        };
        let comp_name = match &args[2] {
            Value::String(s) => s.to_string(),
            _ => {
                return Err(RuntimeError::new(
                    "ecs_attach() expects a string component name as third argument.\n\
                 Common component names: \"Position\", \"Velocity\", \"Health\", \"Sprite\"\n\
                 Example: ecs_attach(world, entity, \"Position\", vec3(0, 0, 0));",
                ))
            }
        };
        let data = args[3].clone();

        let world_ref = world.borrow();

        // Get or create component storage
        if let Some(Value::Map(components)) = world_ref.get("components") {
            let mut comps = components.borrow_mut();

            let storage = comps
                .entry(comp_name.clone())
                .or_insert_with(|| Value::Map(Rc::new(RefCell::new(HashMap::new()))));

            if let Value::Map(storage_map) = storage {
                storage_map.borrow_mut().insert(id.to_string(), data);
            }
        }

        Ok(Value::Bool(true))
    });

    // ecs_get(world, entity_id, component_name) - Get component data
    define(interp, "ecs_get", Some(3), |_, args| {
        let world = match &args[0] {
            Value::Map(m) => m.clone(),
            _ => return Err(RuntimeError::new("ecs_get: expected world")),
        };
        let id = match &args[1] {
            Value::Int(n) => *n,
            _ => return Err(RuntimeError::new("ecs_get: expected entity id")),
        };
        let comp_name = match &args[2] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("ecs_get: expected component name")),
        };

        let world_ref = world.borrow();

        if let Some(Value::Map(components)) = world_ref.get("components") {
            let comps = components.borrow();
            if let Some(Value::Map(storage)) = comps.get(&comp_name) {
                if let Some(data) = storage.borrow().get(&id.to_string()) {
                    return Ok(data.clone());
                }
            }
        }

        Ok(Value::Null)
    });

    // ecs_has(world, entity_id, component_name) - Check if entity has component
    define(interp, "ecs_has", Some(3), |_, args| {
        let world = match &args[0] {
            Value::Map(m) => m.clone(),
            _ => return Err(RuntimeError::new("ecs_has: expected world")),
        };
        let id = match &args[1] {
            Value::Int(n) => *n,
            _ => return Err(RuntimeError::new("ecs_has: expected entity id")),
        };
        let comp_name = match &args[2] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("ecs_has: expected component name")),
        };

        let world_ref = world.borrow();

        if let Some(Value::Map(components)) = world_ref.get("components") {
            let comps = components.borrow();
            if let Some(Value::Map(storage)) = comps.get(&comp_name) {
                return Ok(Value::Bool(storage.borrow().contains_key(&id.to_string())));
            }
        }

        Ok(Value::Bool(false))
    });

    // ecs_remove(world, entity_id, component_name) - Remove component from entity
    define(interp, "ecs_remove", Some(3), |_, args| {
        let world = match &args[0] {
            Value::Map(m) => m.clone(),
            _ => return Err(RuntimeError::new("ecs_remove: expected world")),
        };
        let id = match &args[1] {
            Value::Int(n) => *n,
            _ => return Err(RuntimeError::new("ecs_remove: expected entity id")),
        };
        let comp_name = match &args[2] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("ecs_remove: expected component name")),
        };

        let world_ref = world.borrow();

        if let Some(Value::Map(components)) = world_ref.get("components") {
            let comps = components.borrow();
            if let Some(Value::Map(storage)) = comps.get(&comp_name) {
                storage.borrow_mut().remove(&id.to_string());
                return Ok(Value::Bool(true));
            }
        }

        Ok(Value::Bool(false))
    });

    // ecs_query(world, component_names...) - Get all entities with all specified components
    // Returns array of entity IDs
    define(interp, "ecs_query", None, |_, args| {
        if args.is_empty() {
            return Err(RuntimeError::new(
                "ecs_query: expected at least world argument",
            ));
        }

        let world = match &args[0] {
            Value::Map(m) => m.clone(),
            _ => return Err(RuntimeError::new("ecs_query: expected world")),
        };

        let comp_names: Vec<String> = args[1..]
            .iter()
            .filter_map(|a| match a {
                Value::String(s) => Some(s.to_string()),
                _ => None,
            })
            .collect();

        if comp_names.is_empty() {
            // Return all entities
            let world_ref = world.borrow();
            if let Some(Value::Map(entities)) = world_ref.get("entities") {
                let result: Vec<Value> = entities
                    .borrow()
                    .keys()
                    .filter_map(|k| k.parse::<i64>().ok().map(Value::Int))
                    .collect();
                return Ok(Value::Array(Rc::new(RefCell::new(result))));
            }
            return Ok(Value::Array(Rc::new(RefCell::new(vec![]))));
        }

        let world_ref = world.borrow();
        let mut result_ids: Option<Vec<String>> = None;

        if let Some(Value::Map(components)) = world_ref.get("components") {
            let comps = components.borrow();

            for comp_name in &comp_names {
                if let Some(Value::Map(storage)) = comps.get(comp_name) {
                    let keys: Vec<String> = storage.borrow().keys().cloned().collect();

                    result_ids = Some(match result_ids {
                        None => keys,
                        Some(existing) => {
                            existing.into_iter().filter(|k| keys.contains(k)).collect()
                        }
                    });
                } else {
                    // Component type doesn't exist, no entities match
                    return Ok(Value::Array(Rc::new(RefCell::new(vec![]))));
                }
            }
        }

        let result: Vec<Value> = result_ids
            .unwrap_or_default()
            .iter()
            .filter_map(|k| k.parse::<i64>().ok().map(Value::Int))
            .collect();

        Ok(Value::Array(Rc::new(RefCell::new(result))))
    });

    // ecs_query_with(world, component_names, callback) - Iterate over matching entities
    // Callback receives (entity_id, components_map)
    define(interp, "ecs_query_with", Some(3), |interp, args| {
        let world = match &args[0] {
            Value::Map(m) => m.clone(),
            _ => return Err(RuntimeError::new("ecs_query_with: expected world")),
        };
        let comp_names: Vec<String> = match &args[1] {
            Value::Array(arr) => arr
                .borrow()
                .iter()
                .filter_map(|v| match v {
                    Value::String(s) => Some(s.to_string()),
                    _ => None,
                })
                .collect(),
            _ => {
                return Err(RuntimeError::new(
                    "ecs_query_with: expected array of component names",
                ))
            }
        };
        let callback = match &args[2] {
            Value::Function(f) => f.clone(),
            _ => {
                return Err(RuntimeError::new(
                    "ecs_query_with: expected callback function",
                ))
            }
        };

        // Pre-collect all data to avoid borrow issues during callbacks
        let mut callback_data: Vec<(i64, HashMap<String, Value>)> = Vec::new();

        {
            let world_ref = world.borrow();
            let mut result_ids: Option<Vec<String>> = None;

            if let Some(Value::Map(components)) = world_ref.get("components") {
                let comps = components.borrow();

                for comp_name in &comp_names {
                    if let Some(Value::Map(storage)) = comps.get(comp_name) {
                        let keys: Vec<String> = storage.borrow().keys().cloned().collect();
                        result_ids = Some(match result_ids {
                            None => keys,
                            Some(existing) => {
                                existing.into_iter().filter(|k| keys.contains(k)).collect()
                            }
                        });
                    } else {
                        result_ids = Some(vec![]);
                        break;
                    }
                }

                // Collect data for each matching entity
                for id_str in result_ids.unwrap_or_default() {
                    if let Ok(id) = id_str.parse::<i64>() {
                        let mut entity_comps = HashMap::new();
                        for comp_name in &comp_names {
                            if let Some(Value::Map(storage)) = comps.get(comp_name) {
                                if let Some(data) = storage.borrow().get(&id_str) {
                                    entity_comps.insert(comp_name.clone(), data.clone());
                                }
                            }
                        }
                        callback_data.push((id, entity_comps));
                    }
                }
            }
        } // Release borrows here

        // Now call callbacks without holding borrows
        for (id, entity_comps) in callback_data {
            let callback_args = vec![
                Value::Int(id),
                Value::Map(Rc::new(RefCell::new(entity_comps))),
            ];
            interp.call_function(&callback, callback_args)?;
        }

        Ok(Value::Null)
    });

    // ecs_count(world) - Count total entities
    define(interp, "ecs_count", Some(1), |_, args| {
        let world = match &args[0] {
            Value::Map(m) => m.clone(),
            _ => return Err(RuntimeError::new("ecs_count: expected world")),
        };

        let world_ref = world.borrow();
        if let Some(Value::Map(entities)) = world_ref.get("entities") {
            return Ok(Value::Int(entities.borrow().len() as i64));
        }

        Ok(Value::Int(0))
    });

    // ecs_alive(world, entity_id) - Check if entity is alive
    define(interp, "ecs_alive", Some(2), |_, args| {
        let world = match &args[0] {
            Value::Map(m) => m.clone(),
            _ => return Err(RuntimeError::new("ecs_alive: expected world")),
        };
        let id = match &args[1] {
            Value::Int(n) => *n,
            _ => return Err(RuntimeError::new("ecs_alive: expected entity id")),
        };

        let world_ref = world.borrow();
        if let Some(Value::Map(entities)) = world_ref.get("entities") {
            return Ok(Value::Bool(entities.borrow().contains_key(&id.to_string())));
        }

        Ok(Value::Bool(false))
    });
}

// ============================================================================
// POLYCULTURAL TEXT PROCESSING
// ============================================================================
//
// Sigil's philosophy: Mathematics is poly-cultural, and so is TEXT.
// Different writing systems have different needs:
//
// | Writing System | Special Needs |
// |----------------|---------------|
// | Latin          | Diacritics, ligatures, case folding |
// | Arabic/Hebrew  | RTL, contextual shaping, vowel marks |
// | CJK            | No word boundaries, display width, ruby text |
// | Devanagari     | Complex clusters, conjuncts |
// | Thai           | No spaces between words |
// | Hangul         | Jamo composition/decomposition |
//
// This module provides world-class text handling for ALL scripts.
//

fn register_polycultural_text(interp: &mut Interpreter) {
    // =========================================================================
    // SCRIPT DETECTION
    // =========================================================================
    //
    // Detect what writing system(s) a text uses.
    // Essential for choosing appropriate processing strategies.
    //

    // script - get the dominant script of a string
    define(interp, "script", Some(1), |_, args| {
        match &args[0] {
            Value::String(s) => {
                // Count scripts
                let mut script_counts: HashMap<String, usize> = HashMap::new();
                for c in s.chars() {
                    if !c.is_whitespace() && !c.is_ascii_punctuation() {
                        let script = c.script();
                        let name = format!("{:?}", script);
                        *script_counts.entry(name).or_insert(0) += 1;
                    }
                }
                // Find dominant script
                let dominant = script_counts
                    .into_iter()
                    .max_by_key(|(_, count)| *count)
                    .map(|(name, _)| name)
                    .unwrap_or_else(|| "Unknown".to_string());
                Ok(Value::String(Rc::new(dominant)))
            }
            _ => Err(RuntimeError::new("script() requires string")),
        }
    });

    // scripts - get all scripts present in text
    define(interp, "scripts", Some(1), |_, args| match &args[0] {
        Value::String(s) => {
            let mut scripts: Vec<String> = s
                .chars()
                .filter(|c| !c.is_whitespace() && !c.is_ascii_punctuation())
                .map(|c| format!("{:?}", c.script()))
                .collect();
            scripts.sort();
            scripts.dedup();
            let values: Vec<Value> = scripts
                .into_iter()
                .map(|s| Value::String(Rc::new(s)))
                .collect();
            Ok(Value::Array(Rc::new(RefCell::new(values))))
        }
        _ => Err(RuntimeError::new("scripts() requires string")),
    });

    // is_script - check if text is primarily in a specific script
    define(interp, "is_script", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::String(s), Value::String(script_name)) => {
                let target = script_name.to_lowercase();
                let mut matching = 0usize;
                let mut total = 0usize;
                for c in s.chars() {
                    if !c.is_whitespace() && !c.is_ascii_punctuation() {
                        total += 1;
                        let script_str = format!("{:?}", c.script()).to_lowercase();
                        if script_str == target {
                            matching += 1;
                        }
                    }
                }
                let ratio = if total > 0 {
                    matching as f64 / total as f64
                } else {
                    0.0
                };
                Ok(Value::Bool(ratio > 0.5))
            }
            _ => Err(RuntimeError::new(
                "is_script() requires string and script name",
            )),
        }
    });

    // Script-specific detection functions
    define(interp, "is_latin", Some(1), |_, args| match &args[0] {
        Value::String(s) => {
            let is_latin = s
                .chars()
                .filter(|c| !c.is_whitespace())
                .all(|c| matches!(c.script(), Script::Latin | Script::Common));
            Ok(Value::Bool(is_latin && !s.is_empty()))
        }
        _ => Err(RuntimeError::new("is_latin() requires string")),
    });

    define(interp, "is_cjk", Some(1), |_, args| match &args[0] {
        Value::String(s) => {
            let has_cjk = s.chars().any(|c| {
                matches!(
                    c.script(),
                    Script::Han
                        | Script::Hiragana
                        | Script::Katakana
                        | Script::Hangul
                        | Script::Bopomofo
                )
            });
            Ok(Value::Bool(has_cjk))
        }
        _ => Err(RuntimeError::new("is_cjk() requires string")),
    });

    define(interp, "is_arabic", Some(1), |_, args| match &args[0] {
        Value::String(s) => {
            let has_arabic = s.chars().any(|c| matches!(c.script(), Script::Arabic));
            Ok(Value::Bool(has_arabic))
        }
        _ => Err(RuntimeError::new("is_arabic() requires string")),
    });

    define(interp, "is_hebrew", Some(1), |_, args| match &args[0] {
        Value::String(s) => {
            let has_hebrew = s.chars().any(|c| matches!(c.script(), Script::Hebrew));
            Ok(Value::Bool(has_hebrew))
        }
        _ => Err(RuntimeError::new("is_hebrew() requires string")),
    });

    define(interp, "is_cyrillic", Some(1), |_, args| match &args[0] {
        Value::String(s) => {
            let has_cyrillic = s.chars().any(|c| matches!(c.script(), Script::Cyrillic));
            Ok(Value::Bool(has_cyrillic))
        }
        _ => Err(RuntimeError::new("is_cyrillic() requires string")),
    });

    define(interp, "is_greek", Some(1), |_, args| match &args[0] {
        Value::String(s) => {
            let has_greek = s.chars().any(|c| matches!(c.script(), Script::Greek));
            Ok(Value::Bool(has_greek))
        }
        _ => Err(RuntimeError::new("is_greek() requires string")),
    });

    define(interp, "is_devanagari", Some(1), |_, args| match &args[0] {
        Value::String(s) => {
            let has_devanagari = s.chars().any(|c| matches!(c.script(), Script::Devanagari));
            Ok(Value::Bool(has_devanagari))
        }
        _ => Err(RuntimeError::new("is_devanagari() requires string")),
    });

    define(interp, "is_thai", Some(1), |_, args| match &args[0] {
        Value::String(s) => {
            let has_thai = s.chars().any(|c| matches!(c.script(), Script::Thai));
            Ok(Value::Bool(has_thai))
        }
        _ => Err(RuntimeError::new("is_thai() requires string")),
    });

    define(interp, "is_hangul", Some(1), |_, args| match &args[0] {
        Value::String(s) => {
            let has_hangul = s.chars().any(|c| matches!(c.script(), Script::Hangul));
            Ok(Value::Bool(has_hangul))
        }
        _ => Err(RuntimeError::new("is_hangul() requires string")),
    });

    define(interp, "is_hiragana", Some(1), |_, args| match &args[0] {
        Value::String(s) => {
            let has_hiragana = s.chars().any(|c| matches!(c.script(), Script::Hiragana));
            Ok(Value::Bool(has_hiragana))
        }
        _ => Err(RuntimeError::new("is_hiragana() requires string")),
    });

    define(interp, "is_katakana", Some(1), |_, args| match &args[0] {
        Value::String(s) => {
            let has_katakana = s.chars().any(|c| matches!(c.script(), Script::Katakana));
            Ok(Value::Bool(has_katakana))
        }
        _ => Err(RuntimeError::new("is_katakana() requires string")),
    });

    // char_script - get script of a single character
    define(interp, "char_script", Some(1), |_, args| match &args[0] {
        Value::Char(c) => {
            let script = format!("{:?}", c.script());
            Ok(Value::String(Rc::new(script)))
        }
        Value::String(s) if s.chars().count() == 1 => {
            let c = s.chars().next().unwrap();
            let script = format!("{:?}", c.script());
            Ok(Value::String(Rc::new(script)))
        }
        _ => Err(RuntimeError::new("char_script() requires single character")),
    });

    // =========================================================================
    // BIDIRECTIONAL TEXT (RTL/LTR)
    // =========================================================================
    //
    // Arabic, Hebrew, and other scripts are written right-to-left.
    // Mixed text (e.g., Arabic with English) needs bidirectional handling.
    //

    // text_direction - get overall text direction
    define(interp, "text_direction", Some(1), |_, args| {
        match &args[0] {
            Value::String(s) => {
                let bidi_info = BidiInfo::new(s, None);
                // Check if any paragraph is RTL
                let has_rtl = bidi_info.paragraphs.iter().any(|p| p.level.is_rtl());
                let direction = if has_rtl { "rtl" } else { "ltr" };
                Ok(Value::String(Rc::new(direction.to_string())))
            }
            _ => Err(RuntimeError::new("text_direction() requires string")),
        }
    });

    // is_rtl - check if text is right-to-left
    define(interp, "is_rtl", Some(1), |_, args| match &args[0] {
        Value::String(s) => {
            let bidi_info = BidiInfo::new(s, None);
            let has_rtl = bidi_info.paragraphs.iter().any(|p| p.level.is_rtl());
            Ok(Value::Bool(has_rtl))
        }
        _ => Err(RuntimeError::new("is_rtl() requires string")),
    });

    // is_ltr - check if text is left-to-right
    define(interp, "is_ltr", Some(1), |_, args| match &args[0] {
        Value::String(s) => {
            let bidi_info = BidiInfo::new(s, None);
            let is_ltr = bidi_info.paragraphs.iter().all(|p| !p.level.is_rtl());
            Ok(Value::Bool(is_ltr))
        }
        _ => Err(RuntimeError::new("is_ltr() requires string")),
    });

    // is_bidi - check if text contains mixed directions
    define(interp, "is_bidi", Some(1), |_, args| {
        match &args[0] {
            Value::String(s) => {
                // Check for both RTL and LTR characters
                let has_rtl = s.chars().any(|c| {
                    matches!(
                        c.script(),
                        Script::Arabic | Script::Hebrew | Script::Syriac | Script::Thaana
                    )
                });
                let has_ltr = s.chars().any(|c| {
                    matches!(c.script(), Script::Latin | Script::Greek | Script::Cyrillic)
                });
                Ok(Value::Bool(has_rtl && has_ltr))
            }
            _ => Err(RuntimeError::new("is_bidi() requires string")),
        }
    });

    // bidi_reorder - reorder text for visual display
    define(interp, "bidi_reorder", Some(1), |_, args| match &args[0] {
        Value::String(s) => {
            let bidi_info = BidiInfo::new(s, None);
            let mut result = String::new();
            for para in &bidi_info.paragraphs {
                let line = para.range.clone();
                let reordered = bidi_info.reorder_line(para, line);
                result.push_str(&reordered);
            }
            Ok(Value::String(Rc::new(result)))
        }
        _ => Err(RuntimeError::new("bidi_reorder() requires string")),
    });

    // =========================================================================
    // DISPLAY WIDTH (CJK-aware)
    // =========================================================================
    //
    // CJK characters are "full-width" (2 columns), while Latin is "half-width".
    // Critical for proper terminal output and text alignment.
    //

    // display_width - get visual width in terminal columns
    define(interp, "display_width", Some(1), |_, args| match &args[0] {
        Value::String(s) => {
            let width = UnicodeWidthStr::width(s.as_str());
            Ok(Value::Int(width as i64))
        }
        _ => Err(RuntimeError::new("display_width() requires string")),
    });

    // is_fullwidth - check if string contains full-width characters
    define(interp, "is_fullwidth", Some(1), |_, args| {
        match &args[0] {
            Value::String(s) => {
                let char_count = s.chars().count();
                let display_width = UnicodeWidthStr::width(s.as_str());
                // If display width > char count, we have full-width chars
                Ok(Value::Bool(display_width > char_count))
            }
            _ => Err(RuntimeError::new("is_fullwidth() requires string")),
        }
    });

    // pad_display - pad string to display width (CJK-aware)
    define(interp, "pad_display", Some(3), |_, args| {
        match (&args[0], &args[1], &args[2]) {
            (Value::String(s), Value::Int(target_width), Value::String(align)) => {
                let current_width = UnicodeWidthStr::width(s.as_str());
                let target = *target_width as usize;
                if current_width >= target {
                    return Ok(Value::String(s.clone()));
                }
                let padding = target - current_width;
                let result = match align.as_str() {
                    "left" => format!("{}{}", s, " ".repeat(padding)),
                    "right" => format!("{}{}", " ".repeat(padding), s),
                    "center" => {
                        let left = padding / 2;
                        let right = padding - left;
                        format!("{}{}{}", " ".repeat(left), s, " ".repeat(right))
                    }
                    _ => {
                        return Err(RuntimeError::new(
                            "pad_display: align must be 'left', 'right', or 'center'",
                        ))
                    }
                };
                Ok(Value::String(Rc::new(result)))
            }
            _ => Err(RuntimeError::new(
                "pad_display() requires string, width, and alignment",
            )),
        }
    });

    // =========================================================================
    // TRANSLITERATION
    // =========================================================================
    //
    // Convert text from any script to ASCII representation.
    // Essential for: search, URLs, usernames, file names.
    //

    // transliterate - convert any Unicode text to ASCII
    define(interp, "transliterate", Some(1), |_, args| match &args[0] {
        Value::String(s) => {
            let ascii = deunicode(s);
            Ok(Value::String(Rc::new(ascii)))
        }
        _ => Err(RuntimeError::new("transliterate() requires string")),
    });

    // to_ascii - alias for transliterate
    define(interp, "to_ascii", Some(1), |_, args| match &args[0] {
        Value::String(s) => {
            let ascii = deunicode(s);
            Ok(Value::String(Rc::new(ascii)))
        }
        _ => Err(RuntimeError::new("to_ascii() requires string")),
    });

    // slugify - create URL-safe slug from any text
    define(interp, "slugify", Some(1), |_, args| {
        match &args[0] {
            Value::String(s) => {
                let ascii = deunicode(s);
                let slug: String = ascii
                    .to_lowercase()
                    .chars()
                    .map(|c| if c.is_alphanumeric() { c } else { '-' })
                    .collect();
                // Collapse multiple dashes and trim
                let mut result = String::new();
                let mut last_was_dash = true; // Start true to trim leading dashes
                for c in slug.chars() {
                    if c == '-' {
                        if !last_was_dash {
                            result.push(c);
                            last_was_dash = true;
                        }
                    } else {
                        result.push(c);
                        last_was_dash = false;
                    }
                }
                // Trim trailing dash
                if result.ends_with('-') {
                    result.pop();
                }
                Ok(Value::String(Rc::new(result)))
            }
            _ => Err(RuntimeError::new("slugify() requires string")),
        }
    });

    // =========================================================================
    // DIACRITICS AND ACCENTS
    // =========================================================================
    //
    // Many scripts use combining marks: é = e + ́ (combining acute)
    // Need to handle decomposition, stripping, and normalization.
    //

    // strip_diacritics - remove accents and combining marks
    define(interp, "strip_diacritics", Some(1), |_, args| {
        match &args[0] {
            Value::String(s) => {
                // NFD decomposition separates base chars from combining marks
                let decomposed: String = s.nfd().collect();
                // Filter out combining marks (category Mn, Mc, Me)
                let stripped: String = decomposed
                    .chars()
                    .filter(|c| {
                        // Keep if not a combining mark
                        // Combining marks are in Unicode categories Mn, Mc, Me
                        // which are roughly in ranges U+0300-U+036F (common) and others
                        let code = *c as u32;
                        // Quick check for common combining diacritical marks
                        !(0x0300..=0x036F).contains(&code)
                            && !(0x1AB0..=0x1AFF).contains(&code)
                            && !(0x1DC0..=0x1DFF).contains(&code)
                            && !(0x20D0..=0x20FF).contains(&code)
                            && !(0xFE20..=0xFE2F).contains(&code)
                    })
                    .collect();
                Ok(Value::String(Rc::new(stripped)))
            }
            _ => Err(RuntimeError::new("strip_diacritics() requires string")),
        }
    });

    // has_diacritics - check if string contains diacritical marks
    define(interp, "has_diacritics", Some(1), |_, args| {
        match &args[0] {
            Value::String(s) => {
                let decomposed: String = s.nfd().collect();
                let has_marks = decomposed.chars().any(|c| {
                    let code = c as u32;
                    (0x0300..=0x036F).contains(&code)
                        || (0x1AB0..=0x1AFF).contains(&code)
                        || (0x1DC0..=0x1DFF).contains(&code)
                        || (0x20D0..=0x20FF).contains(&code)
                        || (0xFE20..=0xFE2F).contains(&code)
                });
                Ok(Value::Bool(has_marks))
            }
            _ => Err(RuntimeError::new("has_diacritics() requires string")),
        }
    });

    // normalize_accents - convert composed to decomposed or vice versa
    define(interp, "normalize_accents", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::String(s), Value::String(form)) => {
                let result = match form.as_str() {
                    "composed" | "nfc" => s.nfc().collect(),
                    "decomposed" | "nfd" => s.nfd().collect(),
                    _ => {
                        return Err(RuntimeError::new(
                            "normalize_accents: form must be 'composed' or 'decomposed'",
                        ))
                    }
                };
                Ok(Value::String(Rc::new(result)))
            }
            _ => Err(RuntimeError::new(
                "normalize_accents() requires string and form",
            )),
        }
    });

    // =========================================================================
    // LOCALE-AWARE CASE MAPPING
    // =========================================================================
    //
    // Case mapping varies by locale:
    // - Turkish: i ↔ İ, ı ↔ I (dotted/dotless distinction)
    // - German: ß → SS (uppercase), but SS → ss or ß (lowercase)
    // - Greek: final sigma rules
    //

    // upper_locale - locale-aware uppercase
    define(interp, "upper_locale", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::String(s), Value::String(locale_str)) => {
                let case_mapper = CaseMapper::new();
                let langid: LanguageIdentifier =
                    locale_str.parse().unwrap_or_else(|_| "en".parse().unwrap());
                let result = case_mapper.uppercase_to_string(s, &langid);
                Ok(Value::String(Rc::new(result)))
            }
            _ => Err(RuntimeError::new(
                "upper_locale() requires string and locale",
            )),
        }
    });

    // lower_locale - locale-aware lowercase
    define(interp, "lower_locale", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::String(s), Value::String(locale_str)) => {
                let case_mapper = CaseMapper::new();
                let langid: LanguageIdentifier =
                    locale_str.parse().unwrap_or_else(|_| "en".parse().unwrap());
                let result = case_mapper.lowercase_to_string(s, &langid);
                Ok(Value::String(Rc::new(result)))
            }
            _ => Err(RuntimeError::new(
                "lower_locale() requires string and locale",
            )),
        }
    });

    // titlecase_locale - locale-aware titlecase
    define(interp, "titlecase_locale", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::String(s), Value::String(locale_str)) => {
                let case_mapper = CaseMapper::new();
                let langid: LanguageIdentifier =
                    locale_str.parse().unwrap_or_else(|_| "en".parse().unwrap());
                let options = TitlecaseOptions::default();
                let result = case_mapper
                    .titlecase_segment_with_only_case_data_to_string(s, &langid, options);
                Ok(Value::String(Rc::new(result)))
            }
            _ => Err(RuntimeError::new(
                "titlecase_locale() requires string and locale",
            )),
        }
    });

    // case_fold - Unicode case folding for comparison
    define(interp, "case_fold", Some(1), |_, args| match &args[0] {
        Value::String(s) => {
            let case_mapper = CaseMapper::new();
            let result = case_mapper.fold_string(s);
            Ok(Value::String(Rc::new(result)))
        }
        _ => Err(RuntimeError::new("case_fold() requires string")),
    });

    // case_insensitive_eq - compare strings ignoring case (using case folding)
    define(interp, "case_insensitive_eq", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::String(a), Value::String(b)) => {
                let case_mapper = CaseMapper::new();
                let folded_a = case_mapper.fold_string(a);
                let folded_b = case_mapper.fold_string(b);
                Ok(Value::Bool(folded_a == folded_b))
            }
            _ => Err(RuntimeError::new(
                "case_insensitive_eq() requires two strings",
            )),
        }
    });

    // =========================================================================
    // LOCALE-AWARE COLLATION (SORTING)
    // =========================================================================
    //
    // Sorting order varies dramatically by locale:
    // - German: ä sorts with a
    // - Swedish: ä sorts after z
    // - Spanish: ñ is a separate letter after n
    //

    // compare_locale - locale-aware string comparison
    define(interp, "compare_locale", Some(3), |_, args| {
        match (&args[0], &args[1], &args[2]) {
            (Value::String(a), Value::String(b), Value::String(locale_str)) => {
                let locale: Locale = locale_str.parse().unwrap_or_else(|_| "en".parse().unwrap());
                let options = CollatorOptions::new();
                let collator = Collator::try_new(&locale.into(), options)
                    .unwrap_or_else(|_| Collator::try_new(&Default::default(), options).unwrap());
                let result = match collator.compare(a, b) {
                    std::cmp::Ordering::Less => -1,
                    std::cmp::Ordering::Equal => 0,
                    std::cmp::Ordering::Greater => 1,
                };
                Ok(Value::Int(result))
            }
            _ => Err(RuntimeError::new(
                "compare_locale() requires two strings and locale",
            )),
        }
    });

    // sort_locale - sort array of strings by locale
    define(interp, "sort_locale", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::Array(arr), Value::String(locale_str)) => {
                let locale: Locale = locale_str.parse().unwrap_or_else(|_| "en".parse().unwrap());
                let options = CollatorOptions::new();
                let collator = Collator::try_new(&locale.into(), options)
                    .unwrap_or_else(|_| Collator::try_new(&Default::default(), options).unwrap());

                let mut items: Vec<(String, Value)> = arr
                    .borrow()
                    .iter()
                    .map(|v| {
                        let s = match v {
                            Value::String(s) => (**s).clone(),
                            _ => format!("{}", v),
                        };
                        (s, v.clone())
                    })
                    .collect();

                items.sort_by(|(a, _), (b, _)| collator.compare(a, b));

                let sorted: Vec<Value> = items.into_iter().map(|(_, v)| v).collect();
                Ok(Value::Array(Rc::new(RefCell::new(sorted))))
            }
            _ => Err(RuntimeError::new("sort_locale() requires array and locale")),
        }
    });

    // =========================================================================
    // ADVANCED SEGMENTATION
    // =========================================================================
    //
    // Different languages have different boundary rules:
    // - Thai/Lao/Khmer: No spaces between words
    // - CJK: Characters can be words themselves
    // - German: Compound words are single words
    //

    // sentences - split text into sentences (locale-aware)
    define(interp, "sentences", Some(1), |_, args| match &args[0] {
        Value::String(s) => {
            let segmenter = SentenceSegmenter::new();
            let breakpoints: Vec<usize> = segmenter.segment_str(s).collect();
            let mut sentences = Vec::new();
            let mut start = 0;
            for end in breakpoints {
                let sentence = s[start..end].trim();
                if !sentence.is_empty() {
                    sentences.push(Value::String(Rc::new(sentence.to_string())));
                }
                start = end;
            }
            Ok(Value::Array(Rc::new(RefCell::new(sentences))))
        }
        _ => Err(RuntimeError::new("sentences() requires string")),
    });

    // sentence_count - count sentences
    define(interp, "sentence_count", Some(1), |_, args| {
        match &args[0] {
            Value::String(s) => {
                let segmenter = SentenceSegmenter::new();
                let breakpoints: Vec<usize> = segmenter.segment_str(s).collect();
                // Sentences are between breakpoints
                let count = breakpoints.len().saturating_sub(1);
                Ok(Value::Int(count as i64))
            }
            _ => Err(RuntimeError::new("sentence_count() requires string")),
        }
    });

    // words_icu - ICU-based word segmentation (better for CJK, Thai)
    define(interp, "words_icu", Some(1), |_, args| {
        match &args[0] {
            Value::String(s) => {
                let segmenter = WordSegmenter::new_auto();
                let breakpoints: Vec<usize> = segmenter.segment_str(s).collect();
                let mut words = Vec::new();
                let mut start = 0;
                for end in breakpoints {
                    let word = &s[start..end];
                    // Filter out whitespace-only segments
                    if !word.trim().is_empty() {
                        words.push(Value::String(Rc::new(word.to_string())));
                    }
                    start = end;
                }
                Ok(Value::Array(Rc::new(RefCell::new(words))))
            }
            _ => Err(RuntimeError::new("words_icu() requires string")),
        }
    });

    // word_count_icu - ICU-based word count (handles Thai, CJK correctly)
    define(interp, "word_count_icu", Some(1), |_, args| {
        match &args[0] {
            Value::String(s) => {
                let segmenter = WordSegmenter::new_auto();
                let breakpoints: Vec<usize> = segmenter.segment_str(s).collect();
                let mut count = 0;
                let mut start = 0;
                for end in breakpoints {
                    let word = &s[start..end];
                    if !word.trim().is_empty() && word.chars().any(|c| c.is_alphanumeric()) {
                        count += 1;
                    }
                    start = end;
                }
                Ok(Value::Int(count))
            }
            _ => Err(RuntimeError::new("word_count_icu() requires string")),
        }
    });

    // =========================================================================
    // SCRIPT-SPECIFIC UTILITIES
    // =========================================================================

    // is_emoji - check if string contains emoji
    define(interp, "is_emoji", Some(1), |_, args| {
        match &args[0] {
            Value::String(s) => {
                let has_emoji = s.chars().any(|c| {
                    let code = c as u32;
                    // Common emoji ranges
                    (0x1F600..=0x1F64F).contains(&code) ||  // Emoticons
                    (0x1F300..=0x1F5FF).contains(&code) ||  // Misc Symbols and Pictographs
                    (0x1F680..=0x1F6FF).contains(&code) ||  // Transport and Map
                    (0x1F1E0..=0x1F1FF).contains(&code) ||  // Flags
                    (0x2600..=0x26FF).contains(&code) ||    // Misc symbols
                    (0x2700..=0x27BF).contains(&code) ||    // Dingbats
                    (0xFE00..=0xFE0F).contains(&code) ||    // Variation Selectors
                    (0x1F900..=0x1F9FF).contains(&code) ||  // Supplemental Symbols and Pictographs
                    (0x1FA00..=0x1FA6F).contains(&code) ||  // Chess Symbols
                    (0x1FA70..=0x1FAFF).contains(&code) ||  // Symbols and Pictographs Extended-A
                    (0x231A..=0x231B).contains(&code) ||    // Watch, Hourglass
                    (0x23E9..=0x23F3).contains(&code) ||    // Various symbols
                    (0x23F8..=0x23FA).contains(&code) // Various symbols
                });
                Ok(Value::Bool(has_emoji))
            }
            _ => Err(RuntimeError::new("is_emoji() requires string")),
        }
    });

    // extract_emoji - extract all emoji from text
    define(interp, "extract_emoji", Some(1), |_, args| match &args[0] {
        Value::String(s) => {
            let emoji: Vec<Value> = s
                .graphemes(true)
                .filter(|g| {
                    g.chars().any(|c| {
                        let code = c as u32;
                        (0x1F600..=0x1F64F).contains(&code)
                            || (0x1F300..=0x1F5FF).contains(&code)
                            || (0x1F680..=0x1F6FF).contains(&code)
                            || (0x1F1E0..=0x1F1FF).contains(&code)
                            || (0x2600..=0x26FF).contains(&code)
                            || (0x2700..=0x27BF).contains(&code)
                            || (0x1F900..=0x1F9FF).contains(&code)
                            || (0x1FA00..=0x1FA6F).contains(&code)
                            || (0x1FA70..=0x1FAFF).contains(&code)
                    })
                })
                .map(|g| Value::String(Rc::new(g.to_string())))
                .collect();
            Ok(Value::Array(Rc::new(RefCell::new(emoji))))
        }
        _ => Err(RuntimeError::new("extract_emoji() requires string")),
    });

    // strip_emoji - remove emoji from text
    define(interp, "strip_emoji", Some(1), |_, args| match &args[0] {
        Value::String(s) => {
            let stripped: String = s
                .graphemes(true)
                .filter(|g| {
                    !g.chars().any(|c| {
                        let code = c as u32;
                        (0x1F600..=0x1F64F).contains(&code)
                            || (0x1F300..=0x1F5FF).contains(&code)
                            || (0x1F680..=0x1F6FF).contains(&code)
                            || (0x1F1E0..=0x1F1FF).contains(&code)
                            || (0x2600..=0x26FF).contains(&code)
                            || (0x2700..=0x27BF).contains(&code)
                            || (0x1F900..=0x1F9FF).contains(&code)
                            || (0x1FA00..=0x1FA6F).contains(&code)
                            || (0x1FA70..=0x1FAFF).contains(&code)
                    })
                })
                .collect();
            Ok(Value::String(Rc::new(stripped)))
        }
        _ => Err(RuntimeError::new("strip_emoji() requires string")),
    });

    // =========================================================================
    // MIXED SCRIPT TEXT UTILITIES
    // =========================================================================

    // script_runs - split text into runs of the same script
    define(interp, "script_runs", Some(1), |_, args| {
        match &args[0] {
            Value::String(s) => {
                let mut runs: Vec<Value> = Vec::new();
                let mut current_run = String::new();
                let mut current_script: Option<Script> = None;

                for c in s.chars() {
                    let script = c.script();
                    // Common and Inherited scripts don't start new runs
                    if script != Script::Common && script != Script::Inherited {
                        if let Some(curr) = current_script {
                            if script != curr {
                                // New script - save current run
                                if !current_run.is_empty() {
                                    runs.push(Value::String(Rc::new(current_run.clone())));
                                    current_run.clear();
                                }
                                current_script = Some(script);
                            }
                        } else {
                            current_script = Some(script);
                        }
                    }
                    current_run.push(c);
                }

                // Don't forget the last run
                if !current_run.is_empty() {
                    runs.push(Value::String(Rc::new(current_run)));
                }

                Ok(Value::Array(Rc::new(RefCell::new(runs))))
            }
            _ => Err(RuntimeError::new("script_runs() requires string")),
        }
    });

    // script_ratio - get ratio of scripts in text
    define(interp, "script_ratio", Some(1), |_, args| {
        match &args[0] {
            Value::String(s) => {
                let mut script_counts: HashMap<String, usize> = HashMap::new();
                let mut total = 0usize;

                for c in s.chars() {
                    if !c.is_whitespace() && c != ' ' {
                        let script = format!("{:?}", c.script());
                        *script_counts.entry(script).or_insert(0) += 1;
                        total += 1;
                    }
                }

                // Convert to map of ratios
                let mut result = HashMap::new();
                for (script, count) in script_counts {
                    let ratio = if total > 0 {
                        count as f64 / total as f64
                    } else {
                        0.0
                    };
                    result.insert(script, Value::Float(ratio));
                }

                let map = Rc::new(RefCell::new(result));
                Ok(Value::Map(map))
            }
            _ => Err(RuntimeError::new("script_ratio() requires string")),
        }
    });

    // =========================================================================
    // INTERNATIONALIZATION HELPERS
    // =========================================================================

    // locale_name - get display name for a locale
    define(interp, "locale_name", Some(1), |_, args| {
        match &args[0] {
            Value::String(locale_str) => {
                // Return the locale code itself as a simple implementation
                // A full implementation would use ICU's display names
                Ok(Value::String(locale_str.clone()))
            }
            _ => Err(RuntimeError::new("locale_name() requires string")),
        }
    });

    // supported_locales - list of supported locales for collation
    define(interp, "supported_locales", Some(0), |_, _| {
        // Common locales supported by ICU
        let locales = vec![
            "ar", "bg", "ca", "cs", "da", "de", "el", "en", "es", "et", "fi", "fr", "he", "hi",
            "hr", "hu", "id", "it", "ja", "ko", "lt", "lv", "ms", "nb", "nl", "pl", "pt", "ro",
            "ru", "sk", "sl", "sr", "sv", "th", "tr", "uk", "vi", "zh",
        ];
        let values: Vec<Value> = locales
            .into_iter()
            .map(|s| Value::String(Rc::new(s.to_string())))
            .collect();
        Ok(Value::Array(Rc::new(RefCell::new(values))))
    });
}

// =============================================================================
// TEXT INTELLIGENCE MODULE - AI-Native Text Analysis
// =============================================================================

fn register_text_intelligence(interp: &mut Interpreter) {
    // =========================================================================
    // STRING SIMILARITY METRICS
    // =========================================================================

    // levenshtein - edit distance between strings
    define(interp, "levenshtein", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::String(a), Value::String(b)) => {
                let distance = strsim::levenshtein(a, b);
                Ok(Value::Int(distance as i64))
            }
            _ => Err(RuntimeError::new("levenshtein() requires two strings")),
        }
    });

    // levenshtein_normalized - normalized edit distance (0.0 to 1.0)
    define(
        interp,
        "levenshtein_normalized",
        Some(2),
        |_, args| match (&args[0], &args[1]) {
            (Value::String(a), Value::String(b)) => {
                let distance = strsim::normalized_levenshtein(a, b);
                Ok(Value::Float(distance))
            }
            _ => Err(RuntimeError::new(
                "levenshtein_normalized() requires two strings",
            )),
        },
    );

    // jaro - Jaro similarity (0.0 to 1.0)
    define(interp, "jaro", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::String(a), Value::String(b)) => {
                let sim = strsim::jaro(a, b);
                Ok(Value::Float(sim))
            }
            _ => Err(RuntimeError::new("jaro() requires two strings")),
        }
    });

    // jaro_winkler - Jaro-Winkler similarity (0.0 to 1.0, favors common prefixes)
    define(interp, "jaro_winkler", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::String(a), Value::String(b)) => {
                let sim = strsim::jaro_winkler(a, b);
                Ok(Value::Float(sim))
            }
            _ => Err(RuntimeError::new("jaro_winkler() requires two strings")),
        }
    });

    // sorensen_dice - Sørensen-Dice coefficient (0.0 to 1.0)
    define(interp, "sorensen_dice", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::String(a), Value::String(b)) => {
                let sim = strsim::sorensen_dice(a, b);
                Ok(Value::Float(sim))
            }
            _ => Err(RuntimeError::new("sorensen_dice() requires two strings")),
        }
    });

    // damerau_levenshtein - edit distance with transpositions
    define(interp, "damerau_levenshtein", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::String(a), Value::String(b)) => {
                let distance = strsim::damerau_levenshtein(a, b);
                Ok(Value::Int(distance as i64))
            }
            _ => Err(RuntimeError::new(
                "damerau_levenshtein() requires two strings",
            )),
        }
    });

    // osa_distance - Optimal String Alignment distance
    define(interp, "osa_distance", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::String(a), Value::String(b)) => {
                let distance = strsim::osa_distance(a, b);
                Ok(Value::Int(distance as i64))
            }
            _ => Err(RuntimeError::new("osa_distance() requires two strings")),
        }
    });

    // fuzzy_match - check if strings are similar above threshold
    define(interp, "fuzzy_match", Some(3), |_, args| {
        match (&args[0], &args[1], &args[2]) {
            (Value::String(a), Value::String(b), Value::Float(threshold)) => {
                let sim = strsim::jaro_winkler(a, b);
                Ok(Value::Bool(sim >= *threshold))
            }
            (Value::String(a), Value::String(b), Value::Int(threshold)) => {
                let sim = strsim::jaro_winkler(a, b);
                Ok(Value::Bool(sim >= *threshold as f64))
            }
            _ => Err(RuntimeError::new(
                "fuzzy_match() requires two strings and threshold",
            )),
        }
    });

    // fuzzy_search - find best matches in array
    define(interp, "fuzzy_search", Some(3), |_, args| {
        match (&args[0], &args[1], &args[2]) {
            (Value::String(query), Value::Array(items), Value::Int(limit)) => {
                let items_ref = items.borrow();
                let mut scores: Vec<(f64, &str)> = items_ref
                    .iter()
                    .filter_map(|v| {
                        if let Value::String(s) = v {
                            Some((strsim::jaro_winkler(query, s), s.as_str()))
                        } else {
                            None
                        }
                    })
                    .collect();
                scores.sort_by(|a, b| b.0.partial_cmp(&a.0).unwrap_or(std::cmp::Ordering::Equal));
                let results: Vec<Value> = scores
                    .into_iter()
                    .take(*limit as usize)
                    .map(|(_, s)| Value::String(Rc::new(s.to_string())))
                    .collect();
                Ok(Value::Array(Rc::new(RefCell::new(results))))
            }
            _ => Err(RuntimeError::new(
                "fuzzy_search() requires query string, array, and limit",
            )),
        }
    });

    // =========================================================================
    // PHONETIC ENCODING
    // =========================================================================

    // soundex - American Soundex encoding
    define(interp, "soundex", Some(1), |_, args| match &args[0] {
        Value::String(s) => {
            let code = compute_soundex(s);
            Ok(Value::String(Rc::new(code)))
        }
        _ => Err(RuntimeError::new("soundex() requires string")),
    });

    // soundex_match - check if two strings have same Soundex code
    define(interp, "soundex_match", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::String(a), Value::String(b)) => {
                let code_a = compute_soundex(a);
                let code_b = compute_soundex(b);
                Ok(Value::Bool(code_a == code_b))
            }
            _ => Err(RuntimeError::new("soundex_match() requires two strings")),
        }
    });

    // metaphone - Metaphone encoding (better for English)
    define(interp, "metaphone", Some(1), |_, args| match &args[0] {
        Value::String(s) => {
            let code = compute_metaphone(s);
            Ok(Value::String(Rc::new(code)))
        }
        _ => Err(RuntimeError::new("metaphone() requires string")),
    });

    // metaphone_match - check if two strings have same Metaphone code
    define(interp, "metaphone_match", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::String(a), Value::String(b)) => {
                let code_a = compute_metaphone(a);
                let code_b = compute_metaphone(b);
                Ok(Value::Bool(code_a == code_b))
            }
            _ => Err(RuntimeError::new("metaphone_match() requires two strings")),
        }
    });

    // cologne_phonetic - Cologne phonetic encoding (for German)
    define(interp, "cologne_phonetic", Some(1), |_, args| {
        match &args[0] {
            Value::String(s) => {
                let code = compute_cologne(s);
                Ok(Value::String(Rc::new(code)))
            }
            _ => Err(RuntimeError::new("cologne_phonetic() requires string")),
        }
    });

    // =========================================================================
    // LANGUAGE DETECTION
    // =========================================================================

    // detect_language - detect the language of text
    define(interp, "detect_language", Some(1), |_, args| {
        match &args[0] {
            Value::String(s) => {
                if let Some(info) = detect(s) {
                    let lang_code = match info.lang() {
                        Lang::Eng => "en",
                        Lang::Spa => "es",
                        Lang::Fra => "fr",
                        Lang::Deu => "de",
                        Lang::Ita => "it",
                        Lang::Por => "pt",
                        Lang::Rus => "ru",
                        Lang::Ara => "ar",
                        Lang::Hin => "hi",
                        Lang::Cmn => "zh",
                        Lang::Jpn => "ja",
                        Lang::Kor => "ko",
                        Lang::Nld => "nl",
                        Lang::Swe => "sv",
                        Lang::Tur => "tr",
                        Lang::Pol => "pl",
                        Lang::Ukr => "uk",
                        Lang::Ces => "cs",
                        Lang::Dan => "da",
                        Lang::Fin => "fi",
                        Lang::Ell => "el",
                        Lang::Heb => "he",
                        Lang::Hun => "hu",
                        Lang::Ind => "id",
                        Lang::Nob => "no",
                        Lang::Ron => "ro",
                        Lang::Slk => "sk",
                        Lang::Tha => "th",
                        Lang::Vie => "vi",
                        _ => "unknown",
                    };
                    Ok(Value::String(Rc::new(lang_code.to_string())))
                } else {
                    Ok(Value::String(Rc::new("unknown".to_string())))
                }
            }
            _ => Err(RuntimeError::new("detect_language() requires string")),
        }
    });

    // detect_language_confidence - detect language with confidence score
    define(
        interp,
        "detect_language_confidence",
        Some(1),
        |_, args| match &args[0] {
            Value::String(s) => {
                if let Some(info) = detect(s) {
                    let lang_code = match info.lang() {
                        Lang::Eng => "en",
                        Lang::Spa => "es",
                        Lang::Fra => "fr",
                        Lang::Deu => "de",
                        Lang::Ita => "it",
                        Lang::Por => "pt",
                        Lang::Rus => "ru",
                        Lang::Ara => "ar",
                        Lang::Cmn => "zh",
                        Lang::Jpn => "ja",
                        _ => "unknown",
                    };
                    let confidence = info.confidence();
                    let mut map = HashMap::new();
                    map.insert(
                        "lang".to_string(),
                        Value::String(Rc::new(lang_code.to_string())),
                    );
                    map.insert("confidence".to_string(), Value::Float(confidence as f64));
                    Ok(Value::Map(Rc::new(RefCell::new(map))))
                } else {
                    let mut map = HashMap::new();
                    map.insert(
                        "lang".to_string(),
                        Value::String(Rc::new("unknown".to_string())),
                    );
                    map.insert("confidence".to_string(), Value::Float(0.0));
                    Ok(Value::Map(Rc::new(RefCell::new(map))))
                }
            }
            _ => Err(RuntimeError::new(
                "detect_language_confidence() requires string",
            )),
        },
    );

    // detect_script - detect the script of text using whatlang
    define(
        interp,
        "detect_script_whatlang",
        Some(1),
        |_, args| match &args[0] {
            Value::String(s) => {
                if let Some(info) = detect(s) {
                    let script_name = match info.script() {
                        WhatLangScript::Latin => "Latin",
                        WhatLangScript::Cyrillic => "Cyrillic",
                        WhatLangScript::Arabic => "Arabic",
                        WhatLangScript::Devanagari => "Devanagari",
                        WhatLangScript::Ethiopic => "Ethiopic",
                        WhatLangScript::Georgian => "Georgian",
                        WhatLangScript::Greek => "Greek",
                        WhatLangScript::Gujarati => "Gujarati",
                        WhatLangScript::Gurmukhi => "Gurmukhi",
                        WhatLangScript::Hangul => "Hangul",
                        WhatLangScript::Hebrew => "Hebrew",
                        WhatLangScript::Hiragana => "Hiragana",
                        WhatLangScript::Kannada => "Kannada",
                        WhatLangScript::Katakana => "Katakana",
                        WhatLangScript::Khmer => "Khmer",
                        WhatLangScript::Malayalam => "Malayalam",
                        WhatLangScript::Mandarin => "Mandarin",
                        WhatLangScript::Myanmar => "Myanmar",
                        WhatLangScript::Oriya => "Oriya",
                        WhatLangScript::Sinhala => "Sinhala",
                        WhatLangScript::Tamil => "Tamil",
                        WhatLangScript::Telugu => "Telugu",
                        WhatLangScript::Thai => "Thai",
                        WhatLangScript::Bengali => "Bengali",
                        WhatLangScript::Armenian => "Armenian",
                    };
                    Ok(Value::String(Rc::new(script_name.to_string())))
                } else {
                    Ok(Value::String(Rc::new("Unknown".to_string())))
                }
            }
            _ => Err(RuntimeError::new(
                "detect_script_whatlang() requires string",
            )),
        },
    );

    // is_language - check if text is in a specific language
    define(interp, "is_language", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::String(s), Value::String(lang)) => {
                if let Some(info) = detect(s) {
                    let detected = match info.lang() {
                        Lang::Eng => "en",
                        Lang::Spa => "es",
                        Lang::Fra => "fr",
                        Lang::Deu => "de",
                        Lang::Ita => "it",
                        Lang::Por => "pt",
                        Lang::Rus => "ru",
                        _ => "unknown",
                    };
                    Ok(Value::Bool(detected == lang.as_str()))
                } else {
                    Ok(Value::Bool(false))
                }
            }
            _ => Err(RuntimeError::new(
                "is_language() requires string and language code",
            )),
        }
    });

    // =========================================================================
    // LLM TOKEN COUNTING
    // =========================================================================

    // token_count - count tokens using cl100k_base (GPT-4, Claude compatible)
    define(interp, "token_count", Some(1), |_, args| match &args[0] {
        Value::String(s) => {
            if let Ok(bpe) = cl100k_base() {
                let tokens = bpe.encode_with_special_tokens(s);
                Ok(Value::Int(tokens.len() as i64))
            } else {
                Err(RuntimeError::new("Failed to initialize tokenizer"))
            }
        }
        _ => Err(RuntimeError::new("token_count() requires string")),
    });

    // token_count_model - count tokens for specific model
    define(interp, "token_count_model", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::String(s), Value::String(model)) => {
                let bpe_result = match model.as_str() {
                    "gpt4" | "gpt-4" | "claude" | "cl100k" => cl100k_base(),
                    "gpt3" | "gpt-3" | "p50k" => p50k_base(),
                    "codex" | "r50k" => r50k_base(),
                    _ => cl100k_base(), // Default to GPT-4/Claude
                };
                if let Ok(bpe) = bpe_result {
                    let tokens = bpe.encode_with_special_tokens(s);
                    Ok(Value::Int(tokens.len() as i64))
                } else {
                    Err(RuntimeError::new("Failed to initialize tokenizer"))
                }
            }
            _ => Err(RuntimeError::new(
                "token_count_model() requires string and model name",
            )),
        }
    });

    // tokenize_ids - get token IDs as array
    define(interp, "tokenize_ids", Some(1), |_, args| match &args[0] {
        Value::String(s) => {
            if let Ok(bpe) = cl100k_base() {
                let tokens = bpe.encode_with_special_tokens(s);
                let values: Vec<Value> = tokens.into_iter().map(|t| Value::Int(t as i64)).collect();
                Ok(Value::Array(Rc::new(RefCell::new(values))))
            } else {
                Err(RuntimeError::new("Failed to initialize tokenizer"))
            }
        }
        _ => Err(RuntimeError::new("tokenize_ids() requires string")),
    });

    // truncate_tokens - truncate string to max tokens
    define(interp, "truncate_tokens", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::String(s), Value::Int(max_tokens)) => {
                if let Ok(bpe) = cl100k_base() {
                    let tokens = bpe.encode_with_special_tokens(s);
                    if tokens.len() <= *max_tokens as usize {
                        Ok(Value::String(s.clone()))
                    } else {
                        let truncated: Vec<usize> =
                            tokens.into_iter().take(*max_tokens as usize).collect();
                        if let Ok(decoded) = bpe.decode(truncated) {
                            Ok(Value::String(Rc::new(decoded)))
                        } else {
                            Err(RuntimeError::new("Failed to decode tokens"))
                        }
                    }
                } else {
                    Err(RuntimeError::new("Failed to initialize tokenizer"))
                }
            }
            _ => Err(RuntimeError::new(
                "truncate_tokens() requires string and max tokens",
            )),
        }
    });

    // estimate_cost - estimate API cost based on token count
    define(interp, "estimate_cost", Some(3), |_, args| {
        match (&args[0], &args[1], &args[2]) {
            (Value::String(s), Value::Float(input_cost), Value::Float(output_cost)) => {
                if let Ok(bpe) = cl100k_base() {
                    let tokens = bpe.encode_with_special_tokens(s);
                    let count = tokens.len() as f64;
                    // Cost per 1K tokens
                    let input_total = (count / 1000.0) * input_cost;
                    let output_total = (count / 1000.0) * output_cost;
                    let mut map = HashMap::new();
                    map.insert("tokens".to_string(), Value::Int(tokens.len() as i64));
                    map.insert("input_cost".to_string(), Value::Float(input_total));
                    map.insert("output_cost".to_string(), Value::Float(output_total));
                    Ok(Value::Map(Rc::new(RefCell::new(map))))
                } else {
                    Err(RuntimeError::new("Failed to initialize tokenizer"))
                }
            }
            _ => Err(RuntimeError::new(
                "estimate_cost() requires string, input cost, output cost",
            )),
        }
    });

    // =========================================================================
    // STEMMING
    // =========================================================================

    // stem - stem a word using Porter algorithm
    define(interp, "stem", Some(1), |_, args| match &args[0] {
        Value::String(s) => {
            let stemmer = Stemmer::create(StemAlgorithm::English);
            let stemmed = stemmer.stem(s);
            Ok(Value::String(Rc::new(stemmed.to_string())))
        }
        _ => Err(RuntimeError::new("stem() requires string")),
    });

    // stem_language - stem a word for specific language
    define(interp, "stem_language", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::String(s), Value::String(lang)) => {
                let algorithm = match lang.as_str() {
                    "en" | "english" => StemAlgorithm::English,
                    "fr" | "french" => StemAlgorithm::French,
                    "de" | "german" => StemAlgorithm::German,
                    "es" | "spanish" => StemAlgorithm::Spanish,
                    "it" | "italian" => StemAlgorithm::Italian,
                    "pt" | "portuguese" => StemAlgorithm::Portuguese,
                    "nl" | "dutch" => StemAlgorithm::Dutch,
                    "sv" | "swedish" => StemAlgorithm::Swedish,
                    "no" | "norwegian" => StemAlgorithm::Norwegian,
                    "da" | "danish" => StemAlgorithm::Danish,
                    "fi" | "finnish" => StemAlgorithm::Finnish,
                    "ru" | "russian" => StemAlgorithm::Russian,
                    "ro" | "romanian" => StemAlgorithm::Romanian,
                    "hu" | "hungarian" => StemAlgorithm::Hungarian,
                    "tr" | "turkish" => StemAlgorithm::Turkish,
                    "ar" | "arabic" => StemAlgorithm::Arabic,
                    _ => StemAlgorithm::English,
                };
                let stemmer = Stemmer::create(algorithm);
                let stemmed = stemmer.stem(s);
                Ok(Value::String(Rc::new(stemmed.to_string())))
            }
            _ => Err(RuntimeError::new(
                "stem_language() requires string and language code",
            )),
        }
    });

    // stem_all - stem all words in array
    define(interp, "stem_all", Some(1), |_, args| match &args[0] {
        Value::Array(arr) => {
            let stemmer = Stemmer::create(StemAlgorithm::English);
            let arr_ref = arr.borrow();
            let results: Vec<Value> = arr_ref
                .iter()
                .filter_map(|v| {
                    if let Value::String(s) = v {
                        Some(Value::String(Rc::new(stemmer.stem(s).to_string())))
                    } else {
                        None
                    }
                })
                .collect();
            Ok(Value::Array(Rc::new(RefCell::new(results))))
        }
        _ => Err(RuntimeError::new("stem_all() requires array of strings")),
    });

    // =========================================================================
    // STOPWORDS
    // =========================================================================

    // is_stopword - check if word is a stopword
    define(interp, "is_stopword", Some(1), |_, args| match &args[0] {
        Value::String(s) => {
            let word = s.to_lowercase();
            let stopwords = get_stopwords("en");
            Ok(Value::Bool(stopwords.contains(&word.as_str())))
        }
        _ => Err(RuntimeError::new("is_stopword() requires string")),
    });

    // is_stopword_language - check if word is stopword in language
    define(interp, "is_stopword_language", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::String(s), Value::String(lang)) => {
                let word = s.to_lowercase();
                let stopwords = get_stopwords(lang);
                Ok(Value::Bool(stopwords.contains(&word.as_str())))
            }
            _ => Err(RuntimeError::new(
                "is_stopword_language() requires string and language",
            )),
        }
    });

    // remove_stopwords - remove stopwords from array
    define(interp, "remove_stopwords", Some(1), |_, args| {
        match &args[0] {
            Value::Array(arr) => {
                let stopwords = get_stopwords("en");
                let arr_ref = arr.borrow();
                let results: Vec<Value> = arr_ref
                    .iter()
                    .filter(|v| {
                        if let Value::String(s) = v {
                            !stopwords.contains(&s.to_lowercase().as_str())
                        } else {
                            true
                        }
                    })
                    .cloned()
                    .collect();
                Ok(Value::Array(Rc::new(RefCell::new(results))))
            }
            _ => Err(RuntimeError::new(
                "remove_stopwords() requires array of strings",
            )),
        }
    });

    // remove_stopwords_text - remove stopwords from text string
    define(
        interp,
        "remove_stopwords_text",
        Some(1),
        |_, args| match &args[0] {
            Value::String(s) => {
                let stopwords = get_stopwords("en");
                let words: Vec<&str> = s
                    .split_whitespace()
                    .filter(|w| !stopwords.contains(&w.to_lowercase().as_str()))
                    .collect();
                Ok(Value::String(Rc::new(words.join(" "))))
            }
            _ => Err(RuntimeError::new("remove_stopwords_text() requires string")),
        },
    );

    // get_stopwords_list - get list of stopwords for language
    define(
        interp,
        "get_stopwords_list",
        Some(1),
        |_, args| match &args[0] {
            Value::String(lang) => {
                let stopwords = get_stopwords(lang);
                let values: Vec<Value> = stopwords
                    .iter()
                    .map(|s| Value::String(Rc::new(s.to_string())))
                    .collect();
                Ok(Value::Array(Rc::new(RefCell::new(values))))
            }
            _ => Err(RuntimeError::new(
                "get_stopwords_list() requires language code",
            )),
        },
    );

    // =========================================================================
    // N-GRAMS AND SHINGLES
    // =========================================================================

    // ngrams - extract word n-grams
    define(interp, "ngrams", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::String(s), Value::Int(n)) => {
                let words: Vec<&str> = s.split_whitespace().collect();
                let n = *n as usize;
                if n == 0 || n > words.len() {
                    return Ok(Value::Array(Rc::new(RefCell::new(vec![]))));
                }
                let ngrams: Vec<Value> = words
                    .windows(n)
                    .map(|w| Value::String(Rc::new(w.join(" "))))
                    .collect();
                Ok(Value::Array(Rc::new(RefCell::new(ngrams))))
            }
            _ => Err(RuntimeError::new("ngrams() requires string and n")),
        }
    });

    // char_ngrams - extract character n-grams
    define(interp, "char_ngrams", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::String(s), Value::Int(n)) => {
                let chars: Vec<char> = s.chars().collect();
                let n = *n as usize;
                if n == 0 || n > chars.len() {
                    return Ok(Value::Array(Rc::new(RefCell::new(vec![]))));
                }
                let ngrams: Vec<Value> = chars
                    .windows(n)
                    .map(|w| Value::String(Rc::new(w.iter().collect())))
                    .collect();
                Ok(Value::Array(Rc::new(RefCell::new(ngrams))))
            }
            _ => Err(RuntimeError::new("char_ngrams() requires string and n")),
        }
    });

    // shingles - extract word shingles (same as ngrams, but as set)
    define(interp, "shingles", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::String(s), Value::Int(n)) => {
                let words: Vec<&str> = s.split_whitespace().collect();
                let n = *n as usize;
                if n == 0 || n > words.len() {
                    return Ok(Value::Array(Rc::new(RefCell::new(vec![]))));
                }
                let mut seen = std::collections::HashSet::new();
                let shingles: Vec<Value> = words
                    .windows(n)
                    .filter_map(|w| {
                        let s = w.join(" ");
                        if seen.insert(s.clone()) {
                            Some(Value::String(Rc::new(s)))
                        } else {
                            None
                        }
                    })
                    .collect();
                Ok(Value::Array(Rc::new(RefCell::new(shingles))))
            }
            _ => Err(RuntimeError::new("shingles() requires string and n")),
        }
    });

    // jaccard_similarity - Jaccard similarity between two sets of shingles
    define(interp, "jaccard_similarity", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::Array(a), Value::Array(b)) => {
                let a_ref = a.borrow();
                let b_ref = b.borrow();
                let set_a: std::collections::HashSet<String> = a_ref
                    .iter()
                    .filter_map(|v| {
                        if let Value::String(s) = v {
                            Some(s.to_string())
                        } else {
                            None
                        }
                    })
                    .collect();
                let set_b: std::collections::HashSet<String> = b_ref
                    .iter()
                    .filter_map(|v| {
                        if let Value::String(s) = v {
                            Some(s.to_string())
                        } else {
                            None
                        }
                    })
                    .collect();
                let intersection = set_a.intersection(&set_b).count();
                let union = set_a.union(&set_b).count();
                if union == 0 {
                    Ok(Value::Float(0.0))
                } else {
                    Ok(Value::Float(intersection as f64 / union as f64))
                }
            }
            _ => Err(RuntimeError::new(
                "jaccard_similarity() requires two arrays",
            )),
        }
    });

    // minhash_signature - compute MinHash signature for LSH
    define(interp, "minhash_signature", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::Array(arr), Value::Int(num_hashes)) => {
                let arr_ref = arr.borrow();
                let items: std::collections::HashSet<String> = arr_ref
                    .iter()
                    .filter_map(|v| {
                        if let Value::String(s) = v {
                            Some(s.to_string())
                        } else {
                            None
                        }
                    })
                    .collect();

                // Simple MinHash using polynomial rolling hash
                let mut signature: Vec<Value> = Vec::with_capacity(*num_hashes as usize);
                for i in 0..*num_hashes {
                    let mut min_hash: u64 = u64::MAX;
                    for item in &items {
                        let hash = compute_hash(item, i as u64);
                        if hash < min_hash {
                            min_hash = hash;
                        }
                    }
                    signature.push(Value::Int(min_hash as i64));
                }
                Ok(Value::Array(Rc::new(RefCell::new(signature))))
            }
            _ => Err(RuntimeError::new(
                "minhash_signature() requires array and num_hashes",
            )),
        }
    });

    // =========================================================================
    // TEXT PREPROCESSING
    // =========================================================================

    // preprocess_text - full text preprocessing pipeline
    define(interp, "preprocess_text", Some(1), |_, args| {
        match &args[0] {
            Value::String(s) => {
                // Lowercase
                let lower = s.to_lowercase();
                // Remove punctuation (keep letters, numbers, spaces)
                let clean: String = lower
                    .chars()
                    .filter(|c| c.is_alphanumeric() || c.is_whitespace())
                    .collect();
                // Normalize whitespace
                let normalized: String = clean.split_whitespace().collect::<Vec<_>>().join(" ");
                Ok(Value::String(Rc::new(normalized)))
            }
            _ => Err(RuntimeError::new("preprocess_text() requires string")),
        }
    });

    // tokenize_words - split text into word tokens
    define(interp, "tokenize_words", Some(1), |_, args| {
        match &args[0] {
            Value::String(s) => {
                let words: Vec<Value> = s
                    .split_whitespace()
                    .map(|w| Value::String(Rc::new(w.to_string())))
                    .collect();
                Ok(Value::Array(Rc::new(RefCell::new(words))))
            }
            _ => Err(RuntimeError::new("tokenize_words() requires string")),
        }
    });

    // extract_keywords - extract likely keywords (content words)
    define(interp, "extract_keywords", Some(1), |_, args| {
        match &args[0] {
            Value::String(s) => {
                let stopwords = get_stopwords("en");
                let words: Vec<Value> = s
                    .split_whitespace()
                    .filter(|w| {
                        let lower = w.to_lowercase();
                        !stopwords.contains(&lower.as_str()) && lower.len() > 2
                    })
                    .map(|w| Value::String(Rc::new(w.to_lowercase())))
                    .collect();
                Ok(Value::Array(Rc::new(RefCell::new(words))))
            }
            _ => Err(RuntimeError::new("extract_keywords() requires string")),
        }
    });

    // word_frequency - count word frequencies
    define(interp, "word_frequency", Some(1), |_, args| {
        match &args[0] {
            Value::String(s) => {
                let mut freq: HashMap<String, i64> = HashMap::new();
                for word in s.split_whitespace() {
                    let lower = word.to_lowercase();
                    *freq.entry(lower).or_insert(0) += 1;
                }
                let map: HashMap<String, Value> =
                    freq.into_iter().map(|(k, v)| (k, Value::Int(v))).collect();
                Ok(Value::Map(Rc::new(RefCell::new(map))))
            }
            _ => Err(RuntimeError::new("word_frequency() requires string")),
        }
    });

    // =========================================================================
    // AFFECTIVE MARKERS (Emotional Intelligence)
    // =========================================================================

    // sentiment_words - basic sentiment word detection
    define(interp, "sentiment_words", Some(1), |_, args| {
        match &args[0] {
            Value::String(s) => {
                let positive = vec![
                    "good",
                    "great",
                    "excellent",
                    "amazing",
                    "wonderful",
                    "fantastic",
                    "love",
                    "happy",
                    "joy",
                    "beautiful",
                    "awesome",
                    "perfect",
                    "best",
                    "brilliant",
                    "delightful",
                    "pleasant",
                    "positive",
                ];
                let negative = vec![
                    "bad",
                    "terrible",
                    "awful",
                    "horrible",
                    "hate",
                    "sad",
                    "angry",
                    "worst",
                    "poor",
                    "negative",
                    "disappointing",
                    "ugly",
                    "disgusting",
                    "painful",
                    "miserable",
                    "annoying",
                ];

                let lower = s.to_lowercase();
                let words: Vec<&str> = lower.split_whitespace().collect();
                let pos_count: i64 = words.iter().filter(|w| positive.contains(w)).count() as i64;
                let neg_count: i64 = words.iter().filter(|w| negative.contains(w)).count() as i64;

                let mut map = HashMap::new();
                map.insert("positive".to_string(), Value::Int(pos_count));
                map.insert("negative".to_string(), Value::Int(neg_count));
                map.insert("total".to_string(), Value::Int(words.len() as i64));

                let score = if pos_count + neg_count > 0 {
                    (pos_count - neg_count) as f64 / (pos_count + neg_count) as f64
                } else {
                    0.0
                };
                map.insert("score".to_string(), Value::Float(score));

                Ok(Value::Map(Rc::new(RefCell::new(map))))
            }
            _ => Err(RuntimeError::new("sentiment_words() requires string")),
        }
    });

    // has_question - detect if text contains a question
    define(interp, "has_question", Some(1), |_, args| match &args[0] {
        Value::String(s) => {
            let has_q_mark = s.contains('?');
            let lower = s.to_lowercase();
            let question_words = [
                "what", "where", "when", "why", "how", "who", "which", "whose", "whom",
            ];
            let starts_with_q = question_words.iter().any(|w| lower.starts_with(w));
            Ok(Value::Bool(has_q_mark || starts_with_q))
        }
        _ => Err(RuntimeError::new("has_question() requires string")),
    });

    // has_exclamation - detect if text has strong emotion markers
    define(interp, "has_exclamation", Some(1), |_, args| {
        match &args[0] {
            Value::String(s) => Ok(Value::Bool(s.contains('!'))),
            _ => Err(RuntimeError::new("has_exclamation() requires string")),
        }
    });

    // text_formality - estimate text formality (0=informal, 1=formal)
    define(interp, "text_formality", Some(1), |_, args| {
        match &args[0] {
            Value::String(s) => {
                let lower = s.to_lowercase();
                let informal_markers = vec![
                    "gonna", "wanna", "gotta", "kinda", "sorta", "dunno", "yeah", "yep", "nope",
                    "ok", "lol", "omg", "btw", "u", "ur", "r", "y", "2", "4",
                ];
                let formal_markers = vec![
                    "therefore",
                    "furthermore",
                    "moreover",
                    "consequently",
                    "nevertheless",
                    "however",
                    "whereas",
                    "hereby",
                    "respectfully",
                    "sincerely",
                    "accordingly",
                ];

                let words: Vec<&str> = lower.split_whitespace().collect();
                let informal_count = words
                    .iter()
                    .filter(|w| informal_markers.contains(w))
                    .count();
                let formal_count = words.iter().filter(|w| formal_markers.contains(w)).count();

                let score = if informal_count + formal_count > 0 {
                    formal_count as f64 / (informal_count + formal_count) as f64
                } else {
                    0.5 // Neutral if no markers
                };

                Ok(Value::Float(score))
            }
            _ => Err(RuntimeError::new("text_formality() requires string")),
        }
    });

    // =========================================================================
    // VADER-STYLE SENTIMENT ANALYSIS
    // =========================================================================

    // sentiment_vader - VADER-inspired sentiment analysis with intensity
    define(interp, "sentiment_vader", Some(1), |_, args| {
        match &args[0] {
            Value::String(s) => {
                let result = compute_vader_sentiment(s);
                let mut map = HashMap::new();
                map.insert("positive".to_string(), Value::Float(result.0));
                map.insert("negative".to_string(), Value::Float(result.1));
                map.insert("neutral".to_string(), Value::Float(result.2));
                map.insert("compound".to_string(), Value::Float(result.3));
                Ok(Value::Map(Rc::new(RefCell::new(map))))
            }
            _ => Err(RuntimeError::new("sentiment_vader() requires string")),
        }
    });

    // emotion_detect - detect specific emotions
    define(interp, "emotion_detect", Some(1), |_, args| {
        match &args[0] {
            Value::String(s) => {
                let emotions = compute_emotions(s);
                let map: HashMap<String, Value> = emotions
                    .into_iter()
                    .map(|(k, v)| (k, Value::Float(v)))
                    .collect();
                Ok(Value::Map(Rc::new(RefCell::new(map))))
            }
            _ => Err(RuntimeError::new("emotion_detect() requires string")),
        }
    });

    // intensity_words - detect intensity modifiers
    define(interp, "intensity_score", Some(1), |_, args| {
        match &args[0] {
            Value::String(s) => {
                let score = compute_intensity(s);
                Ok(Value::Float(score))
            }
            _ => Err(RuntimeError::new("intensity_score() requires string")),
        }
    });

    // =========================================================================
    // SARCASM AND IRONY DETECTION
    // =========================================================================

    // detect_sarcasm - detect potential sarcasm/irony markers
    define(interp, "detect_sarcasm", Some(1), |_, args| {
        match &args[0] {
            Value::String(s) => {
                let result = compute_sarcasm_score(s);
                let mut map = HashMap::new();
                map.insert("score".to_string(), Value::Float(result.0));
                map.insert("confidence".to_string(), Value::Float(result.1));
                let markers: Vec<Value> = result
                    .2
                    .into_iter()
                    .map(|m| Value::String(Rc::new(m)))
                    .collect();
                map.insert(
                    "markers".to_string(),
                    Value::Array(Rc::new(RefCell::new(markers))),
                );
                Ok(Value::Map(Rc::new(RefCell::new(map))))
            }
            _ => Err(RuntimeError::new("detect_sarcasm() requires string")),
        }
    });

    // is_sarcastic - simple boolean sarcasm check
    define(interp, "is_sarcastic", Some(1), |_, args| match &args[0] {
        Value::String(s) => {
            let result = compute_sarcasm_score(s);
            Ok(Value::Bool(result.0 > 0.5))
        }
        _ => Err(RuntimeError::new("is_sarcastic() requires string")),
    });

    // detect_irony - detect verbal irony patterns
    define(interp, "detect_irony", Some(1), |_, args| match &args[0] {
        Value::String(s) => {
            let score = compute_irony_score(s);
            Ok(Value::Float(score))
        }
        _ => Err(RuntimeError::new("detect_irony() requires string")),
    });

    // =========================================================================
    // NAMED ENTITY RECOGNITION (Pattern-based)
    // =========================================================================

    // extract_emails - extract email addresses
    define(interp, "extract_emails", Some(1), |_, args| {
        match &args[0] {
            Value::String(s) => {
                let re = Regex::new(r"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}").unwrap();
                let emails: Vec<Value> = re
                    .find_iter(s)
                    .map(|m| Value::String(Rc::new(m.as_str().to_string())))
                    .collect();
                Ok(Value::Array(Rc::new(RefCell::new(emails))))
            }
            _ => Err(RuntimeError::new("extract_emails() requires string")),
        }
    });

    // extract_urls - extract URLs
    define(interp, "extract_urls", Some(1), |_, args| match &args[0] {
        Value::String(s) => {
            let re = Regex::new(r"https?://[^\s<>\[\]{}|\\^]+").unwrap();
            let urls: Vec<Value> = re
                .find_iter(s)
                .map(|m| Value::String(Rc::new(m.as_str().to_string())))
                .collect();
            Ok(Value::Array(Rc::new(RefCell::new(urls))))
        }
        _ => Err(RuntimeError::new("extract_urls() requires string")),
    });

    // extract_phone_numbers - extract phone numbers
    define(
        interp,
        "extract_phone_numbers",
        Some(1),
        |_, args| match &args[0] {
            Value::String(s) => {
                let re =
                    Regex::new(r"(?:\+?1[-.\s]?)?\(?[0-9]{3}\)?[-.\s]?[0-9]{3}[-.\s]?[0-9]{4}")
                        .unwrap();
                let phones: Vec<Value> = re
                    .find_iter(s)
                    .map(|m| Value::String(Rc::new(m.as_str().to_string())))
                    .collect();
                Ok(Value::Array(Rc::new(RefCell::new(phones))))
            }
            _ => Err(RuntimeError::new("extract_phone_numbers() requires string")),
        },
    );

    // extract_dates - extract date patterns
    define(interp, "extract_dates", Some(1), |_, args| {
        match &args[0] {
            Value::String(s) => {
                // Various date formats
                let patterns = vec![
                    r"\d{4}-\d{2}-\d{2}", // 2024-01-15
                    r"\d{2}/\d{2}/\d{4}", // 01/15/2024
                    r"\d{2}-\d{2}-\d{4}", // 01-15-2024
                    r"(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\s+\d{1,2},?\s+\d{4}",
                    r"\d{1,2}\s+(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\s+\d{4}",
                ];
                let mut dates = Vec::new();
                for pattern in patterns {
                    if let Ok(re) = Regex::new(pattern) {
                        for m in re.find_iter(s) {
                            dates.push(Value::String(Rc::new(m.as_str().to_string())));
                        }
                    }
                }
                Ok(Value::Array(Rc::new(RefCell::new(dates))))
            }
            _ => Err(RuntimeError::new("extract_dates() requires string")),
        }
    });

    // extract_money - extract monetary values
    define(interp, "extract_money", Some(1), |_, args| match &args[0] {
        Value::String(s) => {
            let re = Regex::new(r"[$€£¥]\s*\d+(?:,\d{3})*(?:\.\d{2})?|\d+(?:,\d{3})*(?:\.\d{2})?\s*(?:dollars?|euros?|pounds?|USD|EUR|GBP)").unwrap();
            let money: Vec<Value> = re
                .find_iter(s)
                .map(|m| Value::String(Rc::new(m.as_str().to_string())))
                .collect();
            Ok(Value::Array(Rc::new(RefCell::new(money))))
        }
        _ => Err(RuntimeError::new("extract_money() requires string")),
    });

    // extract_hashtags - extract hashtags
    define(interp, "extract_hashtags", Some(1), |_, args| {
        match &args[0] {
            Value::String(s) => {
                let re = Regex::new(r"#\w+").unwrap();
                let tags: Vec<Value> = re
                    .find_iter(s)
                    .map(|m| Value::String(Rc::new(m.as_str().to_string())))
                    .collect();
                Ok(Value::Array(Rc::new(RefCell::new(tags))))
            }
            _ => Err(RuntimeError::new("extract_hashtags() requires string")),
        }
    });

    // extract_mentions - extract @mentions
    define(interp, "extract_mentions", Some(1), |_, args| {
        match &args[0] {
            Value::String(s) => {
                let re = Regex::new(r"@\w+").unwrap();
                let mentions: Vec<Value> = re
                    .find_iter(s)
                    .map(|m| Value::String(Rc::new(m.as_str().to_string())))
                    .collect();
                Ok(Value::Array(Rc::new(RefCell::new(mentions))))
            }
            _ => Err(RuntimeError::new("extract_mentions() requires string")),
        }
    });

    // extract_numbers - extract all numbers
    define(interp, "extract_numbers", Some(1), |_, args| {
        match &args[0] {
            Value::String(s) => {
                let re = Regex::new(r"-?\d+(?:,\d{3})*(?:\.\d+)?").unwrap();
                let numbers: Vec<Value> = re
                    .find_iter(s)
                    .filter_map(|m| {
                        let num_str = m.as_str().replace(",", "");
                        if let Ok(n) = num_str.parse::<f64>() {
                            Some(Value::Float(n))
                        } else {
                            None
                        }
                    })
                    .collect();
                Ok(Value::Array(Rc::new(RefCell::new(numbers))))
            }
            _ => Err(RuntimeError::new("extract_numbers() requires string")),
        }
    });

    // extract_entities - extract likely named entities (capitalized words)
    define(interp, "extract_entities", Some(1), |_, args| {
        match &args[0] {
            Value::String(s) => {
                // Simple heuristic: capitalized words not at sentence start
                let re = Regex::new(r"(?:[.!?]\s+)?([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)").unwrap();
                let mut entities = std::collections::HashSet::new();
                for cap in re.captures_iter(s) {
                    if let Some(m) = cap.get(1) {
                        let entity = m.as_str().to_string();
                        // Filter out common sentence starters
                        let starters = [
                            "The", "A", "An", "This", "That", "It", "I", "We", "They", "He", "She",
                        ];
                        if !starters.contains(&entity.as_str()) {
                            entities.insert(entity);
                        }
                    }
                }
                let results: Vec<Value> = entities
                    .into_iter()
                    .map(|e| Value::String(Rc::new(e)))
                    .collect();
                Ok(Value::Array(Rc::new(RefCell::new(results))))
            }
            _ => Err(RuntimeError::new("extract_entities() requires string")),
        }
    });

    // =========================================================================
    // TEXT EMBEDDINGS (Hash-based, no ML required)
    // =========================================================================

    // text_hash_vector - create a simple hash-based embedding
    define(interp, "text_hash_vector", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::String(s), Value::Int(dims)) => {
                let dims = *dims as usize;
                let mut vector = vec![0.0f64; dims];

                // Hash each word and add to vector
                for word in s.to_lowercase().split_whitespace() {
                    let hash = compute_hash(word, 0);
                    let idx = (hash as usize) % dims;
                    vector[idx] += 1.0;
                }

                // Normalize
                let magnitude: f64 = vector.iter().map(|x| x * x).sum::<f64>().sqrt();
                if magnitude > 0.0 {
                    for v in vector.iter_mut() {
                        *v /= magnitude;
                    }
                }

                let values: Vec<Value> = vector.into_iter().map(Value::Float).collect();
                Ok(Value::Array(Rc::new(RefCell::new(values))))
            }
            _ => Err(RuntimeError::new(
                "text_hash_vector() requires string and dimensions",
            )),
        }
    });

    // text_fingerprint - create a compact fingerprint of text
    define(interp, "text_fingerprint", Some(1), |_, args| {
        match &args[0] {
            Value::String(s) => {
                // Create 64-bit fingerprint using multiple hashes
                let lower = s.to_lowercase();
                let words: Vec<&str> = lower.split_whitespace().collect();

                let mut fp: u64 = 0;
                for (i, word) in words.iter().enumerate() {
                    let h = compute_hash(word, i as u64);
                    fp ^= h.rotate_left((i % 64) as u32);
                }

                Ok(Value::String(Rc::new(format!("{:016x}", fp))))
            }
            _ => Err(RuntimeError::new("text_fingerprint() requires string")),
        }
    });

    // cosine_similarity - compute cosine similarity between two vectors
    define(interp, "cosine_similarity", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::Array(a), Value::Array(b)) => {
                let a_ref = a.borrow();
                let b_ref = b.borrow();

                if a_ref.len() != b_ref.len() {
                    return Err(RuntimeError::new("Vectors must have same length"));
                }

                let mut dot = 0.0;
                let mut mag_a = 0.0;
                let mut mag_b = 0.0;

                for (va, vb) in a_ref.iter().zip(b_ref.iter()) {
                    let fa = match va {
                        Value::Float(f) => *f,
                        Value::Int(i) => *i as f64,
                        _ => continue,
                    };
                    let fb = match vb {
                        Value::Float(f) => *f,
                        Value::Int(i) => *i as f64,
                        _ => continue,
                    };
                    dot += fa * fb;
                    mag_a += fa * fa;
                    mag_b += fb * fb;
                }

                let denom = (mag_a.sqrt()) * (mag_b.sqrt());
                if denom == 0.0 {
                    Ok(Value::Float(0.0))
                } else {
                    Ok(Value::Float(dot / denom))
                }
            }
            _ => Err(RuntimeError::new("cosine_similarity() requires two arrays")),
        }
    });

    // text_similarity_embedding - compare texts using hash embeddings
    define(interp, "text_similarity_embedding", Some(2), |_, args| {
        match (&args[0], &args[1]) {
            (Value::String(a), Value::String(b)) => {
                let dims = 128;

                // Create vectors for both texts
                let vec_a = create_hash_vector(a, dims);
                let vec_b = create_hash_vector(b, dims);

                // Compute cosine similarity
                let mut dot = 0.0;
                let mut mag_a = 0.0;
                let mut mag_b = 0.0;

                for i in 0..dims {
                    dot += vec_a[i] * vec_b[i];
                    mag_a += vec_a[i] * vec_a[i];
                    mag_b += vec_b[i] * vec_b[i];
                }

                let denom = (mag_a.sqrt()) * (mag_b.sqrt());
                if denom == 0.0 {
                    Ok(Value::Float(0.0))
                } else {
                    Ok(Value::Float(dot / denom))
                }
            }
            _ => Err(RuntimeError::new(
                "text_similarity_embedding() requires two strings",
            )),
        }
    });

    // =========================================================================
    // READABILITY METRICS
    // =========================================================================

    // flesch_reading_ease - Flesch Reading Ease score
    define(
        interp,
        "flesch_reading_ease",
        Some(1),
        |_, args| match &args[0] {
            Value::String(s) => {
                let (words, sentences, syllables) = count_text_stats(s);
                if words == 0 || sentences == 0 {
                    return Ok(Value::Float(0.0));
                }
                let score = 206.835
                    - 1.015 * (words as f64 / sentences as f64)
                    - 84.6 * (syllables as f64 / words as f64);
                Ok(Value::Float(score.max(0.0).min(100.0)))
            }
            _ => Err(RuntimeError::new("flesch_reading_ease() requires string")),
        },
    );

    // flesch_kincaid_grade - Flesch-Kincaid Grade Level
    define(
        interp,
        "flesch_kincaid_grade",
        Some(1),
        |_, args| match &args[0] {
            Value::String(s) => {
                let (words, sentences, syllables) = count_text_stats(s);
                if words == 0 || sentences == 0 {
                    return Ok(Value::Float(0.0));
                }
                let grade = 0.39 * (words as f64 / sentences as f64)
                    + 11.8 * (syllables as f64 / words as f64)
                    - 15.59;
                Ok(Value::Float(grade.max(0.0)))
            }
            _ => Err(RuntimeError::new("flesch_kincaid_grade() requires string")),
        },
    );

    // automated_readability_index - ARI score
    define(
        interp,
        "automated_readability_index",
        Some(1),
        |_, args| match &args[0] {
            Value::String(s) => {
                let chars: usize = s.chars().filter(|c| c.is_alphanumeric()).count();
                let words: usize = s.split_whitespace().count();
                let sentences: usize = s
                    .matches(|c| c == '.' || c == '!' || c == '?')
                    .count()
                    .max(1);

                if words == 0 {
                    return Ok(Value::Float(0.0));
                }

                let ari = 4.71 * (chars as f64 / words as f64)
                    + 0.5 * (words as f64 / sentences as f64)
                    - 21.43;
                Ok(Value::Float(ari.max(0.0)))
            }
            _ => Err(RuntimeError::new(
                "automated_readability_index() requires string",
            )),
        },
    );

    // reading_time - estimated reading time in minutes
    define(interp, "reading_time", Some(1), |_, args| {
        match &args[0] {
            Value::String(s) => {
                let words = s.split_whitespace().count();
                let minutes = words as f64 / 200.0; // Average reading speed
                Ok(Value::Float(minutes))
            }
            _ => Err(RuntimeError::new("reading_time() requires string")),
        }
    });

    // speaking_time - estimated speaking time in minutes
    define(interp, "speaking_time", Some(1), |_, args| {
        match &args[0] {
            Value::String(s) => {
                let words = s.split_whitespace().count();
                let minutes = words as f64 / 150.0; // Average speaking speed
                Ok(Value::Float(minutes))
            }
            _ => Err(RuntimeError::new("speaking_time() requires string")),
        }
    });
}

// =============================================================================
// HELPER FUNCTIONS FOR TEXT INTELLIGENCE
// =============================================================================

/// VADER-style sentiment computation
fn compute_vader_sentiment(s: &str) -> (f64, f64, f64, f64) {
    // Sentiment lexicon with intensity
    let positive_words: Vec<(&str, f64)> = vec![
        ("love", 3.0),
        ("loved", 3.0),
        ("loving", 3.0),
        ("excellent", 3.0),
        ("amazing", 3.0),
        ("fantastic", 3.0),
        ("wonderful", 3.0),
        ("great", 2.5),
        ("awesome", 2.5),
        ("brilliant", 2.5),
        ("superb", 2.5),
        ("good", 2.0),
        ("nice", 2.0),
        ("pleasant", 2.0),
        ("happy", 2.0),
        ("like", 1.5),
        ("enjoy", 1.5),
        ("fine", 1.5),
        ("okay", 1.0),
        ("best", 3.0),
        ("perfect", 3.0),
        ("beautiful", 2.5),
        ("delightful", 2.5),
        ("excited", 2.5),
        ("thrilled", 3.0),
        ("glad", 2.0),
        ("pleased", 2.0),
    ];

    let negative_words: Vec<(&str, f64)> = vec![
        ("hate", 3.0),
        ("hated", 3.0),
        ("hating", 3.0),
        ("terrible", 3.0),
        ("horrible", 3.0),
        ("awful", 3.0),
        ("disgusting", 3.0),
        ("bad", 2.5),
        ("poor", 2.5),
        ("worst", 3.0),
        ("pathetic", 2.5),
        ("sad", 2.0),
        ("angry", 2.5),
        ("upset", 2.0),
        ("disappointed", 2.0),
        ("dislike", 1.5),
        ("annoying", 2.0),
        ("boring", 1.5),
        ("mediocre", 1.0),
        ("ugly", 2.5),
        ("stupid", 2.5),
        ("dumb", 2.0),
        ("useless", 2.5),
        ("painful", 2.5),
        ("miserable", 3.0),
        ("depressing", 2.5),
        ("frustrating", 2.0),
    ];

    // Intensity modifiers
    let boosters = vec![
        "very",
        "really",
        "extremely",
        "absolutely",
        "incredibly",
        "totally",
        "so",
    ];
    let dampeners = vec![
        "somewhat", "slightly", "a bit", "kind of", "sort of", "barely",
    ];

    let lower = s.to_lowercase();
    let words: Vec<&str> = lower.split_whitespace().collect();

    let mut pos_score = 0.0;
    let mut neg_score = 0.0;
    let mut word_count = 0;

    for (i, word) in words.iter().enumerate() {
        let mut modifier = 1.0;

        // Check for boosters/dampeners before this word
        if i > 0 {
            if boosters.contains(&words[i - 1]) {
                modifier = 1.5;
            } else if dampeners.iter().any(|d| words[i - 1].contains(d)) {
                modifier = 0.5;
            }
        }

        // Check for negation
        let negated = i > 0
            && [
                "not",
                "no",
                "never",
                "neither",
                "don't",
                "doesn't",
                "didn't",
                "won't",
                "wouldn't",
                "couldn't",
                "shouldn't",
            ]
            .contains(&words[i - 1]);

        if let Some((_, score)) = positive_words.iter().find(|(w, _)| w == word) {
            if negated {
                neg_score += score * modifier;
            } else {
                pos_score += score * modifier;
            }
            word_count += 1;
        } else if let Some((_, score)) = negative_words.iter().find(|(w, _)| w == word) {
            if negated {
                pos_score += score * modifier * 0.5; // Negated negative is mildly positive
            } else {
                neg_score += score * modifier;
            }
            word_count += 1;
        }
    }

    // Normalize scores
    let total = pos_score + neg_score;
    let (pos_norm, neg_norm) = if total > 0.0 {
        (pos_score / total, neg_score / total)
    } else {
        (0.0, 0.0)
    };

    let neutral = 1.0 - pos_norm - neg_norm;

    // Compound score: normalized to [-1, 1]
    let compound = if word_count > 0 {
        ((pos_score - neg_score) / (word_count as f64 * 3.0))
            .max(-1.0)
            .min(1.0)
    } else {
        0.0
    };

    (pos_norm, neg_norm, neutral.max(0.0), compound)
}

/// Detect specific emotions
fn compute_emotions(s: &str) -> HashMap<String, f64> {
    let emotion_words: Vec<(&str, &str)> = vec![
        // Joy
        ("happy", "joy"),
        ("joyful", "joy"),
        ("delighted", "joy"),
        ("cheerful", "joy"),
        ("excited", "joy"),
        ("thrilled", "joy"),
        ("ecstatic", "joy"),
        ("elated", "joy"),
        // Sadness
        ("sad", "sadness"),
        ("unhappy", "sadness"),
        ("depressed", "sadness"),
        ("miserable", "sadness"),
        ("gloomy", "sadness"),
        ("heartbroken", "sadness"),
        ("sorrowful", "sadness"),
        ("melancholy", "sadness"),
        // Anger
        ("angry", "anger"),
        ("furious", "anger"),
        ("enraged", "anger"),
        ("irritated", "anger"),
        ("annoyed", "anger"),
        ("outraged", "anger"),
        ("livid", "anger"),
        ("mad", "anger"),
        // Fear
        ("afraid", "fear"),
        ("scared", "fear"),
        ("terrified", "fear"),
        ("frightened", "fear"),
        ("anxious", "fear"),
        ("worried", "fear"),
        ("nervous", "fear"),
        ("panicked", "fear"),
        // Surprise
        ("surprised", "surprise"),
        ("amazed", "surprise"),
        ("astonished", "surprise"),
        ("shocked", "surprise"),
        ("stunned", "surprise"),
        ("startled", "surprise"),
        ("bewildered", "surprise"),
        // Disgust
        ("disgusted", "disgust"),
        ("revolted", "disgust"),
        ("repulsed", "disgust"),
        ("sickened", "disgust"),
        ("nauseated", "disgust"),
        ("appalled", "disgust"),
        // Trust
        ("trust", "trust"),
        ("confident", "trust"),
        ("secure", "trust"),
        ("reliable", "trust"),
        ("faithful", "trust"),
        ("loyal", "trust"),
        // Anticipation
        ("eager", "anticipation"),
        ("hopeful", "anticipation"),
        ("expectant", "anticipation"),
        ("looking forward", "anticipation"),
        ("excited", "anticipation"),
    ];

    let lower = s.to_lowercase();
    let mut counts: HashMap<String, f64> = HashMap::new();

    for (word, emotion) in emotion_words {
        if lower.contains(word) {
            *counts.entry(emotion.to_string()).or_insert(0.0) += 1.0;
        }
    }

    // Normalize
    let total: f64 = counts.values().sum();
    if total > 0.0 {
        for v in counts.values_mut() {
            *v /= total;
        }
    }

    counts
}

/// Compute text intensity
fn compute_intensity(s: &str) -> f64 {
    let intensifiers = vec![
        ("very", 1.5),
        ("really", 1.5),
        ("extremely", 2.0),
        ("incredibly", 2.0),
        ("absolutely", 2.0),
        ("totally", 1.5),
        ("completely", 1.5),
        ("utterly", 2.0),
        ("so", 1.3),
        ("such", 1.3),
        ("quite", 1.2),
        ("rather", 1.1),
    ];

    let exclamation_boost = 0.5;
    let caps_boost = 0.3;

    let lower = s.to_lowercase();
    let mut score = 1.0;

    for (word, boost) in intensifiers {
        if lower.contains(word) {
            score *= boost;
        }
    }

    // Check for exclamation marks
    let exclamations = s.matches('!').count();
    score += exclamations as f64 * exclamation_boost;

    // Check for ALL CAPS words
    let caps_words = s
        .split_whitespace()
        .filter(|w| w.len() > 2 && w.chars().all(|c| c.is_uppercase()))
        .count();
    score += caps_words as f64 * caps_boost;

    score.min(5.0)
}

/// Detect sarcasm markers
fn compute_sarcasm_score(s: &str) -> (f64, f64, Vec<String>) {
    let mut markers = Vec::new();
    let mut score: f64 = 0.0;

    let lower = s.to_lowercase();

    // Explicit sarcasm markers
    let explicit = vec![
        "/s",
        "not!",
        "yeah right",
        "sure thing",
        "oh really",
        "oh great",
        "wow, just wow",
        "thanks a lot",
        "how wonderful",
        "isn't that special",
        "clearly",
        "obviously",
        "shocking",
        "no way",
        "what a surprise",
    ];

    for marker in &explicit {
        if lower.contains(marker) {
            markers.push(format!("explicit: {}", marker));
            score += 0.4;
        }
    }

    // Hyperbolic expressions
    let hyperbolic = vec![
        "best thing ever",
        "worst thing ever",
        "literally dying",
        "absolutely perfect",
        "world's greatest",
        "totally awesome",
        "so much fun",
        "couldn't be happier",
    ];

    for h in &hyperbolic {
        if lower.contains(h) {
            markers.push(format!("hyperbole: {}", h));
            score += 0.3;
        }
    }

    // Positive-negative contradiction patterns
    let has_positive = ["great", "wonderful", "amazing", "love", "best", "awesome"]
        .iter()
        .any(|w| lower.contains(w));
    let has_negative_context = ["but", "however", "although", "except", "unfortunately"]
        .iter()
        .any(|w| lower.contains(w));

    if has_positive && has_negative_context {
        markers.push("positive-negative contrast".to_string());
        score += 0.25;
    }

    // Quotation marks around positive words (air quotes)
    let quote_pattern = Regex::new(r#"["'](\w+)["']"#).unwrap();
    for cap in quote_pattern.captures_iter(s) {
        if let Some(m) = cap.get(1) {
            let word = m.as_str().to_lowercase();
            if [
                "great",
                "wonderful",
                "helpful",
                "useful",
                "smart",
                "genius",
                "brilliant",
            ]
            .contains(&word.as_str())
            {
                markers.push(format!("air quotes: \"{}\"", word));
                score += 0.35;
            }
        }
    }

    // Excessive punctuation
    if s.contains("...") || s.contains("!!!") || s.contains("???") {
        markers.push("excessive punctuation".to_string());
        score += 0.15;
    }

    // Calculate confidence based on number of markers
    let confidence = if markers.is_empty() {
        0.0
    } else {
        (markers.len() as f64 * 0.25).min(1.0)
    };

    (score.min(1.0), confidence, markers)
}

/// Detect irony patterns
fn compute_irony_score(s: &str) -> f64 {
    let mut score: f64 = 0.0;
    let lower = s.to_lowercase();

    // Situational irony markers
    let irony_phrases = vec![
        "of course",
        "as expected",
        "naturally",
        "predictably",
        "who would have thought",
        "surprise surprise",
        "go figure",
        "typical",
        "as usual",
        "yet again",
        "once again",
    ];

    for phrase in irony_phrases {
        if lower.contains(phrase) {
            score += 0.2;
        }
    }

    // Contrast indicators
    if lower.contains("but") || lower.contains("yet") || lower.contains("however") {
        score += 0.1;
    }

    // Rhetorical questions
    if s.contains('?')
        && (lower.starts_with("isn't")
            || lower.starts_with("aren't")
            || lower.starts_with("doesn't")
            || lower.starts_with("don't")
            || lower.contains("right?")
            || lower.contains("isn't it"))
    {
        score += 0.25;
    }

    score.min(1.0)
}

/// Create hash-based vector for text
fn create_hash_vector(s: &str, dims: usize) -> Vec<f64> {
    let mut vector = vec![0.0f64; dims];

    for word in s.to_lowercase().split_whitespace() {
        let hash = compute_hash(word, 0);
        let idx = (hash as usize) % dims;
        vector[idx] += 1.0;
    }

    // Normalize
    let magnitude: f64 = vector.iter().map(|x| x * x).sum::<f64>().sqrt();
    if magnitude > 0.0 {
        for v in vector.iter_mut() {
            *v /= magnitude;
        }
    }

    vector
}

/// Count text statistics for readability
fn count_text_stats(s: &str) -> (usize, usize, usize) {
    let words: Vec<&str> = s.split_whitespace().collect();
    let word_count = words.len();
    let sentence_count = s
        .matches(|c| c == '.' || c == '!' || c == '?')
        .count()
        .max(1);

    let mut syllable_count = 0;
    for word in &words {
        syllable_count += count_syllables(word);
    }

    (word_count, sentence_count, syllable_count)
}

/// Count syllables in a word (English approximation)
fn count_syllables(word: &str) -> usize {
    let word = word.to_lowercase();
    let vowels = ['a', 'e', 'i', 'o', 'u', 'y'];
    let mut count = 0;
    let mut prev_was_vowel = false;

    for c in word.chars() {
        let is_vowel = vowels.contains(&c);
        if is_vowel && !prev_was_vowel {
            count += 1;
        }
        prev_was_vowel = is_vowel;
    }

    // Adjust for silent e
    if word.ends_with('e') && count > 1 {
        count -= 1;
    }

    count.max(1)
}

/// Compute American Soundex encoding
fn compute_soundex(s: &str) -> String {
    if s.is_empty() {
        return "0000".to_string();
    }

    let s = s.to_uppercase();
    let chars: Vec<char> = s.chars().filter(|c| c.is_ascii_alphabetic()).collect();

    if chars.is_empty() {
        return "0000".to_string();
    }

    let first = chars[0];
    let mut code = String::new();
    code.push(first);

    let get_code = |c: char| -> char {
        match c {
            'B' | 'F' | 'P' | 'V' => '1',
            'C' | 'G' | 'J' | 'K' | 'Q' | 'S' | 'X' | 'Z' => '2',
            'D' | 'T' => '3',
            'L' => '4',
            'M' | 'N' => '5',
            'R' => '6',
            _ => '0',
        }
    };

    let mut prev_code = get_code(first);

    for &c in chars.iter().skip(1) {
        let curr_code = get_code(c);
        if curr_code != '0' && curr_code != prev_code {
            code.push(curr_code);
            if code.len() == 4 {
                break;
            }
        }
        prev_code = curr_code;
    }

    while code.len() < 4 {
        code.push('0');
    }

    code
}

/// Compute Metaphone encoding
fn compute_metaphone(s: &str) -> String {
    let s = s.to_uppercase();
    let chars: Vec<char> = s.chars().filter(|c| c.is_ascii_alphabetic()).collect();

    if chars.is_empty() {
        return String::new();
    }

    let mut result = String::new();
    let mut i = 0;

    // Skip initial KN, GN, PN, AE, WR
    if chars.len() >= 2 {
        let prefix: String = chars[0..2].iter().collect();
        if ["KN", "GN", "PN", "AE", "WR"].contains(&prefix.as_str()) {
            i = 1;
        }
    }

    while i < chars.len() && result.len() < 6 {
        let c = chars[i];
        let prev = if i > 0 { Some(chars[i - 1]) } else { None };
        let next = chars.get(i + 1).copied();

        let code = match c {
            'A' | 'E' | 'I' | 'O' | 'U' => {
                if i == 0 {
                    Some(c)
                } else {
                    None
                }
            }
            'B' => {
                if prev != Some('M') || i == chars.len() - 1 {
                    Some('B')
                } else {
                    None
                }
            }
            'C' => {
                if next == Some('H') {
                    Some('X')
                } else if matches!(next, Some('I') | Some('E') | Some('Y')) {
                    Some('S')
                } else {
                    Some('K')
                }
            }
            'D' => {
                if next == Some('G')
                    && matches!(chars.get(i + 2), Some('E') | Some('I') | Some('Y'))
                {
                    Some('J')
                } else {
                    Some('T')
                }
            }
            'F' => Some('F'),
            'G' => {
                if next == Some('H')
                    && !matches!(
                        chars.get(i + 2),
                        Some('A') | Some('E') | Some('I') | Some('O') | Some('U')
                    )
                {
                    None
                } else if matches!(next, Some('N') | Some('E') | Some('I') | Some('Y')) {
                    Some('J')
                } else {
                    Some('K')
                }
            }
            'H' => {
                if matches!(
                    prev,
                    Some('A') | Some('E') | Some('I') | Some('O') | Some('U')
                ) {
                    None
                } else if matches!(
                    next,
                    Some('A') | Some('E') | Some('I') | Some('O') | Some('U')
                ) {
                    Some('H')
                } else {
                    None
                }
            }
            'J' => Some('J'),
            'K' => {
                if prev != Some('C') {
                    Some('K')
                } else {
                    None
                }
            }
            'L' => Some('L'),
            'M' => Some('M'),
            'N' => Some('N'),
            'P' => {
                if next == Some('H') {
                    Some('F')
                } else {
                    Some('P')
                }
            }
            'Q' => Some('K'),
            'R' => Some('R'),
            'S' => {
                if next == Some('H') {
                    Some('X')
                } else {
                    Some('S')
                }
            }
            'T' => {
                if next == Some('H') {
                    Some('0') // TH sound
                } else if next == Some('I') && matches!(chars.get(i + 2), Some('O') | Some('A')) {
                    Some('X')
                } else {
                    Some('T')
                }
            }
            'V' => Some('F'),
            'W' | 'Y' => {
                if matches!(
                    next,
                    Some('A') | Some('E') | Some('I') | Some('O') | Some('U')
                ) {
                    Some(c)
                } else {
                    None
                }
            }
            'X' => {
                result.push('K');
                Some('S')
            }
            'Z' => Some('S'),
            _ => None,
        };

        if let Some(ch) = code {
            result.push(ch);
        }

        // Skip double letters
        if next == Some(c) {
            i += 1;
        }
        i += 1;
    }

    result
}

/// Compute Cologne phonetic encoding (for German)
fn compute_cologne(s: &str) -> String {
    let s = s.to_uppercase();
    let chars: Vec<char> = s.chars().filter(|c| c.is_ascii_alphabetic()).collect();

    if chars.is_empty() {
        return String::new();
    }

    let mut result = String::new();

    for (i, &c) in chars.iter().enumerate() {
        let prev = if i > 0 { Some(chars[i - 1]) } else { None };
        let next = chars.get(i + 1).copied();

        let code = match c {
            'A' | 'E' | 'I' | 'O' | 'U' | 'J' | 'Y' => '0',
            'H' => continue,
            'B' | 'P' => '1',
            'D' | 'T' => {
                if matches!(next, Some('C') | Some('S') | Some('Z')) {
                    '8'
                } else {
                    '2'
                }
            }
            'F' | 'V' | 'W' => '3',
            'G' | 'K' | 'Q' => '4',
            'C' => {
                if i == 0 {
                    if matches!(
                        next,
                        Some('A')
                            | Some('H')
                            | Some('K')
                            | Some('L')
                            | Some('O')
                            | Some('Q')
                            | Some('R')
                            | Some('U')
                            | Some('X')
                    ) {
                        '4'
                    } else {
                        '8'
                    }
                } else if matches!(prev, Some('S') | Some('Z')) {
                    '8'
                } else if matches!(
                    next,
                    Some('A')
                        | Some('H')
                        | Some('K')
                        | Some('O')
                        | Some('Q')
                        | Some('U')
                        | Some('X')
                ) {
                    '4'
                } else {
                    '8'
                }
            }
            'X' => {
                if matches!(prev, Some('C') | Some('K') | Some('Q')) {
                    '8'
                } else {
                    result.push('4');
                    '8'
                }
            }
            'L' => '5',
            'M' | 'N' => '6',
            'R' => '7',
            'S' | 'Z' => '8',
            _ => continue,
        };

        result.push(code);
    }

    // Remove consecutive duplicates
    let mut deduped = String::new();
    let mut prev = None;
    for c in result.chars() {
        if prev != Some(c) {
            deduped.push(c);
        }
        prev = Some(c);
    }

    // Remove leading zeros (except if all zeros)
    let trimmed: String = deduped.trim_start_matches('0').to_string();
    if trimmed.is_empty() {
        "0".to_string()
    } else {
        trimmed
    }
}

/// Get stopwords for a language
fn get_stopwords(lang: &str) -> Vec<&'static str> {
    match lang {
        "en" | "english" => vec![
            "a", "an", "the", "and", "or", "but", "in", "on", "at", "to", "for", "of", "with",
            "by", "from", "as", "is", "was", "are", "were", "been", "be", "have", "has", "had",
            "do", "does", "did", "will", "would", "could", "should", "may", "might", "must",
            "shall", "can", "need", "it", "its", "this", "that", "these", "those", "i", "you",
            "he", "she", "we", "they", "me", "him", "her", "us", "them", "my", "your", "his",
            "her", "our", "their", "what", "which", "who", "whom", "whose", "when", "where", "why",
            "how", "all", "each", "every", "both", "few", "more", "most", "other", "some", "such",
            "no", "nor", "not", "only", "own", "same", "so", "than", "too", "very", "just", "also",
            "now",
        ],
        "de" | "german" => vec![
            "der", "die", "das", "den", "dem", "des", "ein", "eine", "einer", "einem", "einen",
            "und", "oder", "aber", "in", "auf", "an", "zu", "für", "von", "mit", "bei", "als",
            "ist", "war", "sind", "waren", "sein", "haben", "hat", "hatte", "werden", "wird",
            "wurde", "kann", "können", "muss", "müssen", "soll", "sollen", "will", "wollen", "es",
            "sie", "er", "wir", "ihr", "ich", "du", "man", "sich", "nicht", "auch", "nur", "noch",
            "schon", "mehr", "sehr", "so",
        ],
        "fr" | "french" => vec![
            "le", "la", "les", "un", "une", "des", "et", "ou", "mais", "dans", "sur", "à", "de",
            "pour", "par", "avec", "ce", "cette", "ces", "est", "sont", "était", "être", "avoir",
            "a", "ont", "avait", "je", "tu", "il", "elle", "nous", "vous", "ils", "elles", "on",
            "ne", "pas", "plus", "moins", "très", "aussi", "que", "qui",
        ],
        "es" | "spanish" => vec![
            "el", "la", "los", "las", "un", "una", "unos", "unas", "y", "o", "pero", "en", "de",
            "a", "para", "por", "con", "es", "son", "era", "ser", "estar", "tiene", "tienen", "yo",
            "tú", "él", "ella", "nosotros", "ustedes", "ellos", "ellas", "no", "sí", "muy", "más",
            "menos", "también", "que", "quien", "cual", "como", "cuando",
        ],
        "it" | "italian" => vec![
            "il", "lo", "la", "i", "gli", "le", "un", "uno", "una", "e", "o", "ma", "in", "di",
            "a", "da", "per", "con", "su", "tra", "fra", "è", "sono", "era", "erano", "essere",
            "avere", "ha", "hanno", "io", "tu", "lui", "lei", "noi", "voi", "loro", "mi", "ti",
            "ci", "non", "più", "molto", "anche", "come", "che", "chi", "quale", "questo",
            "quello", "quando", "dove", "perché", "se", "però",
        ],
        "pt" | "portuguese" => vec![
            "o", "a", "os", "as", "um", "uma", "uns", "umas", "e", "ou", "mas", "em", "de", "para",
            "por", "com", "sem", "sob", "sobre", "é", "são", "era", "eram", "ser", "estar", "ter",
            "tem", "têm", "eu", "tu", "ele", "ela", "nós", "vós", "eles", "elas", "me", "te",
            "não", "mais", "muito", "também", "como", "que", "quem", "qual", "este", "esse",
            "aquele", "quando", "onde", "porque", "se", "já",
        ],
        "nl" | "dutch" => vec![
            "de", "het", "een", "en", "of", "maar", "in", "op", "aan", "van", "voor", "met", "bij",
            "naar", "om", "te", "tot", "uit", "over", "is", "zijn", "was", "waren", "worden",
            "wordt", "werd", "hebben", "ik", "je", "jij", "hij", "zij", "wij", "jullie", "ze",
            "mij", "jou", "niet", "geen", "meer", "ook", "als", "dat", "die", "wat", "wie", "dit",
            "deze", "wanneer", "waar", "waarom", "hoe", "dan", "nog",
        ],
        "ru" | "russian" => vec![
            "и",
            "в",
            "на",
            "с",
            "к",
            "по",
            "за",
            "из",
            "у",
            "о",
            "от",
            "до",
            "для",
            "при",
            "без",
            "под",
            "над",
            "между",
            "через",
            "после",
            "это",
            "то",
            "что",
            "как",
            "так",
            "но",
            "а",
            "или",
            "если",
            "же",
            "я",
            "ты",
            "он",
            "она",
            "мы",
            "вы",
            "они",
            "его",
            "её",
            "их",
            "не",
            "ни",
            "да",
            "нет",
            "был",
            "была",
            "были",
            "быть",
            "есть",
            "все",
            "всё",
            "весь",
            "этот",
            "тот",
            "который",
            "когда",
            "где",
        ],
        "ar" | "arabic" => vec![
            "في",
            "من",
            "إلى",
            "على",
            "عن",
            "مع",
            "هذا",
            "هذه",
            "ذلك",
            "تلك",
            "التي",
            "الذي",
            "اللذان",
            "اللتان",
            "الذين",
            "اللاتي",
            "اللواتي",
            "هو",
            "هي",
            "هم",
            "هن",
            "أنا",
            "أنت",
            "نحن",
            "أنتم",
            "أنتن",
            "كان",
            "كانت",
            "كانوا",
            "يكون",
            "تكون",
            "ليس",
            "ليست",
            "ليسوا",
            "و",
            "أو",
            "ثم",
            "لكن",
            "بل",
            "إن",
            "أن",
            "لأن",
            "كي",
            "حتى",
            "ما",
            "لا",
            "قد",
            "كل",
            "بعض",
            "غير",
            "أي",
            "كيف",
            "متى",
            "أين",
        ],
        "zh" | "chinese" => vec![
            "的", "了", "是", "在", "有", "和", "与", "或", "但", "而", "我", "你", "他", "她",
            "它", "我们", "你们", "他们", "她们", "这", "那", "这个", "那个", "这些", "那些",
            "什么", "哪", "哪个", "不", "没", "没有", "很", "也", "都", "就", "才", "只", "还",
            "把", "被", "给", "从", "到", "为", "以", "因为", "所以", "如果", "会", "能", "可以",
            "要", "想", "应该", "必须", "可能", "一", "个",
        ],
        "ja" | "japanese" => vec![
            "の",
            "に",
            "は",
            "を",
            "た",
            "が",
            "で",
            "て",
            "と",
            "し",
            "れ",
            "さ",
            "ある",
            "いる",
            "も",
            "する",
            "から",
            "な",
            "こと",
            "として",
            "い",
            "や",
            "など",
            "なっ",
            "ない",
            "この",
            "ため",
            "その",
            "あっ",
            "よう",
            "また",
            "もの",
            "という",
            "あり",
            "まで",
            "られ",
            "なる",
            "へ",
            "か",
            "だ",
            "これ",
            "によって",
            "により",
            "おり",
            "より",
            "による",
            "ず",
            "なり",
            "られる",
            "において",
        ],
        "ko" | "korean" => vec![
            "이",
            "그",
            "저",
            "것",
            "수",
            "등",
            "들",
            "및",
            "에",
            "의",
            "가",
            "을",
            "를",
            "은",
            "는",
            "로",
            "으로",
            "와",
            "과",
            "도",
            "에서",
            "까지",
            "부터",
            "만",
            "뿐",
            "처럼",
            "같이",
            "보다",
            "하다",
            "있다",
            "되다",
            "없다",
            "않다",
            "이다",
            "아니다",
            "나",
            "너",
            "우리",
            "그들",
            "이것",
            "그것",
            "저것",
            "무엇",
            "어디",
            "언제",
            "왜",
            "어떻게",
            "누구",
            "어느",
            "모든",
            "각",
        ],
        "hi" | "hindi" => vec![
            "का",
            "के",
            "की",
            "में",
            "है",
            "हैं",
            "को",
            "से",
            "पर",
            "था",
            "थे",
            "थी",
            "और",
            "या",
            "लेकिन",
            "अगर",
            "तो",
            "भी",
            "ही",
            "यह",
            "वह",
            "इस",
            "उस",
            "ये",
            "वे",
            "जो",
            "कि",
            "क्या",
            "कैसे",
            "मैं",
            "तुम",
            "आप",
            "हम",
            "वे",
            "उन्हें",
            "उनके",
            "अपने",
            "नहीं",
            "न",
            "कुछ",
            "कोई",
            "सब",
            "बहुत",
            "कम",
            "ज्यादा",
            "होना",
            "करना",
            "जाना",
            "आना",
            "देना",
            "लेना",
            "रहना",
            "सकना",
        ],
        "tr" | "turkish" => vec![
            "bir",
            "ve",
            "bu",
            "da",
            "de",
            "için",
            "ile",
            "mi",
            "ne",
            "o",
            "var",
            "ben",
            "sen",
            "biz",
            "siz",
            "onlar",
            "ki",
            "ama",
            "çok",
            "daha",
            "gibi",
            "kadar",
            "sonra",
            "şey",
            "kendi",
            "bütün",
            "her",
            "bazı",
            "olan",
            "olarak",
            "değil",
            "ya",
            "hem",
            "veya",
            "ancak",
            "ise",
            "göre",
            "rağmen",
            "dolayı",
            "üzere",
            "karşı",
            "arasında",
            "olan",
            "oldu",
            "olur",
            "olmak",
            "etmek",
            "yapmak",
            "demek",
        ],
        "pl" | "polish" => vec![
            "i",
            "w",
            "z",
            "na",
            "do",
            "o",
            "że",
            "to",
            "nie",
            "się",
            "jest",
            "tak",
            "jak",
            "ale",
            "po",
            "co",
            "czy",
            "lub",
            "oraz",
            "ja",
            "ty",
            "on",
            "ona",
            "my",
            "wy",
            "oni",
            "one",
            "pan",
            "pani",
            "ten",
            "ta",
            "te",
            "tego",
            "tej",
            "tym",
            "tych",
            "który",
            "która",
            "być",
            "mieć",
            "móc",
            "musieć",
            "chcieć",
            "wiedzieć",
            "mówić",
            "bardzo",
            "tylko",
            "już",
            "jeszcze",
            "też",
            "więc",
            "jednak",
        ],
        "sv" | "swedish" => vec![
            "och", "i", "att", "det", "som", "en", "på", "är", "av", "för", "med", "till", "den",
            "har", "de", "inte", "om", "ett", "men", "jag", "du", "han", "hon", "vi", "ni", "de",
            "dem", "sig", "sin", "var", "från", "eller", "när", "kan", "ska", "så", "än", "nu",
            "också", "bara", "mycket", "mer", "andra", "detta", "sedan", "hade", "varit", "skulle",
            "vara", "bli", "blev", "blir", "göra",
        ],
        _ => vec![
            "a", "an", "the", "and", "or", "but", "in", "on", "at", "to", "for",
        ],
    }
}

/// Simple hash function for MinHash
fn compute_hash(s: &str, seed: u64) -> u64 {
    let mut hash: u64 = seed.wrapping_mul(0x517cc1b727220a95);
    for b in s.bytes() {
        hash = hash.wrapping_mul(31).wrapping_add(b as u64);
    }
    hash
}

// ============================================================================
// EMOTIONAL HOLOGRAM: Multi-dimensional affective projection with cultural awareness
// ============================================================================
//
// The Emotional Hologram is a unique Sigil concept that projects affect onto a
// normalized coordinate space, enabling:
// - Emotional distance calculations
// - Cross-cultural emotion mappings
// - Emotional fingerprinting and cryptographic signing
// - Dissonance detection (e.g., positive + sarcastic)
//
// Dimensions:
//   Valence     (-1 to +1): Negative to Positive sentiment
//   Arousal     (0 to 1):   Low to High intensity
//   Dominance   (0 to 1):   Submissive to Dominant (formality)
//   Authenticity(-1 to +1): Sincere to Ironic
//   Certainty   (0 to 1):   Low to High confidence
//   Emotion     (0-6):      Discrete emotion index (or -1 for none)

fn register_hologram(interp: &mut Interpreter) {
    use crate::interpreter::{
        RuntimeAffect, RuntimeConfidence, RuntimeEmotion, RuntimeFormality, RuntimeIntensity,
        RuntimeSentiment,
    };

    // emotional_hologram - project affect onto normalized coordinate space
    // Returns a map: { valence, arousal, dominance, authenticity, certainty, emotion_index }
    define(interp, "emotional_hologram", Some(1), |_, args| {
        let affect = match &args[0] {
            Value::Affective { affect, .. } => affect.clone(),
            _ => RuntimeAffect {
                sentiment: None,
                sarcasm: false,
                intensity: None,
                formality: None,
                emotion: None,
                confidence: None,
            },
        };

        let mut hologram = std::collections::HashMap::new();

        // Valence: sentiment mapped to -1, 0, +1
        let valence = match affect.sentiment {
            Some(RuntimeSentiment::Positive) => 1.0,
            Some(RuntimeSentiment::Negative) => -1.0,
            Some(RuntimeSentiment::Neutral) | None => 0.0,
        };
        hologram.insert("valence".to_string(), Value::Float(valence));

        // Arousal: intensity mapped to 0, 0.33, 0.66, 1.0
        let arousal = match affect.intensity {
            Some(RuntimeIntensity::Down) => 0.25,
            None => 0.5,
            Some(RuntimeIntensity::Up) => 0.75,
            Some(RuntimeIntensity::Max) => 1.0,
        };
        hologram.insert("arousal".to_string(), Value::Float(arousal));

        // Dominance: formality mapped to 0 (informal/submissive) to 1 (formal/dominant)
        let dominance = match affect.formality {
            Some(RuntimeFormality::Informal) => 0.25,
            None => 0.5,
            Some(RuntimeFormality::Formal) => 0.85,
        };
        hologram.insert("dominance".to_string(), Value::Float(dominance));

        // Authenticity: -1 (ironic/sarcastic) to +1 (sincere)
        let authenticity = if affect.sarcasm { -0.9 } else { 0.9 };
        hologram.insert("authenticity".to_string(), Value::Float(authenticity));

        // Certainty: confidence mapped to 0, 0.5, 1.0
        let certainty = match affect.confidence {
            Some(RuntimeConfidence::Low) => 0.2,
            None | Some(RuntimeConfidence::Medium) => 0.5,
            Some(RuntimeConfidence::High) => 0.9,
        };
        hologram.insert("certainty".to_string(), Value::Float(certainty));

        // Emotion index: 0=joy, 1=sadness, 2=anger, 3=fear, 4=surprise, 5=love, -1=none
        let emotion_index = match affect.emotion {
            Some(RuntimeEmotion::Joy) => 0,
            Some(RuntimeEmotion::Sadness) => 1,
            Some(RuntimeEmotion::Anger) => 2,
            Some(RuntimeEmotion::Fear) => 3,
            Some(RuntimeEmotion::Surprise) => 4,
            Some(RuntimeEmotion::Love) => 5,
            None => -1,
        };
        hologram.insert("emotion_index".to_string(), Value::Int(emotion_index));

        // Emotion name
        let emotion_name = match affect.emotion {
            Some(RuntimeEmotion::Joy) => "joy",
            Some(RuntimeEmotion::Sadness) => "sadness",
            Some(RuntimeEmotion::Anger) => "anger",
            Some(RuntimeEmotion::Fear) => "fear",
            Some(RuntimeEmotion::Surprise) => "surprise",
            Some(RuntimeEmotion::Love) => "love",
            None => "none",
        };
        hologram.insert(
            "emotion".to_string(),
            Value::String(Rc::new(emotion_name.to_string())),
        );

        Ok(Value::Map(Rc::new(RefCell::new(hologram))))
    });

    // emotional_distance - Euclidean distance between two emotional holograms
    define(interp, "emotional_distance", Some(2), |interp, args| {
        // Get holograms for both values
        let h1 = get_hologram_values(&args[0], interp)?;
        let h2 = get_hologram_values(&args[1], interp)?;

        // Calculate Euclidean distance across dimensions
        let dist = ((h1.0 - h2.0).powi(2) +    // valence
                    (h1.1 - h2.1).powi(2) +    // arousal
                    (h1.2 - h2.2).powi(2) +    // dominance
                    (h1.3 - h2.3).powi(2) +    // authenticity
                    (h1.4 - h2.4).powi(2)) // certainty
        .sqrt();

        Ok(Value::Float(dist))
    });

    // emotional_similarity - cosine similarity between emotional states (0 to 1)
    define(interp, "emotional_similarity", Some(2), |interp, args| {
        let h1 = get_hologram_values(&args[0], interp)?;
        let h2 = get_hologram_values(&args[1], interp)?;

        let dot = h1.0 * h2.0 + h1.1 * h2.1 + h1.2 * h2.2 + h1.3 * h2.3 + h1.4 * h2.4;
        let mag1 =
            (h1.0.powi(2) + h1.1.powi(2) + h1.2.powi(2) + h1.3.powi(2) + h1.4.powi(2)).sqrt();
        let mag2 =
            (h2.0.powi(2) + h2.1.powi(2) + h2.2.powi(2) + h2.3.powi(2) + h2.4.powi(2)).sqrt();

        let similarity = if mag1 > 0.0 && mag2 > 0.0 {
            (dot / (mag1 * mag2) + 1.0) / 2.0 // Normalize to 0-1
        } else {
            0.5
        };

        Ok(Value::Float(similarity))
    });

    // emotional_dissonance - detect internal contradictions in affect
    // Returns score from 0 (coherent) to 1 (highly dissonant)
    define(interp, "emotional_dissonance", Some(1), |_, args| {
        let affect = match &args[0] {
            Value::Affective { affect, .. } => affect.clone(),
            _ => return Ok(Value::Float(0.0)),
        };

        let mut dissonance: f64 = 0.0;

        // Positive sentiment + sarcasm = dissonant
        if matches!(affect.sentiment, Some(RuntimeSentiment::Positive)) && affect.sarcasm {
            dissonance += 0.4;
        }

        // Negative sentiment + sarcasm = less dissonant (double negative)
        if matches!(affect.sentiment, Some(RuntimeSentiment::Negative)) && affect.sarcasm {
            dissonance += 0.1;
        }

        // High confidence + low intensity = mildly dissonant
        if matches!(affect.confidence, Some(RuntimeConfidence::High))
            && matches!(affect.intensity, Some(RuntimeIntensity::Down))
        {
            dissonance += 0.2;
        }

        // Formal + intense emotion = dissonant
        if matches!(affect.formality, Some(RuntimeFormality::Formal)) {
            if matches!(
                affect.emotion,
                Some(RuntimeEmotion::Anger) | Some(RuntimeEmotion::Fear)
            ) {
                dissonance += 0.3;
            }
        }

        // Joy/Love + Sadness/Fear indicators (based on sarcasm with positive)
        if matches!(
            affect.emotion,
            Some(RuntimeEmotion::Joy) | Some(RuntimeEmotion::Love)
        ) && affect.sarcasm
        {
            dissonance += 0.3;
        }

        Ok(Value::Float(dissonance.min(1.0)))
    });

    // emotional_fingerprint - cryptographic hash of emotional state
    // Creates a unique identifier for this exact emotional configuration
    define(interp, "emotional_fingerprint", Some(1), |interp, args| {
        let h = get_hologram_values(&args[0], interp)?;

        // Create deterministic string representation
        let repr = format!(
            "hologram:v{:.4}:a{:.4}:d{:.4}:auth{:.4}:c{:.4}",
            h.0, h.1, h.2, h.3, h.4
        );

        // Hash using BLAKE3
        let hash = blake3::hash(repr.as_bytes());
        Ok(Value::String(Rc::new(hash.to_hex().to_string())))
    });

    // emotional_morph - interpolate between two emotional states
    // t=0 returns first state, t=1 returns second state
    define(interp, "emotional_morph", Some(3), |interp, args| {
        let h1 = get_hologram_values(&args[0], interp)?;
        let h2 = get_hologram_values(&args[1], interp)?;
        let t = match &args[2] {
            Value::Float(f) => f.max(0.0).min(1.0),
            Value::Int(i) => (*i as f64).max(0.0).min(1.0),
            _ => {
                return Err(RuntimeError::new(
                    "emotional_morph() requires numeric t value",
                ))
            }
        };

        let mut result = std::collections::HashMap::new();
        result.insert(
            "valence".to_string(),
            Value::Float(h1.0 + (h2.0 - h1.0) * t),
        );
        result.insert(
            "arousal".to_string(),
            Value::Float(h1.1 + (h2.1 - h1.1) * t),
        );
        result.insert(
            "dominance".to_string(),
            Value::Float(h1.2 + (h2.2 - h1.2) * t),
        );
        result.insert(
            "authenticity".to_string(),
            Value::Float(h1.3 + (h2.3 - h1.3) * t),
        );
        result.insert(
            "certainty".to_string(),
            Value::Float(h1.4 + (h2.4 - h1.4) * t),
        );

        Ok(Value::Map(Rc::new(RefCell::new(result))))
    });

    // === Cultural Emotion Mappings ===
    // Map Sigil emotions to culturally-specific concepts

    // cultural_emotion - get cultural equivalent of an emotion
    // Supported cultures: japanese, portuguese, german, danish, arabic, korean, russian, hindi
    define(interp, "cultural_emotion", Some(2), |_, args| {
        let emotion = match &args[0] {
            Value::Affective { affect, .. } => affect.emotion.clone(),
            Value::String(s) => match s.as_str() {
                "joy" => Some(RuntimeEmotion::Joy),
                "sadness" => Some(RuntimeEmotion::Sadness),
                "anger" => Some(RuntimeEmotion::Anger),
                "fear" => Some(RuntimeEmotion::Fear),
                "surprise" => Some(RuntimeEmotion::Surprise),
                "love" => Some(RuntimeEmotion::Love),
                _ => None,
            },
            _ => None,
        };

        let culture = match &args[1] {
            Value::String(s) => s.to_lowercase(),
            _ => {
                return Err(RuntimeError::new(
                    "cultural_emotion() requires string culture",
                ))
            }
        };

        let result = match (emotion, culture.as_str()) {
            // Japanese concepts
            (Some(RuntimeEmotion::Joy), "japanese" | "ja") => create_cultural_entry(
                "木漏れ日",
                "komorebi",
                "sunlight filtering through leaves - peaceful joy",
            ),
            (Some(RuntimeEmotion::Sadness), "japanese" | "ja") => create_cultural_entry(
                "物の哀れ",
                "mono no aware",
                "the pathos of things - bittersweet awareness of impermanence",
            ),
            (Some(RuntimeEmotion::Love), "japanese" | "ja") => create_cultural_entry(
                "甘え",
                "amae",
                "indulgent dependence on another's benevolence",
            ),
            (Some(RuntimeEmotion::Fear), "japanese" | "ja") => create_cultural_entry(
                "空気を読む",
                "kuuki wo yomu",
                "anxiety about reading the room",
            ),

            // Portuguese concepts
            (Some(RuntimeEmotion::Sadness), "portuguese" | "pt") => create_cultural_entry(
                "saudade",
                "saudade",
                "melancholic longing for something or someone absent",
            ),
            (Some(RuntimeEmotion::Joy), "portuguese" | "pt") => {
                create_cultural_entry("alegria", "alegria", "exuberant collective joy")
            }

            // German concepts
            (Some(RuntimeEmotion::Joy), "german" | "de") => create_cultural_entry(
                "Schadenfreude",
                "schadenfreude",
                "pleasure derived from another's misfortune",
            ),
            (Some(RuntimeEmotion::Sadness), "german" | "de") => create_cultural_entry(
                "Weltschmerz",
                "weltschmerz",
                "world-weariness, melancholy about the world's state",
            ),
            (Some(RuntimeEmotion::Fear), "german" | "de") => create_cultural_entry(
                "Torschlusspanik",
                "torschlusspanik",
                "fear of diminishing opportunities with age",
            ),

            // Danish concepts
            (Some(RuntimeEmotion::Joy), "danish" | "da") => {
                create_cultural_entry("hygge", "hygge", "cozy contentment and conviviality")
            }

            // Arabic concepts
            (Some(RuntimeEmotion::Joy), "arabic" | "ar") => {
                create_cultural_entry("طرب", "tarab", "musical ecstasy, enchantment through art")
            }
            (Some(RuntimeEmotion::Love), "arabic" | "ar") => {
                create_cultural_entry("هوى", "hawa", "passionate, sometimes irrational love")
            }

            // Korean concepts
            (Some(RuntimeEmotion::Sadness), "korean" | "ko") => create_cultural_entry(
                "한",
                "han",
                "collective grief and resentment from historical suffering",
            ),
            (Some(RuntimeEmotion::Joy), "korean" | "ko") => create_cultural_entry(
                "정",
                "jeong",
                "deep affection and attachment formed over time",
            ),

            // Russian concepts
            (Some(RuntimeEmotion::Sadness), "russian" | "ru") => {
                create_cultural_entry("тоска", "toska", "spiritual anguish without specific cause")
            }

            // Hindi concepts
            (Some(RuntimeEmotion::Love), "hindi" | "hi") => {
                create_cultural_entry("विरह", "viraha", "longing for an absent beloved")
            }

            // Finnish concepts
            (Some(RuntimeEmotion::Anger), "finnish" | "fi") => {
                create_cultural_entry("sisu", "sisu", "stoic determination and grit in adversity")
            }

            // Default: return the base emotion
            (Some(e), _) => {
                let name = match e {
                    RuntimeEmotion::Joy => "joy",
                    RuntimeEmotion::Sadness => "sadness",
                    RuntimeEmotion::Anger => "anger",
                    RuntimeEmotion::Fear => "fear",
                    RuntimeEmotion::Surprise => "surprise",
                    RuntimeEmotion::Love => "love",
                };
                create_cultural_entry(name, name, "universal emotion")
            }
            (None, _) => create_cultural_entry("none", "none", "no emotion"),
        };

        Ok(result)
    });

    // list_cultural_emotions - list all emotions for a culture
    define(interp, "list_cultural_emotions", Some(1), |_, args| {
        let culture = match &args[0] {
            Value::String(s) => s.to_lowercase(),
            _ => {
                return Err(RuntimeError::new(
                    "list_cultural_emotions() requires string culture",
                ))
            }
        };

        let emotions: Vec<(&str, &str, &str)> = match culture.as_str() {
            "japanese" | "ja" => vec![
                ("木漏れ日", "komorebi", "sunlight through leaves"),
                ("物の哀れ", "mono no aware", "pathos of things"),
                ("甘え", "amae", "indulgent dependence"),
                ("侘寂", "wabi-sabi", "beauty in imperfection"),
                ("生きがい", "ikigai", "reason for being"),
            ],
            "german" | "de" => vec![
                ("Schadenfreude", "schadenfreude", "joy at misfortune"),
                ("Weltschmerz", "weltschmerz", "world-weariness"),
                ("Torschlusspanik", "torschlusspanik", "gate-closing panic"),
                ("Sehnsucht", "sehnsucht", "deep longing"),
                ("Wanderlust", "wanderlust", "desire to travel"),
            ],
            "portuguese" | "pt" => vec![
                ("saudade", "saudade", "melancholic longing"),
                ("alegria", "alegria", "exuberant joy"),
                ("desabafar", "desabafar", "emotional unburdening"),
            ],
            "danish" | "da" => vec![("hygge", "hygge", "cozy contentment")],
            "korean" | "ko" => vec![
                ("한", "han", "collective grief"),
                ("정", "jeong", "deep affection"),
                ("눈치", "nunchi", "situational awareness"),
            ],
            "arabic" | "ar" => vec![
                ("طرب", "tarab", "musical ecstasy"),
                ("هوى", "hawa", "passionate love"),
                ("صبر", "sabr", "patient perseverance"),
            ],
            "russian" | "ru" => vec![
                ("тоска", "toska", "spiritual anguish"),
                ("пошлость", "poshlost", "spiritual vulgarity"),
            ],
            "finnish" | "fi" => vec![("sisu", "sisu", "stoic determination")],
            "hindi" | "hi" => vec![
                ("विरह", "viraha", "longing for beloved"),
                ("जुगाड़", "jugaad", "creative improvisation"),
            ],
            _ => vec![
                ("joy", "joy", "universal happiness"),
                ("sadness", "sadness", "universal sorrow"),
                ("anger", "anger", "universal frustration"),
                ("fear", "fear", "universal anxiety"),
                ("surprise", "surprise", "universal amazement"),
                ("love", "love", "universal affection"),
            ],
        };

        let result: Vec<Value> = emotions
            .iter()
            .map(|(native, romanized, meaning)| create_cultural_entry(native, romanized, meaning))
            .collect();

        Ok(Value::Array(Rc::new(RefCell::new(result))))
    });

    // hologram_info - get metadata about the hologram system
    define(interp, "hologram_info", Some(0), |_, _| {
        let mut info = std::collections::HashMap::new();

        info.insert(
            "dimensions".to_string(),
            Value::Array(Rc::new(RefCell::new(vec![
                Value::String(Rc::new("valence".to_string())),
                Value::String(Rc::new("arousal".to_string())),
                Value::String(Rc::new("dominance".to_string())),
                Value::String(Rc::new("authenticity".to_string())),
                Value::String(Rc::new("certainty".to_string())),
                Value::String(Rc::new("emotion_index".to_string())),
            ]))),
        );

        info.insert(
            "supported_cultures".to_string(),
            Value::Array(Rc::new(RefCell::new(vec![
                Value::String(Rc::new("japanese".to_string())),
                Value::String(Rc::new("german".to_string())),
                Value::String(Rc::new("portuguese".to_string())),
                Value::String(Rc::new("danish".to_string())),
                Value::String(Rc::new("korean".to_string())),
                Value::String(Rc::new("arabic".to_string())),
                Value::String(Rc::new("russian".to_string())),
                Value::String(Rc::new("finnish".to_string())),
                Value::String(Rc::new("hindi".to_string())),
            ]))),
        );

        let funcs = vec![
            "emotional_hologram",
            "emotional_distance",
            "emotional_similarity",
            "emotional_dissonance",
            "emotional_fingerprint",
            "emotional_morph",
            "cultural_emotion",
            "list_cultural_emotions",
            "hologram_info",
        ];
        let func_values: Vec<Value> = funcs
            .iter()
            .map(|s| Value::String(Rc::new(s.to_string())))
            .collect();
        info.insert(
            "functions".to_string(),
            Value::Array(Rc::new(RefCell::new(func_values))),
        );

        Ok(Value::Map(Rc::new(RefCell::new(info))))
    });
}

/// Helper to extract hologram values from an affective value
fn get_hologram_values(
    val: &Value,
    _interp: &mut Interpreter,
) -> Result<(f64, f64, f64, f64, f64), RuntimeError> {
    use crate::interpreter::{
        RuntimeAffect, RuntimeConfidence, RuntimeFormality, RuntimeIntensity, RuntimeSentiment,
    };

    let affect = match val {
        Value::Affective { affect, .. } => affect.clone(),
        Value::Map(m) => {
            // Already a hologram map
            let map = m.borrow();
            let v = extract_float(&map, "valence").unwrap_or(0.0);
            let a = extract_float(&map, "arousal").unwrap_or(0.5);
            let d = extract_float(&map, "dominance").unwrap_or(0.5);
            let auth = extract_float(&map, "authenticity").unwrap_or(0.9);
            let c = extract_float(&map, "certainty").unwrap_or(0.5);
            return Ok((v, a, d, auth, c));
        }
        _ => RuntimeAffect {
            sentiment: None,
            sarcasm: false,
            intensity: None,
            formality: None,
            emotion: None,
            confidence: None,
        },
    };

    let v = match affect.sentiment {
        Some(RuntimeSentiment::Positive) => 1.0,
        Some(RuntimeSentiment::Negative) => -1.0,
        _ => 0.0,
    };
    let a = match affect.intensity {
        Some(RuntimeIntensity::Down) => 0.25,
        Some(RuntimeIntensity::Up) => 0.75,
        Some(RuntimeIntensity::Max) => 1.0,
        None => 0.5,
    };
    let d = match affect.formality {
        Some(RuntimeFormality::Informal) => 0.25,
        Some(RuntimeFormality::Formal) => 0.85,
        None => 0.5,
    };
    let auth = if affect.sarcasm { -0.9 } else { 0.9 };
    let c = match affect.confidence {
        Some(RuntimeConfidence::Low) => 0.2,
        Some(RuntimeConfidence::High) => 0.9,
        _ => 0.5,
    };

    Ok((v, a, d, auth, c))
}

fn extract_float(map: &std::collections::HashMap<String, Value>, key: &str) -> Option<f64> {
    match map.get(key) {
        Some(Value::Float(f)) => Some(*f),
        Some(Value::Int(i)) => Some(*i as f64),
        _ => None,
    }
}

fn create_cultural_entry(native: &str, romanized: &str, meaning: &str) -> Value {
    let mut entry = std::collections::HashMap::new();
    entry.insert(
        "native".to_string(),
        Value::String(Rc::new(native.to_string())),
    );
    entry.insert(
        "romanized".to_string(),
        Value::String(Rc::new(romanized.to_string())),
    );
    entry.insert(
        "meaning".to_string(),
        Value::String(Rc::new(meaning.to_string())),
    );
    Value::Map(Rc::new(RefCell::new(entry)))
}

// ============================================================================
// EXPERIMENTAL CRYPTOGRAPHY: Threshold crypto, commitments, and more
// ============================================================================

fn register_experimental_crypto(interp: &mut Interpreter) {
    // === Commitment Schemes ===
    // Commit to a value without revealing it, verify later

    // commit - create a cryptographic commitment to a value
    // Returns { commitment: hash, nonce: random_value }
    define(interp, "commit", Some(1), |_, args| {
        let value_str = match &args[0] {
            Value::String(s) => s.to_string(),
            other => format!("{:?}", other),
        };

        // Generate random nonce
        let mut nonce = [0u8; 32];
        getrandom::getrandom(&mut nonce)
            .map_err(|e| RuntimeError::new(format!("commit() random failed: {}", e)))?;
        let nonce_hex = hex::encode(&nonce);

        // Create commitment: H(value || nonce)
        let commitment_input = format!("{}:{}", value_str, nonce_hex);
        let commitment = blake3::hash(commitment_input.as_bytes());

        let mut result = std::collections::HashMap::new();
        result.insert(
            "commitment".to_string(),
            Value::String(Rc::new(commitment.to_hex().to_string())),
        );
        result.insert("nonce".to_string(), Value::String(Rc::new(nonce_hex)));
        result.insert("value".to_string(), args[0].clone());

        Ok(Value::Map(Rc::new(RefCell::new(result))))
    });

    // verify_commitment - verify a commitment matches a revealed value
    define(interp, "verify_commitment", Some(3), |_, args| {
        let commitment = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => {
                return Err(RuntimeError::new(
                    "verify_commitment() requires string commitment",
                ))
            }
        };
        let value_str = match &args[1] {
            Value::String(s) => s.to_string(),
            other => format!("{:?}", other),
        };
        let nonce = match &args[2] {
            Value::String(s) => s.to_string(),
            _ => {
                return Err(RuntimeError::new(
                    "verify_commitment() requires string nonce",
                ))
            }
        };

        // Recompute commitment
        let commitment_input = format!("{}:{}", value_str, nonce);
        let computed = blake3::hash(commitment_input.as_bytes());

        Ok(Value::Bool(computed.to_hex().to_string() == commitment))
    });

    // === Threshold Cryptography (Shamir's Secret Sharing) ===
    // Split secrets into shares, requiring threshold to reconstruct

    // secret_split - split a secret into n shares, requiring threshold to recover
    // Uses Shamir's Secret Sharing over GF(256)
    define(interp, "secret_split", Some(3), |_, args| {
        let secret = match &args[0] {
            Value::String(s) => s.as_bytes().to_vec(),
            Value::Array(arr) => {
                let borrowed = arr.borrow();
                borrowed
                    .iter()
                    .filter_map(|v| {
                        if let Value::Int(i) = v {
                            Some(*i as u8)
                        } else {
                            None
                        }
                    })
                    .collect()
            }
            _ => {
                return Err(RuntimeError::new(
                    "secret_split() requires string or byte array",
                ))
            }
        };

        let threshold = match &args[1] {
            Value::Int(n) => *n as usize,
            _ => {
                return Err(RuntimeError::new(
                    "secret_split() requires integer threshold",
                ))
            }
        };

        let num_shares = match &args[2] {
            Value::Int(n) => *n as usize,
            _ => {
                return Err(RuntimeError::new(
                    "secret_split() requires integer num_shares",
                ))
            }
        };

        if threshold < 2 {
            return Err(RuntimeError::new("secret_split() threshold must be >= 2"));
        }
        if num_shares < threshold {
            return Err(RuntimeError::new(
                "secret_split() num_shares must be >= threshold",
            ));
        }
        if num_shares > 255 {
            return Err(RuntimeError::new("secret_split() max 255 shares"));
        }

        // Simple implementation: split each byte independently using polynomial interpolation
        // For production, use vsss-rs properly, but this demonstrates the concept
        let mut rng = rand::thread_rng();
        let mut shares: Vec<Vec<u8>> = (0..num_shares)
            .map(|_| Vec::with_capacity(secret.len() + 1))
            .collect();

        // Assign share indices (1-based to avoid zero)
        for (i, share) in shares.iter_mut().enumerate() {
            share.push((i + 1) as u8);
        }

        // For each byte of the secret, create polynomial shares
        for &byte in &secret {
            // Generate random coefficients for polynomial of degree (threshold - 1)
            // a_0 = secret byte, a_1..a_{t-1} = random
            let mut coefficients: Vec<u8> = vec![byte];
            for _ in 1..threshold {
                coefficients.push(rng.gen());
            }

            // Evaluate polynomial at each share index
            for (i, share) in shares.iter_mut().enumerate() {
                let x = (i + 1) as u8;
                let y = eval_polynomial_gf256(&coefficients, x);
                share.push(y);
            }
        }

        // Convert shares to output format
        let share_values: Vec<Value> = shares
            .iter()
            .map(|share| {
                let hex = hex::encode(share);
                Value::String(Rc::new(hex))
            })
            .collect();

        let mut result = std::collections::HashMap::new();
        result.insert(
            "shares".to_string(),
            Value::Array(Rc::new(RefCell::new(share_values))),
        );
        result.insert("threshold".to_string(), Value::Int(threshold as i64));
        result.insert("total".to_string(), Value::Int(num_shares as i64));

        Ok(Value::Map(Rc::new(RefCell::new(result))))
    });

    // secret_recover - recover secret from threshold shares
    define(interp, "secret_recover", Some(1), |_, args| {
        let shares: Vec<Vec<u8>> = match &args[0] {
            Value::Array(arr) => {
                let borrowed = arr.borrow();
                borrowed
                    .iter()
                    .filter_map(|v| {
                        if let Value::String(s) = v {
                            hex::decode(s.as_str()).ok()
                        } else {
                            None
                        }
                    })
                    .collect()
            }
            _ => {
                return Err(RuntimeError::new(
                    "secret_recover() requires array of share strings",
                ))
            }
        };

        if shares.is_empty() {
            return Err(RuntimeError::new(
                "secret_recover() requires at least one share",
            ));
        }

        let share_len = shares[0].len();
        if share_len < 2 {
            return Err(RuntimeError::new("secret_recover() invalid share format"));
        }

        // Recover each byte using Lagrange interpolation
        let mut secret = Vec::with_capacity(share_len - 1);

        for byte_idx in 1..share_len {
            // Collect (x, y) pairs for this byte position
            let points: Vec<(u8, u8)> = shares
                .iter()
                .map(|share| (share[0], share[byte_idx]))
                .collect();

            // Lagrange interpolation at x=0 to recover the secret byte
            let recovered_byte = lagrange_interpolate_gf256(&points, 0);
            secret.push(recovered_byte);
        }

        // Try to interpret as string
        match String::from_utf8(secret.clone()) {
            Ok(s) => Ok(Value::String(Rc::new(s))),
            Err(_) => {
                // Return as byte array
                let byte_values: Vec<Value> =
                    secret.iter().map(|&b| Value::Int(b as i64)).collect();
                Ok(Value::Array(Rc::new(RefCell::new(byte_values))))
            }
        }
    });

    // === Cryptographic Ceremony Functions ===
    // Cultural trust models encoded in crypto

    // council_split - split secret using Ubuntu (I am because we are) model
    // Requires majority consensus
    define(interp, "council_split", Some(2), |_, args| {
        let secret = match &args[0] {
            Value::String(s) => s.as_bytes().to_vec(),
            _ => return Err(RuntimeError::new("council_split() requires string secret")),
        };

        let num_elders = match &args[1] {
            Value::Int(n) => *n as usize,
            _ => {
                return Err(RuntimeError::new(
                    "council_split() requires integer num_elders",
                ))
            }
        };

        if num_elders < 3 {
            return Err(RuntimeError::new(
                "council_split() requires at least 3 elders",
            ));
        }

        // Ubuntu model: majority required (n/2 + 1)
        let threshold = (num_elders / 2) + 1;

        // Reuse secret_split logic
        let mut rng = rand::thread_rng();
        let mut shares: Vec<Vec<u8>> = (0..num_elders)
            .map(|_| Vec::with_capacity(secret.len() + 1))
            .collect();

        for (i, share) in shares.iter_mut().enumerate() {
            share.push((i + 1) as u8);
        }

        for &byte in &secret {
            let mut coefficients: Vec<u8> = vec![byte];
            for _ in 1..threshold {
                coefficients.push(rng.gen());
            }

            for (i, share) in shares.iter_mut().enumerate() {
                let x = (i + 1) as u8;
                let y = eval_polynomial_gf256(&coefficients, x);
                share.push(y);
            }
        }

        let share_values: Vec<Value> = shares
            .iter()
            .map(|share| Value::String(Rc::new(hex::encode(share))))
            .collect();

        let mut result = std::collections::HashMap::new();
        result.insert(
            "shares".to_string(),
            Value::Array(Rc::new(RefCell::new(share_values))),
        );
        result.insert("threshold".to_string(), Value::Int(threshold as i64));
        result.insert("total".to_string(), Value::Int(num_elders as i64));
        result.insert(
            "model".to_string(),
            Value::String(Rc::new("ubuntu".to_string())),
        );
        result.insert(
            "philosophy".to_string(),
            Value::String(Rc::new(
                "I am because we are - majority consensus required".to_string(),
            )),
        );

        Ok(Value::Map(Rc::new(RefCell::new(result))))
    });

    // witness_chain - create a chain of witnesses (Middle Eastern oral tradition model)
    // Each witness signs the previous, creating a chain of trust
    define(interp, "witness_chain", Some(2), |_, args| {
        let statement = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => {
                return Err(RuntimeError::new(
                    "witness_chain() requires string statement",
                ))
            }
        };

        let witnesses: Vec<String> = match &args[1] {
            Value::Array(arr) => {
                let borrowed = arr.borrow();
                borrowed
                    .iter()
                    .filter_map(|v| {
                        if let Value::String(s) = v {
                            Some(s.to_string())
                        } else {
                            None
                        }
                    })
                    .collect()
            }
            _ => {
                return Err(RuntimeError::new(
                    "witness_chain() requires array of witness names",
                ))
            }
        };

        if witnesses.is_empty() {
            return Err(RuntimeError::new(
                "witness_chain() requires at least one witness",
            ));
        }

        // Build chain: each witness attests to the previous
        let mut chain = Vec::new();
        let mut prev_hash = blake3::hash(statement.as_bytes()).to_hex().to_string();

        for (i, witness) in witnesses.iter().enumerate() {
            let attestation = format!("{}:attests:{}", witness, prev_hash);
            let hash = blake3::hash(attestation.as_bytes()).to_hex().to_string();

            let mut link = std::collections::HashMap::new();
            link.insert(
                "witness".to_string(),
                Value::String(Rc::new(witness.clone())),
            );
            link.insert("position".to_string(), Value::Int((i + 1) as i64));
            link.insert(
                "attests_to".to_string(),
                Value::String(Rc::new(prev_hash.clone())),
            );
            link.insert(
                "signature".to_string(),
                Value::String(Rc::new(hash.clone())),
            );

            chain.push(Value::Map(Rc::new(RefCell::new(link))));
            prev_hash = hash;
        }

        let mut result = std::collections::HashMap::new();
        result.insert("statement".to_string(), Value::String(Rc::new(statement)));
        result.insert(
            "chain".to_string(),
            Value::Array(Rc::new(RefCell::new(chain))),
        );
        result.insert("final_seal".to_string(), Value::String(Rc::new(prev_hash)));
        result.insert(
            "model".to_string(),
            Value::String(Rc::new("isnad".to_string())),
        );
        result.insert(
            "philosophy".to_string(),
            Value::String(Rc::new(
                "Chain of reliable transmitters - each witness validates the previous".to_string(),
            )),
        );

        Ok(Value::Map(Rc::new(RefCell::new(result))))
    });

    // verify_witness_chain - verify a witness chain is intact
    define(interp, "verify_witness_chain", Some(1), |_, args| {
        let chain_map = match &args[0] {
            Value::Map(m) => m.borrow(),
            _ => {
                return Err(RuntimeError::new(
                    "verify_witness_chain() requires chain map",
                ))
            }
        };

        let statement = match chain_map.get("statement") {
            Some(Value::String(s)) => s.to_string(),
            _ => {
                return Err(RuntimeError::new(
                    "verify_witness_chain() invalid chain format",
                ))
            }
        };

        let chain = match chain_map.get("chain") {
            Some(Value::Array(arr)) => arr.borrow().clone(),
            _ => {
                return Err(RuntimeError::new(
                    "verify_witness_chain() invalid chain format",
                ))
            }
        };

        let mut prev_hash = blake3::hash(statement.as_bytes()).to_hex().to_string();

        for link_val in chain.iter() {
            if let Value::Map(link_map) = link_val {
                let link = link_map.borrow();
                let witness = match link.get("witness") {
                    Some(Value::String(s)) => s.to_string(),
                    _ => return Ok(Value::Bool(false)),
                };
                let attests_to = match link.get("attests_to") {
                    Some(Value::String(s)) => s.to_string(),
                    _ => return Ok(Value::Bool(false)),
                };
                let signature = match link.get("signature") {
                    Some(Value::String(s)) => s.to_string(),
                    _ => return Ok(Value::Bool(false)),
                };

                // Verify attestation
                if attests_to != prev_hash {
                    return Ok(Value::Bool(false));
                }

                let expected = format!("{}:attests:{}", witness, prev_hash);
                let computed = blake3::hash(expected.as_bytes()).to_hex().to_string();

                if computed != signature {
                    return Ok(Value::Bool(false));
                }

                prev_hash = signature;
            } else {
                return Ok(Value::Bool(false));
            }
        }

        Ok(Value::Bool(true))
    });

    // === Experimental Crypto Info ===
    define(interp, "experimental_crypto_info", Some(0), |_, _| {
        let mut info = std::collections::HashMap::new();

        info.insert(
            "commitment_functions".to_string(),
            Value::Array(Rc::new(RefCell::new(vec![
                Value::String(Rc::new("commit".to_string())),
                Value::String(Rc::new("verify_commitment".to_string())),
            ]))),
        );

        info.insert(
            "threshold_functions".to_string(),
            Value::Array(Rc::new(RefCell::new(vec![
                Value::String(Rc::new("secret_split".to_string())),
                Value::String(Rc::new("secret_recover".to_string())),
            ]))),
        );

        info.insert(
            "cultural_ceremonies".to_string(),
            Value::Array(Rc::new(RefCell::new(vec![
                Value::String(Rc::new(
                    "council_split (Ubuntu - African consensus)".to_string(),
                )),
                Value::String(Rc::new(
                    "witness_chain (Isnad - Islamic transmission)".to_string(),
                )),
            ]))),
        );

        Ok(Value::Map(Rc::new(RefCell::new(info))))
    });
}

/// Evaluate polynomial in GF(256) at point x
fn eval_polynomial_gf256(coefficients: &[u8], x: u8) -> u8 {
    let mut result: u8 = 0;
    let mut x_power: u8 = 1;

    for &coef in coefficients {
        result ^= gf256_mul(coef, x_power);
        x_power = gf256_mul(x_power, x);
    }

    result
}

/// Lagrange interpolation in GF(256) to find f(0)
fn lagrange_interpolate_gf256(points: &[(u8, u8)], _x: u8) -> u8 {
    let mut result: u8 = 0;

    for (i, &(xi, yi)) in points.iter().enumerate() {
        let mut numerator: u8 = 1;
        let mut denominator: u8 = 1;

        for (j, &(xj, _)) in points.iter().enumerate() {
            if i != j {
                // numerator *= (0 - xj) = xj (in GF256, subtraction is XOR)
                numerator = gf256_mul(numerator, xj);
                // denominator *= (xi - xj)
                denominator = gf256_mul(denominator, xi ^ xj);
            }
        }

        // term = yi * numerator / denominator
        let term = gf256_mul(yi, gf256_mul(numerator, gf256_inv(denominator)));
        result ^= term;
    }

    result
}

/// GF(256) multiplication using Russian peasant algorithm
fn gf256_mul(mut a: u8, mut b: u8) -> u8 {
    let mut result: u8 = 0;
    let modulus: u16 = 0x11b; // x^8 + x^4 + x^3 + x + 1

    while b != 0 {
        if b & 1 != 0 {
            result ^= a;
        }
        let high_bit = (a & 0x80) != 0;
        a <<= 1;
        if high_bit {
            a ^= (modulus & 0xff) as u8;
        }
        b >>= 1;
    }

    result
}

/// GF(256) multiplicative inverse using extended Euclidean algorithm
fn gf256_inv(a: u8) -> u8 {
    if a == 0 {
        return 0;
    }

    // Use Fermat's little theorem: a^(-1) = a^(254) in GF(256)
    let mut result = a;
    for _ in 0..6 {
        result = gf256_mul(result, result);
        result = gf256_mul(result, a);
    }
    gf256_mul(result, result)
}

// ============================================================================
// MULTI-BASE ENCODING: Polycultural numeral systems and crypto addresses
// ============================================================================
//
// Sigil supports multiple numeral bases reflecting different mathematical traditions:
//   Binary (2)      - 0b prefix - Modern computing
//   Octal (8)       - 0o prefix - Unix permissions
//   Decimal (10)    - Default   - Indo-Arabic (global standard)
//   Duodecimal (12) - 0z prefix - Dozen system (time, music)
//   Hexadecimal (16)- 0x prefix - Computing, colors
//   Vigesimal (20)  - 0v prefix - Mayan, Celtic, Basque
//   Sexagesimal (60)- 0s prefix - Babylonian (time, angles)
//
// Plus special encodings:
//   Base58  - Bitcoin addresses (no confusing 0/O/I/l)
//   Base32  - Case-insensitive, no confusing chars
//   Base36  - Alphanumeric only

fn register_multibase(interp: &mut Interpreter) {
    // === Vigesimal (Base 20) - Mayan/Celtic ===
    // Digits: 0-9, A-J (or a-j)

    define(interp, "to_vigesimal", Some(1), |_, args| {
        let n = match &args[0] {
            Value::Int(n) => *n,
            _ => return Err(RuntimeError::new("to_vigesimal() requires integer")),
        };

        let result = to_base_string(n.unsigned_abs(), 20, false);
        let prefix = if n < 0 { "-0v" } else { "0v" };
        Ok(Value::String(Rc::new(format!("{}{}", prefix, result))))
    });

    define(interp, "from_vigesimal", Some(1), |_, args| {
        let s = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("from_vigesimal() requires string")),
        };

        let (negative, clean) = parse_base_prefix(&s, "0v");
        let value = from_base_string(&clean, 20)?;
        Ok(Value::Int(if negative {
            -(value as i64)
        } else {
            value as i64
        }))
    });

    // === Sexagesimal (Base 60) - Babylonian ===
    // Uses colon-separated groups for readability: "1:30:45" = 1*3600 + 30*60 + 45

    define(interp, "to_sexagesimal", Some(1), |_, args| {
        let n = match &args[0] {
            Value::Int(n) => *n,
            _ => return Err(RuntimeError::new("to_sexagesimal() requires integer")),
        };

        let negative = n < 0;
        let mut value = n.unsigned_abs();
        let mut parts = Vec::new();

        if value == 0 {
            parts.push("0".to_string());
        } else {
            while value > 0 {
                parts.push(format!("{}", value % 60));
                value /= 60;
            }
            parts.reverse();
        }

        let prefix = if negative { "-0s" } else { "0s" };
        Ok(Value::String(Rc::new(format!(
            "{}[{}]",
            prefix,
            parts.join(":")
        ))))
    });

    define(interp, "from_sexagesimal", Some(1), |_, args| {
        let s = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("from_sexagesimal() requires string")),
        };

        let negative = s.starts_with('-');
        let clean = s
            .trim_start_matches('-')
            .trim_start_matches("0s")
            .trim_start_matches('[')
            .trim_end_matches(']');

        let mut result: i64 = 0;
        for part in clean.split(':') {
            let digit: i64 = part
                .trim()
                .parse()
                .map_err(|_| RuntimeError::new(format!("Invalid sexagesimal digit: {}", part)))?;
            if digit < 0 || digit >= 60 {
                return Err(RuntimeError::new(format!(
                    "Sexagesimal digit out of range: {}",
                    digit
                )));
            }
            result = result * 60 + digit;
        }

        Ok(Value::Int(if negative { -result } else { result }))
    });

    // === Duodecimal (Base 12) - Dozen system ===
    // Digits: 0-9, X (10), E (11) - Dozenal Society convention

    define(interp, "to_duodecimal", Some(1), |_, args| {
        let n = match &args[0] {
            Value::Int(n) => *n,
            _ => return Err(RuntimeError::new("to_duodecimal() requires integer")),
        };

        let result = to_base_string_custom(n.unsigned_abs(), 12, "0123456789XE");
        let prefix = if n < 0 { "-0z" } else { "0z" };
        Ok(Value::String(Rc::new(format!("{}{}", prefix, result))))
    });

    define(interp, "from_duodecimal", Some(1), |_, args| {
        let s = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("from_duodecimal() requires string")),
        };

        let (negative, clean) = parse_base_prefix(&s, "0z");
        let value = from_base_string_custom(&clean.to_uppercase(), "0123456789XE")?;
        Ok(Value::Int(if negative {
            -(value as i64)
        } else {
            value as i64
        }))
    });

    // === Generic Base Conversion ===

    define(interp, "to_base", Some(2), |_, args| {
        let n = match &args[0] {
            Value::Int(n) => *n,
            _ => return Err(RuntimeError::new("to_base() requires integer")),
        };
        let base = match &args[1] {
            Value::Int(b) => *b as u64,
            _ => return Err(RuntimeError::new("to_base() requires integer base")),
        };

        if base < 2 || base > 36 {
            return Err(RuntimeError::new("to_base() base must be 2-36"));
        }

        let result = to_base_string(n.unsigned_abs(), base, false);
        let prefix = if n < 0 { "-" } else { "" };
        Ok(Value::String(Rc::new(format!("{}{}", prefix, result))))
    });

    define(interp, "from_base", Some(2), |_, args| {
        let s = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("from_base() requires string")),
        };
        let base = match &args[1] {
            Value::Int(b) => *b as u64,
            _ => return Err(RuntimeError::new("from_base() requires integer base")),
        };

        if base < 2 || base > 36 {
            return Err(RuntimeError::new("from_base() base must be 2-36"));
        }

        let negative = s.starts_with('-');
        let clean = s.trim_start_matches('-');
        let value = from_base_string(clean, base)?;
        Ok(Value::Int(if negative {
            -(value as i64)
        } else {
            value as i64
        }))
    });

    // === Base58 - Bitcoin/IPFS addresses ===
    // Alphabet: 123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz
    // Excludes: 0, O, I, l (confusing characters)

    const BASE58_ALPHABET: &str = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";

    define(interp, "base58_encode", Some(1), |_, args| {
        let bytes: Vec<u8> = match &args[0] {
            Value::String(s) => s.as_bytes().to_vec(),
            Value::Array(arr) => arr
                .borrow()
                .iter()
                .filter_map(|v| {
                    if let Value::Int(i) = v {
                        Some(*i as u8)
                    } else {
                        None
                    }
                })
                .collect(),
            _ => {
                return Err(RuntimeError::new(
                    "base58_encode() requires string or byte array",
                ))
            }
        };

        // Count leading zeros
        let leading_zeros = bytes.iter().take_while(|&&b| b == 0).count();

        // Convert to big integer and then to base58
        let mut result = Vec::new();
        let mut num: Vec<u8> = bytes.clone();

        while !num.is_empty() && !num.iter().all(|&b| b == 0) {
            let mut remainder = 0u32;
            let mut new_num = Vec::new();

            for &byte in &num {
                let acc = (remainder << 8) + byte as u32;
                let digit = acc / 58;
                remainder = acc % 58;

                if !new_num.is_empty() || digit > 0 {
                    new_num.push(digit as u8);
                }
            }

            result.push(BASE58_ALPHABET.chars().nth(remainder as usize).unwrap());
            num = new_num;
        }

        // Add '1' for each leading zero byte
        for _ in 0..leading_zeros {
            result.push('1');
        }

        result.reverse();
        Ok(Value::String(Rc::new(result.into_iter().collect())))
    });

    define(interp, "base58_decode", Some(1), |_, args| {
        let s = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("base58_decode() requires string")),
        };

        // Count leading '1's
        let leading_ones = s.chars().take_while(|&c| c == '1').count();

        // Convert from base58 to big integer
        let mut num: Vec<u8> = Vec::new();

        for c in s.chars() {
            let digit = BASE58_ALPHABET
                .find(c)
                .ok_or_else(|| RuntimeError::new(format!("Invalid base58 character: {}", c)))?;

            let mut carry = digit as u32;
            for byte in num.iter_mut().rev() {
                let acc = (*byte as u32) * 58 + carry;
                *byte = (acc & 0xff) as u8;
                carry = acc >> 8;
            }

            while carry > 0 {
                num.insert(0, (carry & 0xff) as u8);
                carry >>= 8;
            }
        }

        // Add leading zeros
        let mut result = vec![0u8; leading_ones];
        result.extend(num);

        // Return as hex string for readability
        Ok(Value::String(Rc::new(hex::encode(&result))))
    });

    // === Base32 - Case insensitive, no confusing chars ===
    // RFC 4648 alphabet: A-Z, 2-7

    const BASE32_ALPHABET: &str = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";

    define(interp, "base32_encode", Some(1), |_, args| {
        let bytes: Vec<u8> = match &args[0] {
            Value::String(s) => s.as_bytes().to_vec(),
            Value::Array(arr) => arr
                .borrow()
                .iter()
                .filter_map(|v| {
                    if let Value::Int(i) = v {
                        Some(*i as u8)
                    } else {
                        None
                    }
                })
                .collect(),
            _ => {
                return Err(RuntimeError::new(
                    "base32_encode() requires string or byte array",
                ))
            }
        };

        let mut result = String::new();
        let mut buffer: u64 = 0;
        let mut bits = 0;

        for byte in bytes {
            buffer = (buffer << 8) | byte as u64;
            bits += 8;

            while bits >= 5 {
                bits -= 5;
                let idx = ((buffer >> bits) & 0x1f) as usize;
                result.push(BASE32_ALPHABET.chars().nth(idx).unwrap());
            }
        }

        if bits > 0 {
            let idx = ((buffer << (5 - bits)) & 0x1f) as usize;
            result.push(BASE32_ALPHABET.chars().nth(idx).unwrap());
        }

        // Padding
        while result.len() % 8 != 0 {
            result.push('=');
        }

        Ok(Value::String(Rc::new(result)))
    });

    define(interp, "base32_decode", Some(1), |_, args| {
        let s = match &args[0] {
            Value::String(s) => s.to_uppercase().replace('=', ""),
            _ => return Err(RuntimeError::new("base32_decode() requires string")),
        };

        let mut result = Vec::new();
        let mut buffer: u64 = 0;
        let mut bits = 0;

        for c in s.chars() {
            let digit = BASE32_ALPHABET
                .find(c)
                .ok_or_else(|| RuntimeError::new(format!("Invalid base32 character: {}", c)))?;

            buffer = (buffer << 5) | digit as u64;
            bits += 5;

            if bits >= 8 {
                bits -= 8;
                result.push((buffer >> bits) as u8);
                buffer &= (1 << bits) - 1;
            }
        }

        Ok(Value::String(Rc::new(hex::encode(&result))))
    });

    // === Cultural Numerology ===

    // sacred_numbers - get sacred/significant numbers for a culture
    define(interp, "sacred_numbers", Some(1), |_, args| {
        let culture = match &args[0] {
            Value::String(s) => s.to_lowercase(),
            _ => {
                return Err(RuntimeError::new(
                    "sacred_numbers() requires string culture",
                ))
            }
        };

        let numbers: Vec<(i64, &str)> = match culture.as_str() {
            "mayan" | "maya" => vec![
                (13, "Sacred cycle - Tzolkin calendar"),
                (20, "Base of vigesimal system - human digits"),
                (52, "Calendar round - 52 years"),
                (260, "Tzolkin sacred calendar days"),
                (365, "Haab solar calendar days"),
                (400, "Baktun - 20×20 years"),
            ],
            "babylonian" | "mesopotamian" => vec![
                (12, "Months, hours - celestial division"),
                (60, "Sexagesimal base - minutes, seconds, degrees"),
                (360, "Circle degrees - 6×60"),
                (3600, "Sar - 60×60, large count"),
                (7, "Planets visible to naked eye"),
            ],
            "chinese" | "zh" => vec![
                (8, "八 (bā) - prosperity, wealth (sounds like 發)"),
                (9, "九 (jiǔ) - longevity (sounds like 久)"),
                (6, "六 (liù) - smooth, flowing"),
                (2, "二 (èr) - pairs, harmony"),
                (4, "四 (sì) - AVOID - sounds like death (死)"),
                (5, "五 (wǔ) - five elements"),
                (12, "十二 - zodiac animals"),
            ],
            "japanese" | "ja" => vec![
                (7, "七 (nana) - lucky, seven gods of fortune"),
                (8, "八 (hachi) - prosperity, expansion"),
                (3, "三 (san) - completeness"),
                (5, "五 (go) - five elements"),
                (4, "四 (shi) - AVOID - sounds like death (死)"),
                (9, "九 (ku) - AVOID - sounds like suffering (苦)"),
            ],
            "hebrew" | "jewish" => vec![
                (7, "Shabbat, creation days, menorah branches"),
                (18, "Chai (חי) - life - gematria of ח(8) + י(10)"),
                (40, "Transformation - flood, Sinai, wilderness"),
                (12, "Tribes of Israel"),
                (613, "Mitzvot - commandments"),
                (26, "Gematria of YHWH"),
            ],
            "islamic" | "arabic" | "ar" => vec![
                (5, "Pillars of Islam, daily prayers"),
                (7, "Heavens, circumambulation of Kaaba"),
                (40, "Age of prophethood, days of repentance"),
                (99, "Names of Allah"),
                (786, "Abjad value of Bismillah"),
            ],
            "hindu" | "indian" | "hi" => vec![
                (108, "Sacred beads, Upanishads, sun's distance"),
                (7, "Chakras (main), rishis, sacred rivers"),
                (3, "Trimurti - Brahma, Vishnu, Shiva"),
                (4, "Vedas, yugas, varnas"),
                (9, "Planets (navagraha), durga forms"),
                (1008, "Names of Vishnu"),
            ],
            "greek" | "pythagorean" => vec![
                (1, "Monad - unity, source"),
                (2, "Dyad - duality, diversity"),
                (3, "Triad - harmony, completion"),
                (4, "Tetrad - solidity, earth"),
                (7, "Heptad - perfection"),
                (10, "Decad - tetractys, divine"),
                (12, "Olympian gods"),
            ],
            "celtic" | "irish" => vec![
                (3, "Triple goddess, triquetra"),
                (5, "Elements including spirit"),
                (9, "Triple threes - sacred completion"),
                (13, "Lunar months"),
                (17, "St. Patrick's Day"),
                (20, "Vigesimal counting"),
            ],
            _ => vec![
                (1, "Unity"),
                (7, "Widely considered lucky"),
                (12, "Dozen - practical division"),
                (13, "Often considered unlucky in West"),
            ],
        };

        let result: Vec<Value> = numbers
            .iter()
            .map(|(n, meaning)| {
                let mut entry = std::collections::HashMap::new();
                entry.insert("number".to_string(), Value::Int(*n));
                entry.insert(
                    "meaning".to_string(),
                    Value::String(Rc::new(meaning.to_string())),
                );
                Value::Map(Rc::new(RefCell::new(entry)))
            })
            .collect();

        Ok(Value::Array(Rc::new(RefCell::new(result))))
    });

    // is_sacred - check if a number is sacred in a culture
    define(interp, "is_sacred", Some(2), |_, args| {
        let n = match &args[0] {
            Value::Int(n) => *n,
            _ => return Err(RuntimeError::new("is_sacred() requires integer")),
        };
        let culture = match &args[1] {
            Value::String(s) => s.to_lowercase(),
            _ => return Err(RuntimeError::new("is_sacred() requires string culture")),
        };

        let sacred = match culture.as_str() {
            "mayan" | "maya" => vec![13, 20, 52, 260, 365, 400],
            "babylonian" | "mesopotamian" => vec![12, 60, 360, 3600, 7],
            "chinese" | "zh" => vec![8, 9, 6, 2, 5, 12],
            "japanese" | "ja" => vec![7, 8, 3, 5],
            "hebrew" | "jewish" => vec![7, 18, 40, 12, 613, 26],
            "islamic" | "arabic" | "ar" => vec![5, 7, 40, 99, 786],
            "hindu" | "indian" | "hi" => vec![108, 7, 3, 4, 9, 1008],
            "greek" | "pythagorean" => vec![1, 2, 3, 4, 7, 10, 12],
            "celtic" | "irish" => vec![3, 5, 9, 13, 17, 20],
            _ => vec![7, 12],
        };

        Ok(Value::Bool(sacred.contains(&n)))
    });

    // is_unlucky - check if a number is unlucky in a culture
    define(interp, "is_unlucky", Some(2), |_, args| {
        let n = match &args[0] {
            Value::Int(n) => *n,
            _ => return Err(RuntimeError::new("is_unlucky() requires integer")),
        };
        let culture = match &args[1] {
            Value::String(s) => s.to_lowercase(),
            _ => return Err(RuntimeError::new("is_unlucky() requires string culture")),
        };

        let unlucky = match culture.as_str() {
            "chinese" | "zh" => vec![4],     // 四 sounds like 死 (death)
            "japanese" | "ja" => vec![4, 9], // 四=death, 九=suffering
            "western" | "en" => vec![13],    // Friday the 13th
            "italian" | "it" => vec![17],    // XVII = VIXI (I lived = I'm dead)
            _ => vec![],
        };

        Ok(Value::Bool(unlucky.contains(&n)))
    });

    // number_meaning - get the cultural meaning of a specific number
    define(interp, "number_meaning", Some(2), |_, args| {
        let n = match &args[0] {
            Value::Int(n) => *n,
            _ => return Err(RuntimeError::new("number_meaning() requires integer")),
        };
        let culture = match &args[1] {
            Value::String(s) => s.to_lowercase(),
            _ => {
                return Err(RuntimeError::new(
                    "number_meaning() requires string culture",
                ))
            }
        };

        let meaning = match (n, culture.as_str()) {
            // Chinese
            (8, "chinese" | "zh") => "八 (bā) - Most auspicious, sounds like 發 (prosperity)",
            (4, "chinese" | "zh") => "四 (sì) - Unlucky, sounds like 死 (death)",
            (9, "chinese" | "zh") => "九 (jiǔ) - Longevity, sounds like 久 (long-lasting)",
            (6, "chinese" | "zh") => "六 (liù) - Smooth and well-off",
            (2, "chinese" | "zh") => "二 (èr) - Good things come in pairs",

            // Japanese
            (7, "japanese" | "ja") => "七 (nana) - Lucky, seven gods of fortune",
            (8, "japanese" | "ja") => "八 (hachi) - Lucky, represents spreading prosperity",
            (4, "japanese" | "ja") => "四 (shi) - Unlucky, homophone of death",
            (9, "japanese" | "ja") => "九 (ku) - Unlucky, homophone of suffering",

            // Hebrew
            (18, "hebrew" | "jewish") => "Chai (חי) - Life itself, most auspicious",
            (7, "hebrew" | "jewish") => "Divine completion - Shabbat, menorah, creation",
            (40, "hebrew" | "jewish") => "Transformation - flood, Sinai, wilderness years",
            (613, "hebrew" | "jewish") => "Taryag - total number of mitzvot (commandments)",

            // Mayan
            (13, "mayan" | "maya") => "Sacred Tzolkin cycle, celestial layers",
            (20, "mayan" | "maya") => "Vigesimal base - fingers and toes, uinal",
            (260, "mayan" | "maya") => "Tzolkin calendar - 13 × 20 sacred days",

            // Babylonian
            (60, "babylonian" | "mesopotamian") => {
                "Sexagesimal base - divisible by 2,3,4,5,6,10,12,15,20,30"
            }
            (360, "babylonian" | "mesopotamian") => "Circle degrees - celestial observation",

            // Hindu
            (108, "hindu" | "indian" | "hi") => {
                "Sacred completeness - mala beads, Upanishads, sun ratio"
            }
            (3, "hindu" | "indian" | "hi") => "Trimurti - Brahma, Vishnu, Shiva",
            (9, "hindu" | "indian" | "hi") => "Navagraha (9 planets), Durga's 9 forms",

            // Islamic
            (99, "islamic" | "arabic" | "ar") => "Asma ul-Husna - 99 names of Allah",
            (5, "islamic" | "arabic" | "ar") => "Five pillars of Islam",
            (786, "islamic" | "arabic" | "ar") => "Abjad numerology of Bismillah",

            // Greek/Pythagorean
            (10, "greek" | "pythagorean") => "Tetractys - 1+2+3+4, perfect number",
            (7, "greek" | "pythagorean") => "Heptad - virgin number, Athena's number",

            _ => "No specific cultural meaning recorded",
        };

        let mut result = std::collections::HashMap::new();
        result.insert("number".to_string(), Value::Int(n));
        result.insert("culture".to_string(), Value::String(Rc::new(culture)));
        result.insert(
            "meaning".to_string(),
            Value::String(Rc::new(meaning.to_string())),
        );

        Ok(Value::Map(Rc::new(RefCell::new(result))))
    });

    // === Time encoding using Babylonian sexagesimal ===

    // to_babylonian_time - convert seconds to Babylonian notation
    define(interp, "to_babylonian_time", Some(1), |_, args| {
        let seconds = match &args[0] {
            Value::Int(n) => *n,
            Value::Float(f) => *f as i64,
            _ => return Err(RuntimeError::new("to_babylonian_time() requires number")),
        };

        let hours = seconds / 3600;
        let mins = (seconds % 3600) / 60;
        let secs = seconds % 60;

        Ok(Value::String(Rc::new(format!(
            "0s[{}:{}:{}]",
            hours, mins, secs
        ))))
    });

    // from_babylonian_time - convert Babylonian time to seconds
    define(interp, "from_babylonian_time", Some(1), |_, args| {
        let s = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("from_babylonian_time() requires string")),
        };

        let clean = s
            .trim_start_matches("0s")
            .trim_start_matches('[')
            .trim_end_matches(']');

        let parts: Vec<i64> = clean
            .split(':')
            .map(|p| p.trim().parse::<i64>().unwrap_or(0))
            .collect();

        let seconds = match parts.len() {
            1 => parts[0],
            2 => parts[0] * 60 + parts[1],
            3 => parts[0] * 3600 + parts[1] * 60 + parts[2],
            _ => return Err(RuntimeError::new("Invalid Babylonian time format")),
        };

        Ok(Value::Int(seconds))
    });

    // === Multi-base secret sharing ===

    // vigesimal_shares - split secret with shares in Mayan base-20
    define(interp, "vigesimal_shares", Some(3), |_, args| {
        let secret = match &args[0] {
            Value::String(s) => s.as_bytes().to_vec(),
            _ => {
                return Err(RuntimeError::new(
                    "vigesimal_shares() requires string secret",
                ))
            }
        };

        let threshold = match &args[1] {
            Value::Int(n) => *n as usize,
            _ => {
                return Err(RuntimeError::new(
                    "vigesimal_shares() requires integer threshold",
                ))
            }
        };

        let num_shares = match &args[2] {
            Value::Int(n) => *n as usize,
            _ => {
                return Err(RuntimeError::new(
                    "vigesimal_shares() requires integer num_shares",
                ))
            }
        };

        if threshold < 2 || num_shares < threshold || num_shares > 20 {
            return Err(RuntimeError::new(
                "vigesimal_shares() requires 2 <= threshold <= num_shares <= 20 (Mayan limit)",
            ));
        }

        // Generate shares using Shamir
        let mut rng = rand::thread_rng();
        let mut shares: Vec<Vec<u8>> = (0..num_shares)
            .map(|_| Vec::with_capacity(secret.len() + 1))
            .collect();

        for (i, share) in shares.iter_mut().enumerate() {
            share.push((i + 1) as u8);
        }

        for &byte in &secret {
            let mut coefficients: Vec<u8> = vec![byte];
            for _ in 1..threshold {
                coefficients.push(rng.gen());
            }

            for (i, share) in shares.iter_mut().enumerate() {
                let x = (i + 1) as u8;
                let y = eval_polynomial_gf256(&coefficients, x);
                share.push(y);
            }
        }

        // Encode shares in vigesimal
        let share_values: Vec<Value> = shares
            .iter()
            .enumerate()
            .map(|(i, share)| {
                let mut entry = std::collections::HashMap::new();

                // Convert share bytes to vigesimal string
                let mut vig_parts: Vec<String> = Vec::new();
                for &byte in share {
                    vig_parts.push(to_base_string(byte as u64, 20, true));
                }

                entry.insert("index".to_string(), Value::Int((i + 1) as i64));
                entry.insert(
                    "vigesimal".to_string(),
                    Value::String(Rc::new(format!("0v{}", vig_parts.join(".")))),
                );
                entry.insert(
                    "hex".to_string(),
                    Value::String(Rc::new(hex::encode(share))),
                );

                Value::Map(Rc::new(RefCell::new(entry)))
            })
            .collect();

        let mut result = std::collections::HashMap::new();
        result.insert(
            "shares".to_string(),
            Value::Array(Rc::new(RefCell::new(share_values))),
        );
        result.insert("threshold".to_string(), Value::Int(threshold as i64));
        result.insert("total".to_string(), Value::Int(num_shares as i64));
        result.insert(
            "base".to_string(),
            Value::String(Rc::new("vigesimal (Mayan base-20)".to_string())),
        );

        Ok(Value::Map(Rc::new(RefCell::new(result))))
    });

    // multibase_info - get information about supported bases
    define(interp, "multibase_info", Some(0), |_, _| {
        let mut info = std::collections::HashMap::new();

        let bases = vec![
            ("binary", 2, "0b", "Modern computing"),
            ("octal", 8, "0o", "Unix, historical computing"),
            ("decimal", 10, "", "Indo-Arabic global standard"),
            (
                "duodecimal",
                12,
                "0z",
                "Dozen system - time, music, measurement",
            ),
            ("hexadecimal", 16, "0x", "Computing, colors, addresses"),
            (
                "vigesimal",
                20,
                "0v",
                "Mayan, Celtic, Basque - human digits",
            ),
            (
                "sexagesimal",
                60,
                "0s",
                "Babylonian - time, angles, astronomy",
            ),
        ];

        let base_list: Vec<Value> = bases
            .iter()
            .map(|(name, base, prefix, desc)| {
                let mut entry = std::collections::HashMap::new();
                entry.insert("name".to_string(), Value::String(Rc::new(name.to_string())));
                entry.insert("base".to_string(), Value::Int(*base as i64));
                entry.insert(
                    "prefix".to_string(),
                    Value::String(Rc::new(prefix.to_string())),
                );
                entry.insert(
                    "origin".to_string(),
                    Value::String(Rc::new(desc.to_string())),
                );
                Value::Map(Rc::new(RefCell::new(entry)))
            })
            .collect();

        info.insert(
            "numeral_systems".to_string(),
            Value::Array(Rc::new(RefCell::new(base_list))),
        );

        let encodings = vec!["base58 (Bitcoin)", "base32 (RFC 4648)", "base64 (standard)"];
        let enc_list: Vec<Value> = encodings
            .iter()
            .map(|s| Value::String(Rc::new(s.to_string())))
            .collect();
        info.insert(
            "special_encodings".to_string(),
            Value::Array(Rc::new(RefCell::new(enc_list))),
        );

        let cultures = vec![
            "mayan",
            "babylonian",
            "chinese",
            "japanese",
            "hebrew",
            "islamic",
            "hindu",
            "greek",
            "celtic",
        ];
        let cult_list: Vec<Value> = cultures
            .iter()
            .map(|s| Value::String(Rc::new(s.to_string())))
            .collect();
        info.insert(
            "supported_cultures".to_string(),
            Value::Array(Rc::new(RefCell::new(cult_list))),
        );

        Ok(Value::Map(Rc::new(RefCell::new(info))))
    });
}

// Helper functions for base conversion

fn to_base_string(mut n: u64, base: u64, pad_to_two: bool) -> String {
    const DIGITS: &[u8] = b"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";

    if n == 0 {
        return if pad_to_two {
            "00".to_string()
        } else {
            "0".to_string()
        };
    }

    let mut result = Vec::new();
    while n > 0 {
        result.push(DIGITS[(n % base) as usize] as char);
        n /= base;
    }

    if pad_to_two && result.len() < 2 {
        result.push('0');
    }

    result.reverse();
    result.into_iter().collect()
}

fn to_base_string_custom(mut n: u64, base: u64, digits: &str) -> String {
    if n == 0 {
        return digits.chars().next().unwrap().to_string();
    }

    let mut result = Vec::new();
    let digit_chars: Vec<char> = digits.chars().collect();

    while n > 0 {
        result.push(digit_chars[(n % base) as usize]);
        n /= base;
    }

    result.reverse();
    result.into_iter().collect()
}

fn from_base_string(s: &str, base: u64) -> Result<u64, RuntimeError> {
    let mut result: u64 = 0;

    for c in s.chars() {
        let digit = match c {
            '0'..='9' => c as u64 - '0' as u64,
            'A'..='Z' => c as u64 - 'A' as u64 + 10,
            'a'..='z' => c as u64 - 'a' as u64 + 10,
            _ => return Err(RuntimeError::new(format!("Invalid digit: {}", c))),
        };

        if digit >= base {
            return Err(RuntimeError::new(format!(
                "Digit {} out of range for base {}",
                c, base
            )));
        }

        result = result
            .checked_mul(base)
            .and_then(|r| r.checked_add(digit))
            .ok_or_else(|| RuntimeError::new("Number overflow"))?;
    }

    Ok(result)
}

fn from_base_string_custom(s: &str, digits: &str) -> Result<u64, RuntimeError> {
    let base = digits.len() as u64;
    let mut result: u64 = 0;

    for c in s.chars() {
        let digit = digits
            .find(c)
            .ok_or_else(|| RuntimeError::new(format!("Invalid digit: {}", c)))?
            as u64;

        result = result
            .checked_mul(base)
            .and_then(|r| r.checked_add(digit))
            .ok_or_else(|| RuntimeError::new("Number overflow"))?;
    }

    Ok(result)
}

fn parse_base_prefix(s: &str, prefix: &str) -> (bool, String) {
    let negative = s.starts_with('-');
    let clean = s
        .trim_start_matches('-')
        .trim_start_matches(prefix)
        .to_string();
    (negative, clean)
}

// ============================================================================
// POLYCULTURAL AUDIO: World tuning systems, sacred frequencies, synthesis
// ============================================================================
//
// Sigil's audio system respects that music is not universal - different cultures
// have fundamentally different relationships with pitch, scale, and meaning.
//
// Waveform Morphemes:
//   ∿  sine     - pure tone, fundamental
//   ⊓  square   - digital, odd harmonics
//   ⋀  sawtooth - bright, all harmonics
//   △  triangle - mellow, odd harmonics (weaker)
//
// Tuning Systems:
//   12-TET     - Western equal temperament (default)
//   24-TET     - Arabic maqam (quarter tones)
//   22-Shruti  - Indian classical (microtones)
//   Just       - Pure ratios (Pythagorean, etc.)
//   Gamelan    - Indonesian (pelog, slendro)
//   53-TET     - Turkish/Persian (commas)
//
// Sacred Frequencies:
//   ॐ Om       - 136.1 Hz (Earth year frequency)
//   Solfeggio  - 396, 417, 528, 639, 741, 852 Hz
//   Schumann   - 7.83 Hz (Earth resonance)
//   Planetary  - Kepler's music of the spheres

fn register_audio(interp: &mut Interpreter) {
    // =========================================================================
    // TUNING SYSTEMS
    // =========================================================================

    // tune - convert a note to frequency in a specific tuning system
    // Supports: "12tet", "24tet", "just", "pythagorean", "meantone", "gamelan_pelog", "gamelan_slendro"
    define(interp, "tune", Some(3), |_, args| {
        let note = match &args[0] {
            Value::Int(n) => *n as f64, // MIDI note number
            Value::Float(f) => *f,      // Fractional note
            Value::String(s) => parse_note_name(s)?,
            _ => return Err(RuntimeError::new("tune() requires note number or name")),
        };

        let system = match &args[1] {
            Value::String(s) => s.to_lowercase(),
            _ => return Err(RuntimeError::new("tune() requires tuning system name")),
        };

        let root_freq = match &args[2] {
            Value::Float(f) => *f,
            Value::Int(i) => *i as f64,
            _ => return Err(RuntimeError::new("tune() requires root frequency")),
        };

        let freq = match system.as_str() {
            "12tet" | "equal" | "western" => {
                // Standard 12-tone equal temperament
                root_freq * 2.0_f64.powf((note - 69.0) / 12.0)
            }
            "24tet" | "quarter" | "arabic" | "maqam" => {
                // 24-tone equal temperament (quarter tones)
                root_freq * 2.0_f64.powf((note - 69.0) / 24.0)
            }
            "just" | "pure" => {
                // Just intonation ratios from root
                let interval = ((note - 69.0) % 12.0 + 12.0) % 12.0;
                let octave = ((note - 69.0) / 12.0).floor();
                let ratio = just_intonation_ratio(interval as i32);
                root_freq * ratio * 2.0_f64.powf(octave)
            }
            "pythagorean" => {
                // Pythagorean tuning (pure fifths)
                let interval = ((note - 69.0) % 12.0 + 12.0) % 12.0;
                let octave = ((note - 69.0) / 12.0).floor();
                let ratio = pythagorean_ratio(interval as i32);
                root_freq * ratio * 2.0_f64.powf(octave)
            }
            "meantone" | "quarter_comma" => {
                // Quarter-comma meantone
                let interval = ((note - 69.0) % 12.0 + 12.0) % 12.0;
                let octave = ((note - 69.0) / 12.0).floor();
                let ratio = meantone_ratio(interval as i32);
                root_freq * ratio * 2.0_f64.powf(octave)
            }
            "53tet" | "turkish" | "persian" | "comma" => {
                // 53-TET (Turkish/Persian music, approximates just intonation)
                root_freq * 2.0_f64.powf((note - 69.0) / 53.0)
            }
            "22shruti" | "shruti" | "indian" => {
                // Indian 22-shruti system
                let shruti = (note - 69.0) % 22.0;
                let octave = ((note - 69.0) / 22.0).floor();
                let ratio = shruti_ratio(shruti as i32);
                root_freq * ratio * 2.0_f64.powf(octave)
            }
            "gamelan_pelog" | "pelog" => {
                // Javanese pelog (7-note)
                let degree = ((note - 69.0) % 7.0 + 7.0) % 7.0;
                let octave = ((note - 69.0) / 7.0).floor();
                let ratio = pelog_ratio(degree as i32);
                root_freq * ratio * 2.0_f64.powf(octave)
            }
            "gamelan_slendro" | "slendro" => {
                // Javanese slendro (5-note, roughly equal)
                let degree = ((note - 69.0) % 5.0 + 5.0) % 5.0;
                let octave = ((note - 69.0) / 5.0).floor();
                let ratio = slendro_ratio(degree as i32);
                root_freq * ratio * 2.0_f64.powf(octave)
            }
            "bohlen_pierce" | "bp" => {
                // Bohlen-Pierce scale (tritave-based, 13 steps)
                root_freq * 3.0_f64.powf((note - 69.0) / 13.0)
            }
            _ => {
                return Err(RuntimeError::new(format!(
                    "Unknown tuning system: {}",
                    system
                )))
            }
        };

        Ok(Value::Float(freq))
    });

    // tuning_info - get information about a tuning system
    define(interp, "tuning_info", Some(1), |_, args| {
        let system = match &args[0] {
            Value::String(s) => s.to_lowercase(),
            _ => return Err(RuntimeError::new("tuning_info() requires string")),
        };

        let (name, notes_per_octave, origin, description) = match system.as_str() {
            "12tet" | "equal" | "western" => (
                "12-TET", 12, "Western (18th century)",
                "Equal temperament - every semitone is exactly 2^(1/12). Universal but slightly impure."
            ),
            "24tet" | "quarter" | "arabic" | "maqam" => (
                "24-TET", 24, "Arabic/Turkish",
                "Quarter-tone system for maqam music. Enables neutral seconds and other microtones."
            ),
            "just" | "pure" => (
                "Just Intonation", 12, "Ancient (Ptolemy)",
                "Pure frequency ratios (3:2 fifth, 5:4 third). Beatless intervals but limited modulation."
            ),
            "pythagorean" => (
                "Pythagorean", 12, "Ancient Greece",
                "Built entirely from perfect fifths (3:2). Pure fifths but harsh thirds."
            ),
            "meantone" | "quarter_comma" => (
                "Quarter-Comma Meantone", 12, "Renaissance Europe",
                "Tempered fifths for pure major thirds. Beautiful in limited keys."
            ),
            "53tet" | "turkish" | "persian" | "comma" => (
                "53-TET", 53, "Turkish/Persian",
                "53 notes per octave. Closely approximates just intonation and allows maqam/dastgah."
            ),
            "22shruti" | "shruti" | "indian" => (
                "22-Shruti", 22, "Indian Classical",
                "Ancient Indian system. Each shruti is a 'microtone' - the smallest perceptible interval."
            ),
            "gamelan_pelog" | "pelog" => (
                "Pelog", 7, "Javanese Gamelan",
                "Heptatonic scale with unequal steps. Each gamelan has unique tuning - instruments are married."
            ),
            "gamelan_slendro" | "slendro" => (
                "Slendro", 5, "Javanese Gamelan",
                "Pentatonic scale, roughly equal steps (~240 cents). Each ensemble uniquely tuned."
            ),
            "bohlen_pierce" | "bp" => (
                "Bohlen-Pierce", 13, "Modern (1970s)",
                "Non-octave scale based on 3:1 tritave. Alien but mathematically beautiful."
            ),
            _ => return Err(RuntimeError::new(format!("Unknown tuning system: {}", system))),
        };

        let mut info = std::collections::HashMap::new();
        info.insert("name".to_string(), Value::String(Rc::new(name.to_string())));
        info.insert("notes_per_octave".to_string(), Value::Int(notes_per_octave));
        info.insert(
            "origin".to_string(),
            Value::String(Rc::new(origin.to_string())),
        );
        info.insert(
            "description".to_string(),
            Value::String(Rc::new(description.to_string())),
        );

        Ok(Value::Map(Rc::new(RefCell::new(info))))
    });

    // list_tuning_systems - list all available tuning systems
    define(interp, "list_tuning_systems", Some(0), |_, _| {
        let systems = vec![
            ("12tet", "Western equal temperament", 12),
            ("24tet", "Arabic/Turkish quarter-tones", 24),
            ("just", "Pure ratio just intonation", 12),
            ("pythagorean", "Ancient Greek pure fifths", 12),
            ("meantone", "Renaissance quarter-comma", 12),
            ("53tet", "Turkish/Persian comma system", 53),
            ("22shruti", "Indian microtonal", 22),
            ("pelog", "Javanese gamelan 7-note", 7),
            ("slendro", "Javanese gamelan 5-note", 5),
            ("bohlen_pierce", "Non-octave tritave scale", 13),
        ];

        let result: Vec<Value> = systems
            .iter()
            .map(|(name, desc, notes)| {
                let mut entry = std::collections::HashMap::new();
                entry.insert("name".to_string(), Value::String(Rc::new(name.to_string())));
                entry.insert(
                    "description".to_string(),
                    Value::String(Rc::new(desc.to_string())),
                );
                entry.insert("notes_per_octave".to_string(), Value::Int(*notes));
                Value::Map(Rc::new(RefCell::new(entry)))
            })
            .collect();

        Ok(Value::Array(Rc::new(RefCell::new(result))))
    });

    // =========================================================================
    // SACRED FREQUENCIES
    // =========================================================================

    // sacred_freq - get sacred/spiritual frequency by name
    define(interp, "sacred_freq", Some(1), |_, args| {
        let name = match &args[0] {
            Value::String(s) => s.to_lowercase(),
            _ => return Err(RuntimeError::new("sacred_freq() requires string")),
        };

        let (freq, description) = match name.as_str() {
            // Om and Earth frequencies
            "om" | "ॐ" | "aum" => (136.1, "Om - Earth year frequency (Cosmic Om)"),
            "earth_day" => (194.18, "Earth day - one rotation"),
            "earth_year" => (136.1, "Earth year - one orbit (Om frequency)"),
            "schumann" | "earth_resonance" => (
                7.83,
                "Schumann resonance - Earth's electromagnetic heartbeat",
            ),

            // Solfeggio frequencies
            "ut" | "do" | "396" => (396.0, "UT/DO - Liberating guilt and fear"),
            "re" | "417" => (417.0, "RE - Undoing situations, facilitating change"),
            "mi" | "528" => (528.0, "MI - Transformation, miracles, DNA repair"),
            "fa" | "639" => (639.0, "FA - Connecting relationships"),
            "sol" | "741" => (741.0, "SOL - Awakening intuition"),
            "la" | "852" => (852.0, "LA - Returning to spiritual order"),
            "si" | "963" => (963.0, "SI - Divine consciousness, enlightenment"),
            "174" => (174.0, "Solfeggio foundation - pain relief"),
            "285" => (285.0, "Solfeggio - healing tissue"),

            // Planetary frequencies (Kepler/Cousto)
            "sun" | "☉" => (126.22, "Sun - ego, vitality, leadership"),
            "moon" | "☽" | "☾" => (210.42, "Moon - emotion, intuition, cycles"),
            "mercury" | "☿" => (141.27, "Mercury - communication, intellect"),
            "venus" | "♀" => (221.23, "Venus - love, beauty, harmony"),
            "mars" | "♂" => (144.72, "Mars - energy, action, courage"),
            "jupiter" | "♃" => (183.58, "Jupiter - expansion, wisdom, luck"),
            "saturn" | "♄" => (147.85, "Saturn - discipline, structure, time"),

            // Chakra frequencies
            "root" | "muladhara" => (256.0, "Root chakra - survival, grounding (C)"),
            "sacral" | "svadhisthana" => (288.0, "Sacral chakra - creativity, sexuality (D)"),
            "solar" | "manipura" => (320.0, "Solar plexus - will, power (E)"),
            "heart" | "anahata" => (341.3, "Heart chakra - love, compassion (F)"),
            "throat" | "vishuddha" => (384.0, "Throat chakra - expression, truth (G)"),
            "third_eye" | "ajna" => (426.7, "Third eye - intuition, insight (A)"),
            "crown" | "sahasrara" => (480.0, "Crown chakra - consciousness, unity (B)"),

            // Concert pitch standards
            "a440" | "iso" => (440.0, "ISO standard concert pitch (1955)"),
            "a432" | "verdi" => (
                432.0,
                "Verdi pitch - 'mathematically consistent with universe'",
            ),
            "a415" | "baroque" => (415.0, "Baroque pitch - period instrument standard"),
            "a466" | "chorton" => (466.0, "Choir pitch - high Baroque German"),

            // Binaural/brainwave
            "delta" => (2.0, "Delta waves - deep sleep, healing (0.5-4 Hz)"),
            "theta" => (6.0, "Theta waves - meditation, creativity (4-8 Hz)"),
            "alpha" => (10.0, "Alpha waves - relaxation, calm focus (8-13 Hz)"),
            "beta" => (20.0, "Beta waves - alertness, concentration (13-30 Hz)"),
            "gamma" => (40.0, "Gamma waves - insight, peak performance (30-100 Hz)"),

            _ => {
                return Err(RuntimeError::new(format!(
                    "Unknown sacred frequency: {}",
                    name
                )))
            }
        };

        let mut result = std::collections::HashMap::new();
        result.insert("frequency".to_string(), Value::Float(freq));
        result.insert("name".to_string(), Value::String(Rc::new(name)));
        result.insert(
            "meaning".to_string(),
            Value::String(Rc::new(description.to_string())),
        );

        Ok(Value::Map(Rc::new(RefCell::new(result))))
    });

    // solfeggio - get all solfeggio frequencies
    define(interp, "solfeggio", Some(0), |_, _| {
        let frequencies = vec![
            (174.0, "Foundation", "Pain relief, security"),
            (285.0, "Quantum", "Healing tissue, safety"),
            (396.0, "UT", "Liberating guilt and fear"),
            (417.0, "RE", "Undoing situations, change"),
            (528.0, "MI", "Transformation, DNA repair, miracles"),
            (639.0, "FA", "Connecting relationships"),
            (741.0, "SOL", "Awakening intuition"),
            (852.0, "LA", "Spiritual order"),
            (963.0, "SI", "Divine consciousness"),
        ];

        let result: Vec<Value> = frequencies
            .iter()
            .map(|(freq, name, meaning)| {
                let mut entry = std::collections::HashMap::new();
                entry.insert("frequency".to_string(), Value::Float(*freq));
                entry.insert("name".to_string(), Value::String(Rc::new(name.to_string())));
                entry.insert(
                    "meaning".to_string(),
                    Value::String(Rc::new(meaning.to_string())),
                );
                Value::Map(Rc::new(RefCell::new(entry)))
            })
            .collect();

        Ok(Value::Array(Rc::new(RefCell::new(result))))
    });

    // chakras - get all chakra frequencies
    define(interp, "chakras", Some(0), |_, _| {
        let chakras = vec![
            (
                256.0,
                "Muladhara",
                "Root",
                "Red",
                "Survival, grounding, stability",
            ),
            (
                288.0,
                "Svadhisthana",
                "Sacral",
                "Orange",
                "Creativity, sexuality, emotion",
            ),
            (
                320.0,
                "Manipura",
                "Solar Plexus",
                "Yellow",
                "Will, power, self-esteem",
            ),
            (
                341.3,
                "Anahata",
                "Heart",
                "Green",
                "Love, compassion, connection",
            ),
            (
                384.0,
                "Vishuddha",
                "Throat",
                "Blue",
                "Expression, truth, communication",
            ),
            (
                426.7,
                "Ajna",
                "Third Eye",
                "Indigo",
                "Intuition, insight, wisdom",
            ),
            (
                480.0,
                "Sahasrara",
                "Crown",
                "Violet",
                "Consciousness, unity, transcendence",
            ),
        ];

        let result: Vec<Value> = chakras
            .iter()
            .map(|(freq, sanskrit, english, color, meaning)| {
                let mut entry = std::collections::HashMap::new();
                entry.insert("frequency".to_string(), Value::Float(*freq));
                entry.insert(
                    "sanskrit".to_string(),
                    Value::String(Rc::new(sanskrit.to_string())),
                );
                entry.insert(
                    "english".to_string(),
                    Value::String(Rc::new(english.to_string())),
                );
                entry.insert(
                    "color".to_string(),
                    Value::String(Rc::new(color.to_string())),
                );
                entry.insert(
                    "meaning".to_string(),
                    Value::String(Rc::new(meaning.to_string())),
                );
                Value::Map(Rc::new(RefCell::new(entry)))
            })
            .collect();

        Ok(Value::Array(Rc::new(RefCell::new(result))))
    });

    // =========================================================================
    // WAVEFORM GENERATION
    // =========================================================================

    // Generate waveform samples - returns array of floats [-1.0, 1.0]

    // sine - pure sine wave ∿
    define(interp, "sine", Some(3), |_, args| {
        generate_waveform(&args, |phase| phase.sin())
    });

    // square - square wave ⊓
    define(interp, "square", Some(3), |_, args| {
        generate_waveform(&args, |phase| if phase.sin() >= 0.0 { 1.0 } else { -1.0 })
    });

    // sawtooth - sawtooth wave ⋀
    define(interp, "sawtooth", Some(3), |_, args| {
        generate_waveform(&args, |phase| {
            let normalized = (phase / std::f64::consts::TAU).fract();
            2.0 * normalized - 1.0
        })
    });

    // triangle - triangle wave △
    define(interp, "triangle", Some(3), |_, args| {
        generate_waveform(&args, |phase| {
            let normalized = (phase / std::f64::consts::TAU).fract();
            if normalized < 0.5 {
                4.0 * normalized - 1.0
            } else {
                3.0 - 4.0 * normalized
            }
        })
    });

    // noise - white noise
    define(interp, "noise", Some(1), |_, args| {
        let samples = match &args[0] {
            Value::Int(n) => *n as usize,
            _ => return Err(RuntimeError::new("noise() requires integer sample count")),
        };

        let mut rng = rand::thread_rng();
        let result: Vec<Value> = (0..samples)
            .map(|_| Value::Float(rng.gen::<f64>() * 2.0 - 1.0))
            .collect();

        Ok(Value::Array(Rc::new(RefCell::new(result))))
    });

    // =========================================================================
    // CULTURAL SCALES
    // =========================================================================

    // scale - get scale degrees for a cultural scale
    define(interp, "scale", Some(1), |_, args| {
        let name = match &args[0] {
            Value::String(s) => s.to_lowercase(),
            _ => return Err(RuntimeError::new("scale() requires string")),
        };

        let (intervals, origin, description) = match name.as_str() {
            // Western modes
            "major" | "ionian" => (
                vec![0, 2, 4, 5, 7, 9, 11],
                "Western",
                "Happy, bright, resolved",
            ),
            "minor" | "aeolian" => (
                vec![0, 2, 3, 5, 7, 8, 10],
                "Western",
                "Sad, dark, introspective",
            ),
            "dorian" => (
                vec![0, 2, 3, 5, 7, 9, 10],
                "Western/Jazz",
                "Minor with bright 6th",
            ),
            "phrygian" => (
                vec![0, 1, 3, 5, 7, 8, 10],
                "Western/Flamenco",
                "Spanish, exotic, tense",
            ),
            "lydian" => (
                vec![0, 2, 4, 6, 7, 9, 11],
                "Western",
                "Dreamy, floating, ethereal",
            ),
            "mixolydian" => (vec![0, 2, 4, 5, 7, 9, 10], "Western/Blues", "Bluesy major"),
            "locrian" => (vec![0, 1, 3, 5, 6, 8, 10], "Western", "Unstable, dissonant"),

            // Pentatonic
            "pentatonic_major" => (vec![0, 2, 4, 7, 9], "Universal", "No dissonance, universal"),
            "pentatonic_minor" => (vec![0, 3, 5, 7, 10], "Universal", "Blues foundation"),

            // Japanese
            "hirajoshi" => (vec![0, 2, 3, 7, 8], "Japanese", "Melancholic, mysterious"),
            "insen" => (vec![0, 1, 5, 7, 10], "Japanese", "Dark, zen, contemplative"),
            "iwato" => (vec![0, 1, 5, 6, 10], "Japanese", "Most dark and dissonant"),
            "kumoi" => (vec![0, 2, 3, 7, 9], "Japanese", "Gentle, peaceful"),
            "yo" => (vec![0, 2, 5, 7, 9], "Japanese", "Bright, folk, celebratory"),

            // Arabic maqamat
            "hijaz" => (
                vec![0, 1, 4, 5, 7, 8, 11],
                "Arabic",
                "Exotic, Middle Eastern",
            ),
            "bayati" => (
                vec![0, 1.5 as i32, 3, 5, 7, 8, 10],
                "Arabic",
                "Quarter-tone, soulful",
            ),
            "rast" => (
                vec![0, 2, 3.5 as i32, 5, 7, 9, 10.5 as i32],
                "Arabic",
                "Foundation maqam",
            ),
            "saba" => (
                vec![0, 1.5 as i32, 3, 4, 5, 8, 10],
                "Arabic",
                "Sad, spiritual",
            ),

            // Indian ragas (approximated to 12-TET)
            "bhairav" => (
                vec![0, 1, 4, 5, 7, 8, 11],
                "Indian",
                "Morning raga, devotional",
            ),
            "yaman" | "kalyan" => (vec![0, 2, 4, 6, 7, 9, 11], "Indian", "Evening, romantic"),
            "bhairavi" => (
                vec![0, 1, 3, 5, 7, 8, 10],
                "Indian",
                "Concluding raga, devotional",
            ),
            "todi" => (vec![0, 1, 3, 6, 7, 8, 11], "Indian", "Serious, pathos"),
            "marwa" => (vec![0, 1, 4, 6, 7, 9, 11], "Indian", "Evening, longing"),

            // Blues
            "blues" => (vec![0, 3, 5, 6, 7, 10], "American", "Blue notes, soul"),

            // Hungarian/Eastern European
            "hungarian_minor" => (vec![0, 2, 3, 6, 7, 8, 11], "Hungarian", "Gypsy, dramatic"),
            "romanian" => (vec![0, 2, 3, 6, 7, 9, 10], "Romanian", "Folk, energetic"),

            // Jewish
            "ahava_raba" | "freygish" => (
                vec![0, 1, 4, 5, 7, 8, 10],
                "Jewish/Klezmer",
                "Cantorial, emotional",
            ),
            "mi_sheberach" => (vec![0, 2, 3, 6, 7, 9, 10], "Jewish", "Prayer mode"),

            // Chinese
            "gong" => (vec![0, 2, 4, 7, 9], "Chinese", "Palace mode, major-like"),
            "shang" => (vec![0, 2, 5, 7, 9], "Chinese", "Merchant mode"),
            "jue" => (vec![0, 3, 5, 7, 10], "Chinese", "Angle mode"),
            "zhi" => (vec![0, 2, 5, 7, 10], "Chinese", "Emblem mode"),
            "yu" => (vec![0, 3, 5, 8, 10], "Chinese", "Wings mode, minor-like"),

            // Indonesian
            "pelog" => (
                vec![0, 1, 3, 7, 8],
                "Javanese",
                "7-note unequal temperament",
            ),
            "slendro" => (vec![0, 2, 5, 7, 9], "Javanese", "5-note roughly equal"),

            // Other
            "whole_tone" => (
                vec![0, 2, 4, 6, 8, 10],
                "Impressionist",
                "Dreamlike, no resolution",
            ),
            "chromatic" => (
                vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
                "Western",
                "All 12 notes",
            ),
            "diminished" => (vec![0, 2, 3, 5, 6, 8, 9, 11], "Jazz", "Symmetric, tense"),
            "augmented" => (vec![0, 3, 4, 7, 8, 11], "Jazz", "Symmetric, floating"),

            _ => return Err(RuntimeError::new(format!("Unknown scale: {}", name))),
        };

        let mut result = std::collections::HashMap::new();
        let intervals_values: Vec<Value> =
            intervals.iter().map(|&i| Value::Int(i as i64)).collect();
        result.insert(
            "intervals".to_string(),
            Value::Array(Rc::new(RefCell::new(intervals_values))),
        );
        result.insert(
            "origin".to_string(),
            Value::String(Rc::new(origin.to_string())),
        );
        result.insert(
            "character".to_string(),
            Value::String(Rc::new(description.to_string())),
        );
        result.insert("name".to_string(), Value::String(Rc::new(name)));

        Ok(Value::Map(Rc::new(RefCell::new(result))))
    });

    // list_scales - list all available scales grouped by culture
    define(interp, "list_scales", Some(0), |_, _| {
        let mut cultures = std::collections::HashMap::new();

        cultures.insert(
            "western".to_string(),
            Value::Array(Rc::new(RefCell::new(vec![
                Value::String(Rc::new("major".to_string())),
                Value::String(Rc::new("minor".to_string())),
                Value::String(Rc::new("dorian".to_string())),
                Value::String(Rc::new("phrygian".to_string())),
                Value::String(Rc::new("lydian".to_string())),
                Value::String(Rc::new("mixolydian".to_string())),
                Value::String(Rc::new("locrian".to_string())),
            ]))),
        );

        cultures.insert(
            "japanese".to_string(),
            Value::Array(Rc::new(RefCell::new(vec![
                Value::String(Rc::new("hirajoshi".to_string())),
                Value::String(Rc::new("insen".to_string())),
                Value::String(Rc::new("iwato".to_string())),
                Value::String(Rc::new("kumoi".to_string())),
                Value::String(Rc::new("yo".to_string())),
            ]))),
        );

        cultures.insert(
            "arabic".to_string(),
            Value::Array(Rc::new(RefCell::new(vec![
                Value::String(Rc::new("hijaz".to_string())),
                Value::String(Rc::new("bayati".to_string())),
                Value::String(Rc::new("rast".to_string())),
                Value::String(Rc::new("saba".to_string())),
            ]))),
        );

        cultures.insert(
            "indian".to_string(),
            Value::Array(Rc::new(RefCell::new(vec![
                Value::String(Rc::new("bhairav".to_string())),
                Value::String(Rc::new("yaman".to_string())),
                Value::String(Rc::new("bhairavi".to_string())),
                Value::String(Rc::new("todi".to_string())),
                Value::String(Rc::new("marwa".to_string())),
            ]))),
        );

        cultures.insert(
            "chinese".to_string(),
            Value::Array(Rc::new(RefCell::new(vec![
                Value::String(Rc::new("gong".to_string())),
                Value::String(Rc::new("shang".to_string())),
                Value::String(Rc::new("jue".to_string())),
                Value::String(Rc::new("zhi".to_string())),
                Value::String(Rc::new("yu".to_string())),
            ]))),
        );

        cultures.insert(
            "jewish".to_string(),
            Value::Array(Rc::new(RefCell::new(vec![
                Value::String(Rc::new("ahava_raba".to_string())),
                Value::String(Rc::new("mi_sheberach".to_string())),
            ]))),
        );

        cultures.insert(
            "indonesian".to_string(),
            Value::Array(Rc::new(RefCell::new(vec![
                Value::String(Rc::new("pelog".to_string())),
                Value::String(Rc::new("slendro".to_string())),
            ]))),
        );

        Ok(Value::Map(Rc::new(RefCell::new(cultures))))
    });

    // =========================================================================
    // INTERVALS AND HARMONY
    // =========================================================================

    // interval_ratio - get the frequency ratio for an interval
    define(interp, "interval_ratio", Some(2), |_, args| {
        let semitones = match &args[0] {
            Value::Int(n) => *n as f64,
            Value::Float(f) => *f,
            _ => return Err(RuntimeError::new("interval_ratio() requires number")),
        };

        let tuning = match &args[1] {
            Value::String(s) => s.to_lowercase(),
            _ => return Err(RuntimeError::new("interval_ratio() requires tuning system")),
        };

        let ratio = match tuning.as_str() {
            "12tet" | "equal" => 2.0_f64.powf(semitones / 12.0),
            "just" => just_intonation_ratio(semitones as i32),
            "pythagorean" => pythagorean_ratio(semitones as i32),
            _ => 2.0_f64.powf(semitones / 12.0),
        };

        Ok(Value::Float(ratio))
    });

    // cents_between - calculate cents between two frequencies
    define(interp, "cents_between", Some(2), |_, args| {
        let f1 = match &args[0] {
            Value::Float(f) => *f,
            Value::Int(i) => *i as f64,
            _ => return Err(RuntimeError::new("cents_between() requires numbers")),
        };
        let f2 = match &args[1] {
            Value::Float(f) => *f,
            Value::Int(i) => *i as f64,
            _ => return Err(RuntimeError::new("cents_between() requires numbers")),
        };

        let cents = 1200.0 * (f2 / f1).log2();
        Ok(Value::Float(cents))
    });

    // harmonic_series - generate harmonic series from fundamental
    define(interp, "harmonic_series", Some(2), |_, args| {
        let fundamental = match &args[0] {
            Value::Float(f) => *f,
            Value::Int(i) => *i as f64,
            _ => return Err(RuntimeError::new("harmonic_series() requires frequency")),
        };
        let count = match &args[1] {
            Value::Int(n) => *n as usize,
            _ => return Err(RuntimeError::new("harmonic_series() requires count")),
        };

        let harmonics: Vec<Value> = (1..=count)
            .map(|n| {
                let mut entry = std::collections::HashMap::new();
                entry.insert("harmonic".to_string(), Value::Int(n as i64));
                entry.insert(
                    "frequency".to_string(),
                    Value::Float(fundamental * n as f64),
                );
                entry.insert(
                    "cents_from_root".to_string(),
                    Value::Float(1200.0 * (n as f64).log2()),
                );
                Value::Map(Rc::new(RefCell::new(entry)))
            })
            .collect();

        Ok(Value::Array(Rc::new(RefCell::new(harmonics))))
    });

    // =========================================================================
    // AUDIO INFO
    // =========================================================================

    define(interp, "audio_info", Some(0), |_, _| {
        let mut info = std::collections::HashMap::new();

        info.insert(
            "tuning_systems".to_string(),
            Value::Array(Rc::new(RefCell::new(vec![
                Value::String(Rc::new(
                    "12tet, 24tet, just, pythagorean, meantone".to_string(),
                )),
                Value::String(Rc::new(
                    "53tet, 22shruti, pelog, slendro, bohlen_pierce".to_string(),
                )),
            ]))),
        );

        info.insert(
            "waveforms".to_string(),
            Value::Array(Rc::new(RefCell::new(vec![
                Value::String(Rc::new("sine (∿)".to_string())),
                Value::String(Rc::new("square (⊓)".to_string())),
                Value::String(Rc::new("sawtooth (⋀)".to_string())),
                Value::String(Rc::new("triangle (△)".to_string())),
                Value::String(Rc::new("noise".to_string())),
            ]))),
        );

        info.insert(
            "sacred_frequencies".to_string(),
            Value::Array(Rc::new(RefCell::new(vec![
                Value::String(Rc::new("om, solfeggio, chakras, planets".to_string())),
                Value::String(Rc::new(
                    "schumann, brainwaves (delta/theta/alpha/beta/gamma)".to_string(),
                )),
            ]))),
        );

        info.insert(
            "scale_cultures".to_string(),
            Value::Array(Rc::new(RefCell::new(vec![
                Value::String(Rc::new("western, japanese, arabic, indian".to_string())),
                Value::String(Rc::new("chinese, jewish, indonesian".to_string())),
            ]))),
        );

        Ok(Value::Map(Rc::new(RefCell::new(info))))
    });
}

// Helper functions for tuning systems

fn parse_note_name(s: &str) -> Result<f64, RuntimeError> {
    let s = s.trim().to_uppercase();
    let (note, octave_offset) = if s.ends_with(|c: char| c.is_ascii_digit()) {
        let octave: i32 = s.chars().last().unwrap().to_digit(10).unwrap() as i32;
        let note_part = &s[..s.len() - 1];
        (note_part, (octave - 4) * 12) // Octave 4 = MIDI 60 area
    } else {
        (&s[..], 0)
    };

    let semitone = match note {
        "C" => 0,
        "C#" | "DB" => 1,
        "D" => 2,
        "D#" | "EB" => 3,
        "E" => 4,
        "F" => 5,
        "F#" | "GB" => 6,
        "G" => 7,
        "G#" | "AB" => 8,
        "A" => 9,
        "A#" | "BB" => 10,
        "B" => 11,
        _ => return Err(RuntimeError::new(format!("Unknown note: {}", s))),
    };

    Ok(69.0 + semitone as f64 - 9.0 + octave_offset as f64) // A4 = 69
}

fn just_intonation_ratio(semitones: i32) -> f64 {
    // Classic 5-limit just intonation ratios
    match semitones.rem_euclid(12) {
        0 => 1.0,         // Unison
        1 => 16.0 / 15.0, // Minor second
        2 => 9.0 / 8.0,   // Major second
        3 => 6.0 / 5.0,   // Minor third
        4 => 5.0 / 4.0,   // Major third
        5 => 4.0 / 3.0,   // Perfect fourth
        6 => 45.0 / 32.0, // Tritone
        7 => 3.0 / 2.0,   // Perfect fifth
        8 => 8.0 / 5.0,   // Minor sixth
        9 => 5.0 / 3.0,   // Major sixth
        10 => 9.0 / 5.0,  // Minor seventh
        11 => 15.0 / 8.0, // Major seventh
        _ => 1.0,
    }
}

fn pythagorean_ratio(semitones: i32) -> f64 {
    // Pythagorean tuning (pure fifths, 3:2 ratio)
    match semitones.rem_euclid(12) {
        0 => 1.0,
        1 => 256.0 / 243.0,
        2 => 9.0 / 8.0,
        3 => 32.0 / 27.0,
        4 => 81.0 / 64.0,
        5 => 4.0 / 3.0,
        6 => 729.0 / 512.0,
        7 => 3.0 / 2.0,
        8 => 128.0 / 81.0,
        9 => 27.0 / 16.0,
        10 => 16.0 / 9.0,
        11 => 243.0 / 128.0,
        _ => 1.0,
    }
}

fn meantone_ratio(semitones: i32) -> f64 {
    // Quarter-comma meantone - fifths narrowed by 1/4 syntonic comma
    let fifth = 5.0_f64.powf(0.25); // Pure major third, tempered fifth
    match semitones.rem_euclid(12) {
        0 => 1.0,
        1 => 8.0 / (fifth.powi(5)),
        2 => fifth.powi(2) / 2.0,
        3 => 4.0 / (fifth.powi(3)),
        4 => fifth.powi(4) / 4.0,
        5 => 2.0 / fifth,
        6 => fifth.powi(6) / 8.0,
        7 => fifth,
        8 => 8.0 / (fifth.powi(4)),
        9 => fifth.powi(3) / 2.0,
        10 => 4.0 / (fifth.powi(2)),
        11 => fifth.powi(5) / 4.0,
        _ => 1.0,
    }
}

fn shruti_ratio(shruti: i32) -> f64 {
    // 22 shruti ratios (traditional Indian)
    let ratios = [
        1.0,
        256.0 / 243.0,
        16.0 / 15.0,
        10.0 / 9.0,
        9.0 / 8.0,
        32.0 / 27.0,
        6.0 / 5.0,
        5.0 / 4.0,
        81.0 / 64.0,
        4.0 / 3.0,
        27.0 / 20.0,
        45.0 / 32.0,
        729.0 / 512.0,
        3.0 / 2.0,
        128.0 / 81.0,
        8.0 / 5.0,
        5.0 / 3.0,
        27.0 / 16.0,
        16.0 / 9.0,
        9.0 / 5.0,
        15.0 / 8.0,
        243.0 / 128.0,
    ];
    ratios[shruti.rem_euclid(22) as usize]
}

fn pelog_ratio(degree: i32) -> f64 {
    // Approximate pelog ratios (varies by gamelan)
    let ratios = [1.0, 1.12, 1.26, 1.5, 1.68, 1.89, 2.12];
    ratios[degree.rem_euclid(7) as usize]
}

fn slendro_ratio(degree: i32) -> f64 {
    // Approximate slendro ratios (roughly equal ~240 cents)
    let ratios = [1.0, 1.148, 1.318, 1.516, 1.741];
    ratios[degree.rem_euclid(5) as usize]
}

fn generate_waveform(args: &[Value], wave_fn: fn(f64) -> f64) -> Result<Value, RuntimeError> {
    let freq = match &args[0] {
        Value::Float(f) => *f,
        Value::Int(i) => *i as f64,
        _ => return Err(RuntimeError::new("Waveform requires frequency")),
    };
    let sample_rate = match &args[1] {
        Value::Float(f) => *f as usize,
        Value::Int(i) => *i as usize,
        _ => return Err(RuntimeError::new("Waveform requires sample rate")),
    };
    let duration = match &args[2] {
        Value::Float(f) => *f,
        Value::Int(i) => *i as f64,
        _ => return Err(RuntimeError::new("Waveform requires duration")),
    };

    let num_samples = (sample_rate as f64 * duration) as usize;
    let samples: Vec<Value> = (0..num_samples)
        .map(|i| {
            let t = i as f64 / sample_rate as f64;
            let phase = 2.0 * std::f64::consts::PI * freq * t;
            Value::Float(wave_fn(phase))
        })
        .collect();

    Ok(Value::Array(Rc::new(RefCell::new(samples))))
}

// ============================================================================
// SPIRITUALITY: Divination, sacred geometry, gematria, archetypes
// ============================================================================
//
// This module treats computation as potentially sacred - numbers have meaning,
// patterns have significance, and randomness can be oracle.
//
// I Ching Trigrams:
//   ☰ Heaven (乾)  ☱ Lake (兌)   ☲ Fire (離)   ☳ Thunder (震)
//   ☴ Wind (巽)    ☵ Water (坎)  ☶ Mountain (艮) ☷ Earth (坤)
//
// Sacred Geometry:
//   φ = 1.618033... (Golden Ratio)
//   √φ, φ², 1/φ (related constants)
//   Fibonacci sequence
//   Platonic solid relationships
//
// Gematria Systems:
//   Hebrew (Kabbalah), Greek (Isopsephy), Arabic (Abjad)
//   Each letter is a number; words have numerical souls

fn register_spirituality(interp: &mut Interpreter) {
    // =========================================================================
    // I CHING - Book of Changes
    // =========================================================================

    // The 8 trigrams
    const TRIGRAMS: [(&str, &str, &str, &str, &str); 8] = [
        (
            "☰",
            "乾",
            "Heaven",
            "Creative",
            "strong, initiating, persisting",
        ),
        (
            "☱",
            "兌",
            "Lake",
            "Joyous",
            "pleasure, satisfaction, openness",
        ),
        (
            "☲",
            "離",
            "Fire",
            "Clinging",
            "clarity, awareness, dependence",
        ),
        (
            "☳",
            "震",
            "Thunder",
            "Arousing",
            "movement, initiative, action",
        ),
        (
            "☴",
            "巽",
            "Wind",
            "Gentle",
            "penetrating, following, flexible",
        ),
        ("☵", "坎", "Water", "Abysmal", "danger, flowing, depth"),
        (
            "☶",
            "艮",
            "Mountain",
            "Keeping Still",
            "stopping, resting, meditation",
        ),
        (
            "☷",
            "坤",
            "Earth",
            "Receptive",
            "yielding, nurturing, devoted",
        ),
    ];

    // trigram - get trigram information
    define(interp, "trigram", Some(1), |_, args| {
        let input = match &args[0] {
            Value::Int(n) => (*n as usize).min(7),
            Value::String(s) => match s.as_str() {
                "☰" | "heaven" | "qian" | "乾" => 0,
                "☱" | "lake" | "dui" | "兌" => 1,
                "☲" | "fire" | "li" | "離" => 2,
                "☳" | "thunder" | "zhen" | "震" => 3,
                "☴" | "wind" | "xun" | "巽" => 4,
                "☵" | "water" | "kan" | "坎" => 5,
                "☶" | "mountain" | "gen" | "艮" => 6,
                "☷" | "earth" | "kun" | "坤" => 7,
                _ => return Err(RuntimeError::new(format!("Unknown trigram: {}", s))),
            },
            _ => return Err(RuntimeError::new("trigram() requires number or name")),
        };

        let (symbol, chinese, english, name, meaning) = TRIGRAMS[input];

        let mut result = std::collections::HashMap::new();
        result.insert("number".to_string(), Value::Int(input as i64));
        result.insert(
            "symbol".to_string(),
            Value::String(Rc::new(symbol.to_string())),
        );
        result.insert(
            "chinese".to_string(),
            Value::String(Rc::new(chinese.to_string())),
        );
        result.insert(
            "english".to_string(),
            Value::String(Rc::new(english.to_string())),
        );
        result.insert("name".to_string(), Value::String(Rc::new(name.to_string())));
        result.insert(
            "meaning".to_string(),
            Value::String(Rc::new(meaning.to_string())),
        );

        // Binary representation (yang=1, yin=0)
        let binary = match input {
            0 => "111", // ☰
            1 => "110", // ☱
            2 => "101", // ☲
            3 => "100", // ☳
            4 => "011", // ☴
            5 => "010", // ☵
            6 => "001", // ☶
            7 => "000", // ☷
            _ => "000",
        };
        result.insert(
            "binary".to_string(),
            Value::String(Rc::new(binary.to_string())),
        );

        Ok(Value::Map(Rc::new(RefCell::new(result))))
    });

    // hexagram - get one of 64 I Ching hexagrams
    define(interp, "hexagram", Some(1), |_, args| {
        let num = match &args[0] {
            Value::Int(n) => ((*n - 1) as usize).min(63),
            _ => return Err(RuntimeError::new("hexagram() requires number 1-64")),
        };

        let hex = &HEXAGRAMS[num];

        let mut result = std::collections::HashMap::new();
        result.insert("number".to_string(), Value::Int((num + 1) as i64));
        result.insert(
            "chinese".to_string(),
            Value::String(Rc::new(hex.0.to_string())),
        );
        result.insert(
            "pinyin".to_string(),
            Value::String(Rc::new(hex.1.to_string())),
        );
        result.insert(
            "english".to_string(),
            Value::String(Rc::new(hex.2.to_string())),
        );
        result.insert(
            "judgment".to_string(),
            Value::String(Rc::new(hex.3.to_string())),
        );
        result.insert(
            "upper_trigram".to_string(),
            Value::String(Rc::new(hex.4.to_string())),
        );
        result.insert(
            "lower_trigram".to_string(),
            Value::String(Rc::new(hex.5.to_string())),
        );

        Ok(Value::Map(Rc::new(RefCell::new(result))))
    });

    // cast_iching - divine using I Ching (uses randomness as oracle)
    define(interp, "cast_iching", Some(0), |_, _| {
        let mut rng = rand::thread_rng();

        // Traditional yarrow stalk method produces numbers 6,7,8,9
        // 6 = old yin (changing), 7 = young yang, 8 = young yin, 9 = old yang (changing)
        let mut lines = Vec::new();
        let mut hexagram_num = 0u8;
        let mut changing_lines = Vec::new();

        for i in 0..6 {
            // Simulate yarrow stalk probabilities
            let r: f64 = rng.gen();
            let line = if r < 0.0625 {
                6
            }
            // 1/16 - old yin
            else if r < 0.3125 {
                7
            }
            // 5/16 - young yang
            else if r < 0.5625 {
                8
            }
            // 5/16 - young yin
            else {
                9
            }; // 5/16 - old yang

            let is_yang = line == 7 || line == 9;
            if is_yang {
                hexagram_num |= 1 << i;
            }

            if line == 6 || line == 9 {
                changing_lines.push(i + 1);
            }

            lines.push(Value::Int(line));
        }

        // Convert to King Wen sequence
        let king_wen_num = binary_to_king_wen(hexagram_num) + 1;
        let hex = &HEXAGRAMS[(king_wen_num - 1) as usize];

        let mut result = std::collections::HashMap::new();
        result.insert("hexagram".to_string(), Value::Int(king_wen_num as i64));
        result.insert(
            "chinese".to_string(),
            Value::String(Rc::new(hex.0.to_string())),
        );
        result.insert(
            "english".to_string(),
            Value::String(Rc::new(hex.2.to_string())),
        );
        result.insert(
            "judgment".to_string(),
            Value::String(Rc::new(hex.3.to_string())),
        );
        result.insert(
            "lines".to_string(),
            Value::Array(Rc::new(RefCell::new(lines))),
        );

        let changing: Vec<Value> = changing_lines.iter().map(|&n| Value::Int(n)).collect();
        result.insert(
            "changing_lines".to_string(),
            Value::Array(Rc::new(RefCell::new(changing))),
        );

        // Calculate resulting hexagram if there are changing lines
        if !changing_lines.is_empty() {
            let mut result_hex = hexagram_num;
            for &line in &changing_lines {
                result_hex ^= 1 << (line - 1); // Flip the changing lines
            }
            let result_king_wen = binary_to_king_wen(result_hex) + 1;
            result.insert(
                "transforms_to".to_string(),
                Value::Int(result_king_wen as i64),
            );
        }

        Ok(Value::Map(Rc::new(RefCell::new(result))))
    });

    // =========================================================================
    // SACRED GEOMETRY
    // =========================================================================

    // phi - Golden Ratio
    define(interp, "phi", Some(0), |_, _| {
        Ok(Value::Float((1.0 + 5.0_f64.sqrt()) / 2.0))
    });

    // sacred_ratio - get various sacred ratios
    define(interp, "sacred_ratio", Some(1), |_, args| {
        let name = match &args[0] {
            Value::String(s) => s.to_lowercase(),
            _ => return Err(RuntimeError::new("sacred_ratio() requires string")),
        };

        let (value, symbol, meaning) = match name.as_str() {
            "phi" | "φ" | "golden" => (
                (1.0 + 5.0_f64.sqrt()) / 2.0,
                "φ",
                "Golden Ratio - divine proportion found in nature, art, architecture",
            ),
            "phi_conjugate" | "1/phi" => (
                2.0 / (1.0 + 5.0_f64.sqrt()),
                "1/φ",
                "Golden Ratio conjugate - φ - 1 = 1/φ",
            ),
            "phi_squared" | "phi2" => (
                ((1.0 + 5.0_f64.sqrt()) / 2.0).powi(2),
                "φ²",
                "Golden Ratio squared - φ + 1 = φ²",
            ),
            "sqrt_phi" => (
                ((1.0 + 5.0_f64.sqrt()) / 2.0).sqrt(),
                "√φ",
                "Square root of Golden Ratio",
            ),
            "pi" | "π" => (
                std::f64::consts::PI,
                "π",
                "Circle constant - circumference/diameter, transcendental",
            ),
            "tau" | "τ" => (
                std::f64::consts::TAU,
                "τ",
                "Full circle constant - 2π, one complete revolution",
            ),
            "e" | "euler" => (
                std::f64::consts::E,
                "e",
                "Euler's number - natural growth, compound interest",
            ),
            "sqrt2" | "√2" | "pythagoras" => (
                std::f64::consts::SQRT_2,
                "√2",
                "Pythagorean constant - diagonal of unit square",
            ),
            "sqrt3" | "√3" | "vesica" => (
                3.0_f64.sqrt(),
                "√3",
                "Vesica Piscis ratio - sacred geometry foundation",
            ),
            "sqrt5" | "√5" => (
                5.0_f64.sqrt(),
                "√5",
                "Related to Golden Ratio: φ = (1 + √5) / 2",
            ),
            "silver" | "δs" => (
                1.0 + 2.0_f64.sqrt(),
                "δs",
                "Silver Ratio - related to octagon",
            ),
            "plastic" | "ρ" => (
                1.324717957244746,
                "ρ",
                "Plastic Number - smallest Pisot number",
            ),
            "feigenbaum" | "δ" => (
                4.669201609102990,
                "δ",
                "Feigenbaum constant - chaos theory, period doubling",
            ),
            _ => return Err(RuntimeError::new(format!("Unknown sacred ratio: {}", name))),
        };

        let mut result = std::collections::HashMap::new();
        result.insert("value".to_string(), Value::Float(value));
        result.insert(
            "symbol".to_string(),
            Value::String(Rc::new(symbol.to_string())),
        );
        result.insert(
            "meaning".to_string(),
            Value::String(Rc::new(meaning.to_string())),
        );

        Ok(Value::Map(Rc::new(RefCell::new(result))))
    });

    // fibonacci - generate Fibonacci sequence
    define(interp, "fibonacci", Some(1), |_, args| {
        let count = match &args[0] {
            Value::Int(n) => *n as usize,
            _ => return Err(RuntimeError::new("fibonacci() requires count")),
        };

        let mut seq = Vec::with_capacity(count);
        let (mut a, mut b) = (0i64, 1i64);

        for _ in 0..count {
            seq.push(Value::Int(a));
            let next = a.saturating_add(b);
            a = b;
            b = next;
        }

        Ok(Value::Array(Rc::new(RefCell::new(seq))))
    });

    // is_fibonacci - check if a number is in the Fibonacci sequence
    define(interp, "is_fibonacci", Some(1), |_, args| {
        let n = match &args[0] {
            Value::Int(n) => *n,
            _ => return Err(RuntimeError::new("is_fibonacci() requires integer")),
        };

        // A number is Fibonacci iff one of (5n² + 4) or (5n² - 4) is a perfect square
        fn is_perfect_square(n: i64) -> bool {
            if n < 0 {
                return false;
            }
            let root = (n as f64).sqrt() as i64;
            root * root == n
        }

        let n_sq = n.saturating_mul(n);
        let test1 = 5i64.saturating_mul(n_sq).saturating_add(4);
        let test2 = 5i64.saturating_mul(n_sq).saturating_sub(4);

        Ok(Value::Bool(
            is_perfect_square(test1) || is_perfect_square(test2),
        ))
    });

    // platonic_solid - get information about Platonic solids
    define(interp, "platonic_solid", Some(1), |_, args| {
        let name = match &args[0] {
            Value::String(s) => s.to_lowercase(),
            _ => return Err(RuntimeError::new("platonic_solid() requires string")),
        };

        let (faces, vertices, edges, face_shape, element, meaning) = match name.as_str() {
            "tetrahedron" | "fire" => (
                4,
                4,
                6,
                "triangle",
                "Fire",
                "Sharpness, heat, transformation",
            ),
            "cube" | "hexahedron" | "earth" => (
                6,
                8,
                12,
                "square",
                "Earth",
                "Stability, grounding, material",
            ),
            "octahedron" | "air" => (
                8,
                6,
                12,
                "triangle",
                "Air",
                "Balance, intellect, communication",
            ),
            "dodecahedron" | "aether" | "spirit" => (
                12,
                20,
                30,
                "pentagon",
                "Aether/Spirit",
                "The cosmos, divine thought",
            ),
            "icosahedron" | "water" => (
                20,
                12,
                30,
                "triangle",
                "Water",
                "Flow, emotion, adaptability",
            ),
            _ => {
                return Err(RuntimeError::new(format!(
                    "Unknown Platonic solid: {}",
                    name
                )))
            }
        };

        let mut result = std::collections::HashMap::new();
        result.insert("name".to_string(), Value::String(Rc::new(name)));
        result.insert("faces".to_string(), Value::Int(faces));
        result.insert("vertices".to_string(), Value::Int(vertices));
        result.insert("edges".to_string(), Value::Int(edges));
        result.insert(
            "face_shape".to_string(),
            Value::String(Rc::new(face_shape.to_string())),
        );
        result.insert(
            "element".to_string(),
            Value::String(Rc::new(element.to_string())),
        );
        result.insert(
            "meaning".to_string(),
            Value::String(Rc::new(meaning.to_string())),
        );

        // Euler's formula: V - E + F = 2
        result.insert("euler_characteristic".to_string(), Value::Int(2));

        Ok(Value::Map(Rc::new(RefCell::new(result))))
    });

    // =========================================================================
    // GEMATRIA - Letter-Number Correspondences
    // =========================================================================

    // gematria - calculate numerical value of text
    define(interp, "gematria", Some(2), |_, args| {
        let text = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("gematria() requires string")),
        };

        let system = match &args[1] {
            Value::String(s) => s.to_lowercase(),
            _ => return Err(RuntimeError::new("gematria() requires system name")),
        };

        let total: i64 = match system.as_str() {
            "hebrew" | "kabbalah" => text.chars().map(|c| hebrew_gematria(c)).sum(),
            "greek" | "isopsephy" => text.chars().map(|c| greek_isopsephy(c)).sum(),
            "arabic" | "abjad" => text.chars().map(|c| arabic_abjad(c)).sum(),
            "english" | "simple" => {
                // Simple English: A=1, B=2, ... Z=26
                text.to_uppercase()
                    .chars()
                    .filter_map(|c| {
                        if c.is_ascii_alphabetic() {
                            Some((c as i64) - ('A' as i64) + 1)
                        } else {
                            None
                        }
                    })
                    .sum()
            }
            "english_ordinal" => {
                // Same as simple
                text.to_uppercase()
                    .chars()
                    .filter_map(|c| {
                        if c.is_ascii_alphabetic() {
                            Some((c as i64) - ('A' as i64) + 1)
                        } else {
                            None
                        }
                    })
                    .sum()
            }
            "english_reduction" => {
                // Reduce each letter: A=1, B=2, ... I=9, J=1, K=2, etc.
                text.to_uppercase()
                    .chars()
                    .filter_map(|c| {
                        if c.is_ascii_alphabetic() {
                            let val = ((c as i64) - ('A' as i64)) % 9 + 1;
                            Some(val)
                        } else {
                            None
                        }
                    })
                    .sum()
            }
            _ => {
                return Err(RuntimeError::new(format!(
                    "Unknown gematria system: {}",
                    system
                )))
            }
        };

        let mut result = std::collections::HashMap::new();
        result.insert("text".to_string(), Value::String(Rc::new(text)));
        result.insert("system".to_string(), Value::String(Rc::new(system)));
        result.insert("value".to_string(), Value::Int(total));

        // Digital root (reduce to single digit)
        let mut digital_root = total;
        while digital_root > 9 {
            digital_root = digital_root
                .to_string()
                .chars()
                .filter_map(|c| c.to_digit(10))
                .map(|d| d as i64)
                .sum();
        }
        result.insert("digital_root".to_string(), Value::Int(digital_root));

        Ok(Value::Map(Rc::new(RefCell::new(result))))
    });

    // gematria_match - find words with same gematria value
    define(interp, "gematria_match", Some(2), |_, args| {
        let value = match &args[0] {
            Value::Int(n) => *n,
            _ => return Err(RuntimeError::new("gematria_match() requires integer value")),
        };

        let system = match &args[1] {
            Value::String(s) => s.to_lowercase(),
            _ => return Err(RuntimeError::new("gematria_match() requires system name")),
        };

        // Return known significant matches for common values
        let matches = match (value, system.as_str()) {
            (26, "hebrew") => vec!["יהוה (YHWH - Tetragrammaton)"],
            (18, "hebrew") => vec!["חי (Chai - Life)"],
            (86, "hebrew") => vec!["אלהים (Elohim - God)"],
            (72, "hebrew") => vec!["חסד (Chesed - Loving-kindness)"],
            (93, "english") => vec!["Love", "Will", "Thelema"],
            (666, "greek") => vec!["Nero Caesar (in Hebrew letters)"],
            (888, "greek") => vec!["Ἰησοῦς (Jesus)"],
            _ => vec![],
        };

        let match_values: Vec<Value> = matches
            .iter()
            .map(|s| Value::String(Rc::new(s.to_string())))
            .collect();

        Ok(Value::Array(Rc::new(RefCell::new(match_values))))
    });

    // =========================================================================
    // ARCHETYPES (Jung)
    // =========================================================================

    // archetype - get information about Jungian archetypes
    define(interp, "archetype", Some(1), |_, args| {
        let name = match &args[0] {
            Value::String(s) => s.to_lowercase(),
            _ => return Err(RuntimeError::new("archetype() requires string")),
        };

        let (description, shadow, gift, challenge) = match name.as_str() {
            // Core archetypes
            "self" => (
                "The unified conscious and unconscious, the goal of individuation",
                "Inflation or deflation of ego",
                "Wholeness, integration, meaning",
                "Integrating all aspects of psyche",
            ),
            "shadow" => (
                "The unconscious aspect containing repressed weaknesses and instincts",
                "Projection onto others, denial",
                "Creativity, spontaneity, insight",
                "Acknowledging and integrating darkness",
            ),
            "anima" => (
                "The feminine inner personality in a man's unconscious",
                "Moodiness, seduction, possession",
                "Relatedness, creativity, soul connection",
                "Developing emotional intelligence",
            ),
            "animus" => (
                "The masculine inner personality in a woman's unconscious",
                "Brutality, reckless action, opinionation",
                "Courage, initiative, spiritual depth",
                "Developing assertiveness with wisdom",
            ),
            "persona" => (
                "The social mask, the face we present to the world",
                "Over-identification, inauthenticity",
                "Social adaptation, professional competence",
                "Maintaining authenticity within role",
            ),

            // Major archetypes
            "hero" => (
                "The courageous one who overcomes obstacles and achieves great deeds",
                "Arrogance, ruthlessness, eternal battle",
                "Courage, perseverance, accomplishment",
                "Knowing when to fight and when to surrender",
            ),
            "sage" | "wise_old_man" => (
                "The wise figure who offers guidance and insight",
                "Dogmatism, disconnection, ivory tower",
                "Wisdom, knowledge, truth-seeking",
                "Applying wisdom practically",
            ),
            "magician" | "wizard" => (
                "The transformer who makes things happen through understanding laws",
                "Manipulation, disconnection from ethics",
                "Transformation, vision, manifestation",
                "Using power responsibly",
            ),
            "lover" => (
                "The one who pursues connection, beauty, and passion",
                "Obsession, jealousy, loss of identity",
                "Passion, commitment, appreciation",
                "Maintaining boundaries while connecting deeply",
            ),
            "caregiver" | "mother" => (
                "The nurturing one who protects and provides",
                "Martyrdom, enabling, smothering",
                "Compassion, generosity, nurturing",
                "Caring for self while caring for others",
            ),
            "ruler" | "king" | "queen" => (
                "The one who takes responsibility for the realm",
                "Tyranny, authoritarianism, being overthrown",
                "Order, leadership, prosperity",
                "Serving the greater good, not just power",
            ),
            "creator" | "artist" => (
                "The one who brings new things into being",
                "Perfectionism, self-indulgence, drama",
                "Creativity, imagination, expression",
                "Completing projects, accepting imperfection",
            ),
            "innocent" | "child" => (
                "The pure one with faith and optimism",
                "Naivety, denial, dependence",
                "Faith, optimism, loyalty",
                "Growing without becoming cynical",
            ),
            "explorer" | "seeker" => (
                "The one who seeks new experiences and self-discovery",
                "Aimless wandering, inability to commit",
                "Autonomy, ambition, authenticity",
                "Finding what you seek",
            ),
            "rebel" | "outlaw" => (
                "The one who breaks rules and challenges the status quo",
                "Crime, self-destruction, alienation",
                "Liberation, revolution, radical freedom",
                "Channeling rebellion constructively",
            ),
            "jester" | "fool" | "trickster" => (
                "The one who uses humor and playfulness",
                "Cruelty, debauchery, irresponsibility",
                "Joy, freedom, living in the moment",
                "Knowing when to be serious",
            ),
            "everyman" | "orphan" => (
                "The regular person who wants belonging",
                "Victim mentality, losing self in group",
                "Realism, empathy, connection",
                "Standing out when necessary",
            ),
            _ => return Err(RuntimeError::new(format!("Unknown archetype: {}", name))),
        };

        let mut result = std::collections::HashMap::new();
        result.insert("name".to_string(), Value::String(Rc::new(name)));
        result.insert(
            "description".to_string(),
            Value::String(Rc::new(description.to_string())),
        );
        result.insert(
            "shadow".to_string(),
            Value::String(Rc::new(shadow.to_string())),
        );
        result.insert("gift".to_string(), Value::String(Rc::new(gift.to_string())));
        result.insert(
            "challenge".to_string(),
            Value::String(Rc::new(challenge.to_string())),
        );

        Ok(Value::Map(Rc::new(RefCell::new(result))))
    });

    // =========================================================================
    // ASTROLOGY
    // =========================================================================

    // zodiac - get zodiac sign information
    define(interp, "zodiac", Some(1), |_, args| {
        let input = match &args[0] {
            Value::Int(n) => (*n as usize - 1).min(11),
            Value::String(s) => match s.to_lowercase().as_str() {
                "aries" | "♈" => 0,
                "taurus" | "♉" => 1,
                "gemini" | "♊" => 2,
                "cancer" | "♋" => 3,
                "leo" | "♌" => 4,
                "virgo" | "♍" => 5,
                "libra" | "♎" => 6,
                "scorpio" | "♏" => 7,
                "sagittarius" | "♐" => 8,
                "capricorn" | "♑" => 9,
                "aquarius" | "♒" => 10,
                "pisces" | "♓" => 11,
                _ => return Err(RuntimeError::new(format!("Unknown sign: {}", s))),
            },
            _ => return Err(RuntimeError::new("zodiac() requires number or name")),
        };

        let signs = [
            (
                "♈",
                "Aries",
                "Fire",
                "Cardinal",
                "Mars",
                "I Am",
                "Mar 21 - Apr 19",
            ),
            (
                "♉",
                "Taurus",
                "Earth",
                "Fixed",
                "Venus",
                "I Have",
                "Apr 20 - May 20",
            ),
            (
                "♊",
                "Gemini",
                "Air",
                "Mutable",
                "Mercury",
                "I Think",
                "May 21 - Jun 20",
            ),
            (
                "♋",
                "Cancer",
                "Water",
                "Cardinal",
                "Moon",
                "I Feel",
                "Jun 21 - Jul 22",
            ),
            (
                "♌",
                "Leo",
                "Fire",
                "Fixed",
                "Sun",
                "I Will",
                "Jul 23 - Aug 22",
            ),
            (
                "♍",
                "Virgo",
                "Earth",
                "Mutable",
                "Mercury",
                "I Analyze",
                "Aug 23 - Sep 22",
            ),
            (
                "♎",
                "Libra",
                "Air",
                "Cardinal",
                "Venus",
                "I Balance",
                "Sep 23 - Oct 22",
            ),
            (
                "♏",
                "Scorpio",
                "Water",
                "Fixed",
                "Pluto/Mars",
                "I Transform",
                "Oct 23 - Nov 21",
            ),
            (
                "♐",
                "Sagittarius",
                "Fire",
                "Mutable",
                "Jupiter",
                "I Seek",
                "Nov 22 - Dec 21",
            ),
            (
                "♑",
                "Capricorn",
                "Earth",
                "Cardinal",
                "Saturn",
                "I Use",
                "Dec 22 - Jan 19",
            ),
            (
                "♒",
                "Aquarius",
                "Air",
                "Fixed",
                "Uranus/Saturn",
                "I Know",
                "Jan 20 - Feb 18",
            ),
            (
                "♓",
                "Pisces",
                "Water",
                "Mutable",
                "Neptune/Jupiter",
                "I Believe",
                "Feb 19 - Mar 20",
            ),
        ];

        let (symbol, name, element, modality, ruler, motto, dates) = signs[input];

        let mut result = std::collections::HashMap::new();
        result.insert("number".to_string(), Value::Int((input + 1) as i64));
        result.insert(
            "symbol".to_string(),
            Value::String(Rc::new(symbol.to_string())),
        );
        result.insert("name".to_string(), Value::String(Rc::new(name.to_string())));
        result.insert(
            "element".to_string(),
            Value::String(Rc::new(element.to_string())),
        );
        result.insert(
            "modality".to_string(),
            Value::String(Rc::new(modality.to_string())),
        );
        result.insert(
            "ruler".to_string(),
            Value::String(Rc::new(ruler.to_string())),
        );
        result.insert(
            "motto".to_string(),
            Value::String(Rc::new(motto.to_string())),
        );
        result.insert(
            "dates".to_string(),
            Value::String(Rc::new(dates.to_string())),
        );

        Ok(Value::Map(Rc::new(RefCell::new(result))))
    });

    // tarot_major - Major Arcana information
    define(interp, "tarot_major", Some(1), |_, args| {
        let num = match &args[0] {
            Value::Int(n) => (*n as usize).min(21),
            Value::String(s) => match s.to_lowercase().as_str() {
                "fool" => 0,
                "magician" => 1,
                "high_priestess" | "priestess" => 2,
                "empress" => 3,
                "emperor" => 4,
                "hierophant" | "pope" => 5,
                "lovers" => 6,
                "chariot" => 7,
                "strength" => 8,
                "hermit" => 9,
                "wheel" | "fortune" => 10,
                "justice" => 11,
                "hanged_man" | "hanged" => 12,
                "death" => 13,
                "temperance" => 14,
                "devil" => 15,
                "tower" => 16,
                "star" => 17,
                "moon" => 18,
                "sun" => 19,
                "judgement" | "judgment" => 20,
                "world" => 21,
                _ => return Err(RuntimeError::new(format!("Unknown card: {}", s))),
            },
            _ => return Err(RuntimeError::new("tarot_major() requires number or name")),
        };

        let cards = [
            (
                "The Fool",
                "New beginnings, innocence, spontaneity",
                "Naivety, recklessness, risk-taking",
            ),
            (
                "The Magician",
                "Willpower, creation, manifestation",
                "Manipulation, trickery, unused talent",
            ),
            (
                "The High Priestess",
                "Intuition, mystery, inner knowledge",
                "Secrets, withdrawal, silence",
            ),
            (
                "The Empress",
                "Abundance, nurturing, fertility",
                "Dependence, smothering, emptiness",
            ),
            (
                "The Emperor",
                "Authority, structure, control",
                "Tyranny, rigidity, coldness",
            ),
            (
                "The Hierophant",
                "Tradition, conformity, spirituality",
                "Dogma, restriction, challenging status quo",
            ),
            (
                "The Lovers",
                "Love, harmony, relationships, choices",
                "Disharmony, imbalance, misalignment",
            ),
            (
                "The Chariot",
                "Direction, willpower, victory",
                "Aggression, lack of direction, obstacles",
            ),
            (
                "Strength",
                "Courage, patience, inner power",
                "Self-doubt, weakness, insecurity",
            ),
            (
                "The Hermit",
                "Contemplation, search for truth, inner guidance",
                "Isolation, loneliness, withdrawal",
            ),
            (
                "Wheel of Fortune",
                "Change, cycles, fate, destiny",
                "Resistance to change, bad luck, setbacks",
            ),
            (
                "Justice",
                "Truth, fairness, law, cause and effect",
                "Unfairness, dishonesty, lack of accountability",
            ),
            (
                "The Hanged Man",
                "Surrender, letting go, new perspective",
                "Stalling, resistance, indecision",
            ),
            (
                "Death",
                "Endings, transformation, transition",
                "Fear of change, stagnation, decay",
            ),
            (
                "Temperance",
                "Balance, moderation, patience",
                "Imbalance, excess, lack of purpose",
            ),
            (
                "The Devil",
                "Bondage, materialism, shadow self",
                "Freedom, release, exploring dark side",
            ),
            (
                "The Tower",
                "Sudden change, upheaval, revelation",
                "Disaster averted, fear of change, prolonged pain",
            ),
            (
                "The Star",
                "Hope, faith, renewal, inspiration",
                "Despair, disconnection, lack of faith",
            ),
            (
                "The Moon",
                "Illusion, intuition, the unconscious",
                "Fear, confusion, misinterpretation",
            ),
            (
                "The Sun",
                "Joy, success, vitality, positivity",
                "Negativity, depression, sadness",
            ),
            (
                "Judgement",
                "Rebirth, inner calling, absolution",
                "Self-doubt, refusal of self-examination",
            ),
            (
                "The World",
                "Completion, accomplishment, wholeness",
                "Incompletion, lack of closure, emptiness",
            ),
        ];

        let (name, upright, reversed) = cards[num];

        let mut result = std::collections::HashMap::new();
        result.insert("number".to_string(), Value::Int(num as i64));
        result.insert("name".to_string(), Value::String(Rc::new(name.to_string())));
        result.insert(
            "upright".to_string(),
            Value::String(Rc::new(upright.to_string())),
        );
        result.insert(
            "reversed".to_string(),
            Value::String(Rc::new(reversed.to_string())),
        );

        Ok(Value::Map(Rc::new(RefCell::new(result))))
    });

    // draw_tarot - draw random tarot card
    define(interp, "draw_tarot", Some(0), |_, _| {
        let mut rng = rand::thread_rng();
        let card: usize = rng.gen_range(0..22);
        let reversed: bool = rng.gen();

        let cards = [
            "The Fool",
            "The Magician",
            "The High Priestess",
            "The Empress",
            "The Emperor",
            "The Hierophant",
            "The Lovers",
            "The Chariot",
            "Strength",
            "The Hermit",
            "Wheel of Fortune",
            "Justice",
            "The Hanged Man",
            "Death",
            "Temperance",
            "The Devil",
            "The Tower",
            "The Star",
            "The Moon",
            "The Sun",
            "Judgement",
            "The World",
        ];

        let mut result = std::collections::HashMap::new();
        result.insert("number".to_string(), Value::Int(card as i64));
        result.insert(
            "name".to_string(),
            Value::String(Rc::new(cards[card].to_string())),
        );
        result.insert("reversed".to_string(), Value::Bool(reversed));
        result.insert(
            "orientation".to_string(),
            Value::String(Rc::new(
                if reversed { "reversed" } else { "upright" }.to_string(),
            )),
        );

        Ok(Value::Map(Rc::new(RefCell::new(result))))
    });

    // =========================================================================
    // SYNCHRONICITY
    // =========================================================================

    // synchronicity_score - calculate "meaningful coincidence" between values
    define(interp, "synchronicity_score", Some(2), |_, args| {
        // This is intentionally mysterious - combining multiple systems
        let a = match &args[0] {
            Value::String(s) => s.to_string(),
            Value::Int(n) => n.to_string(),
            _ => {
                return Err(RuntimeError::new(
                    "synchronicity_score() requires string or int",
                ))
            }
        };

        let b = match &args[1] {
            Value::String(s) => s.to_string(),
            Value::Int(n) => n.to_string(),
            _ => {
                return Err(RuntimeError::new(
                    "synchronicity_score() requires string or int",
                ))
            }
        };

        // Calculate gematria values (simple English)
        let val_a: i64 = a
            .to_uppercase()
            .chars()
            .filter_map(|c| {
                if c.is_ascii_alphabetic() {
                    Some((c as i64) - ('A' as i64) + 1)
                } else if c.is_ascii_digit() {
                    c.to_digit(10).map(|d| d as i64)
                } else {
                    None
                }
            })
            .sum();

        let val_b: i64 = b
            .to_uppercase()
            .chars()
            .filter_map(|c| {
                if c.is_ascii_alphabetic() {
                    Some((c as i64) - ('A' as i64) + 1)
                } else if c.is_ascii_digit() {
                    c.to_digit(10).map(|d| d as i64)
                } else {
                    None
                }
            })
            .sum();

        // Multiple synchronicity factors
        let mut factors = Vec::new();

        // Same value
        if val_a == val_b {
            factors.push("identical_gematria".to_string());
        }

        // One divides the other
        if val_a > 0 && val_b > 0 && (val_a % val_b == 0 || val_b % val_a == 0) {
            factors.push("divisibility".to_string());
        }

        // Fibonacci relationship
        let fib_set: std::collections::HashSet<i64> =
            [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987]
                .iter()
                .cloned()
                .collect();
        if fib_set.contains(&val_a) && fib_set.contains(&val_b) {
            factors.push("both_fibonacci".to_string());
        }

        // Digital root match
        fn digital_root(mut n: i64) -> i64 {
            while n > 9 {
                n = n
                    .to_string()
                    .chars()
                    .filter_map(|c| c.to_digit(10))
                    .map(|d| d as i64)
                    .sum();
            }
            n
        }
        if digital_root(val_a) == digital_root(val_b) {
            factors.push("same_digital_root".to_string());
        }

        // Golden ratio relationship (within 1%)
        let phi = (1.0 + 5.0_f64.sqrt()) / 2.0;
        let ratio = if val_a > 0 && val_b > 0 {
            (val_a as f64 / val_b as f64).max(val_b as f64 / val_a as f64)
        } else {
            0.0
        };
        if (ratio - phi).abs() < 0.02 || (ratio - 1.0 / phi).abs() < 0.02 {
            factors.push("golden_ratio".to_string());
        }

        let score = (factors.len() as f64 / 5.0).min(1.0);

        let mut result = std::collections::HashMap::new();
        result.insert("score".to_string(), Value::Float(score));
        result.insert("value_a".to_string(), Value::Int(val_a));
        result.insert("value_b".to_string(), Value::Int(val_b));
        let factor_values: Vec<Value> = factors
            .iter()
            .map(|s| Value::String(Rc::new(s.clone())))
            .collect();
        result.insert(
            "factors".to_string(),
            Value::Array(Rc::new(RefCell::new(factor_values))),
        );

        Ok(Value::Map(Rc::new(RefCell::new(result))))
    });

    // spirituality_info
    define(interp, "spirituality_info", Some(0), |_, _| {
        let mut info = std::collections::HashMap::new();

        info.insert(
            "i_ching".to_string(),
            Value::String(Rc::new(
                "trigram(), hexagram(), cast_iching() - 64 hexagrams of change".to_string(),
            )),
        );
        info.insert(
            "sacred_geometry".to_string(),
            Value::String(Rc::new(
                "phi(), sacred_ratio(), fibonacci(), platonic_solid()".to_string(),
            )),
        );
        info.insert(
            "gematria".to_string(),
            Value::String(Rc::new(
                "Hebrew, Greek, Arabic, English letter-number systems".to_string(),
            )),
        );
        info.insert(
            "archetypes".to_string(),
            Value::String(Rc::new(
                "17 Jungian archetypes with shadow and gift".to_string(),
            )),
        );
        info.insert(
            "astrology".to_string(),
            Value::String(Rc::new(
                "zodiac() - 12 signs with elements and modalities".to_string(),
            )),
        );
        info.insert(
            "tarot".to_string(),
            Value::String(Rc::new(
                "tarot_major(), draw_tarot() - 22 Major Arcana".to_string(),
            )),
        );

        Ok(Value::Map(Rc::new(RefCell::new(info))))
    });
}

// I Ching hexagram data (64 hexagrams in King Wen sequence)
const HEXAGRAMS: [(&str, &str, &str, &str, &str, &str); 64] = [
    (
        "乾",
        "Qián",
        "The Creative",
        "Sublime success through perseverance",
        "Heaven",
        "Heaven",
    ),
    (
        "坤",
        "Kūn",
        "The Receptive",
        "Devoted success through the mare's perseverance",
        "Earth",
        "Earth",
    ),
    (
        "屯",
        "Zhūn",
        "Difficulty at the Beginning",
        "Persevere, seek helpers, don't act alone",
        "Water",
        "Thunder",
    ),
    (
        "蒙",
        "Méng",
        "Youthful Folly",
        "Success through education and guidance",
        "Mountain",
        "Water",
    ),
    (
        "需",
        "Xū",
        "Waiting",
        "Sincerity brings success; cross the great water",
        "Water",
        "Heaven",
    ),
    (
        "訟",
        "Sòng",
        "Conflict",
        "Seek counsel; don't cross the great water",
        "Heaven",
        "Water",
    ),
    (
        "師",
        "Shī",
        "The Army",
        "Perseverance and an experienced leader bring success",
        "Earth",
        "Water",
    ),
    (
        "比",
        "Bǐ",
        "Holding Together",
        "Through perseverance, those who hesitate should reflect",
        "Water",
        "Earth",
    ),
    (
        "小畜",
        "Xiǎo Chù",
        "Small Taming",
        "Success; dense clouds but no rain",
        "Wind",
        "Heaven",
    ),
    (
        "履",
        "Lǚ",
        "Treading",
        "Tread on the tiger's tail carefully; success",
        "Heaven",
        "Lake",
    ),
    (
        "泰",
        "Tài",
        "Peace",
        "The small departs, the great approaches; success",
        "Earth",
        "Heaven",
    ),
    (
        "否",
        "Pǐ",
        "Standstill",
        "The great departs, the small approaches; persevere",
        "Heaven",
        "Earth",
    ),
    (
        "同人",
        "Tóng Rén",
        "Fellowship",
        "Success in the open; cross the great water",
        "Heaven",
        "Fire",
    ),
    (
        "大有",
        "Dà Yǒu",
        "Great Possession",
        "Supreme success",
        "Fire",
        "Heaven",
    ),
    (
        "謙",
        "Qiān",
        "Modesty",
        "Success; the superior person carries things through",
        "Earth",
        "Mountain",
    ),
    (
        "豫",
        "Yù",
        "Enthusiasm",
        "Appoint helpers and set armies marching",
        "Thunder",
        "Earth",
    ),
    (
        "隨",
        "Suí",
        "Following",
        "Supreme success through perseverance",
        "Lake",
        "Thunder",
    ),
    (
        "蠱",
        "Gǔ",
        "Work on the Decayed",
        "Success; cross the great water; three days before and after",
        "Mountain",
        "Wind",
    ),
    (
        "臨",
        "Lín",
        "Approach",
        "Great success through perseverance; misfortune in eighth month",
        "Earth",
        "Lake",
    ),
    (
        "觀",
        "Guān",
        "Contemplation",
        "Ablution, but not yet sacrifice; confidence inspires",
        "Wind",
        "Earth",
    ),
    (
        "噬嗑",
        "Shì Kè",
        "Biting Through",
        "Success; favorable for legal matters",
        "Fire",
        "Thunder",
    ),
    (
        "賁",
        "Bì",
        "Grace",
        "Success in small matters",
        "Mountain",
        "Fire",
    ),
    (
        "剝",
        "Bō",
        "Splitting Apart",
        "Unfavorable to go anywhere",
        "Mountain",
        "Earth",
    ),
    (
        "復",
        "Fù",
        "Return",
        "Success; going out and coming in without error",
        "Earth",
        "Thunder",
    ),
    (
        "無妄",
        "Wú Wàng",
        "Innocence",
        "Supreme success through perseverance",
        "Heaven",
        "Thunder",
    ),
    (
        "大畜",
        "Dà Chù",
        "Great Taming",
        "Perseverance; eat away from home",
        "Mountain",
        "Heaven",
    ),
    (
        "頤",
        "Yí",
        "Nourishment",
        "Perseverance; watch what you nurture",
        "Mountain",
        "Thunder",
    ),
    (
        "大過",
        "Dà Guò",
        "Great Exceeding",
        "The ridgepole sags; favorable to have somewhere to go",
        "Lake",
        "Wind",
    ),
    (
        "坎",
        "Kǎn",
        "The Abysmal",
        "Sincerity brings success of the heart",
        "Water",
        "Water",
    ),
    (
        "離",
        "Lí",
        "The Clinging",
        "Perseverance; success; care for the cow",
        "Fire",
        "Fire",
    ),
    (
        "咸",
        "Xián",
        "Influence",
        "Success; perseverance; taking a maiden brings fortune",
        "Lake",
        "Mountain",
    ),
    (
        "恆",
        "Héng",
        "Duration",
        "Success without blame; perseverance; favorable to have somewhere to go",
        "Thunder",
        "Wind",
    ),
    (
        "遯",
        "Dùn",
        "Retreat",
        "Success; small perseverance",
        "Heaven",
        "Mountain",
    ),
    (
        "大壯",
        "Dà Zhuàng",
        "Great Power",
        "Perseverance",
        "Thunder",
        "Heaven",
    ),
    (
        "晉",
        "Jìn",
        "Progress",
        "The powerful prince is honored with horses",
        "Fire",
        "Earth",
    ),
    (
        "明夷",
        "Míng Yí",
        "Darkening of the Light",
        "Perseverance in adversity",
        "Earth",
        "Fire",
    ),
    (
        "家人",
        "Jiā Rén",
        "The Family",
        "Perseverance of the woman",
        "Wind",
        "Fire",
    ),
    (
        "睽",
        "Kuí",
        "Opposition",
        "Good fortune in small matters",
        "Fire",
        "Lake",
    ),
    (
        "蹇",
        "Jiǎn",
        "Obstruction",
        "Southwest favorable; northeast unfavorable; see the great person",
        "Water",
        "Mountain",
    ),
    (
        "解",
        "Xiè",
        "Deliverance",
        "Southwest favorable; return brings fortune; haste brings fortune",
        "Thunder",
        "Water",
    ),
    (
        "損",
        "Sǔn",
        "Decrease",
        "Sincerity; supreme fortune; persistence; favorable to undertake",
        "Mountain",
        "Lake",
    ),
    (
        "益",
        "Yì",
        "Increase",
        "Favorable to undertake and cross the great water",
        "Wind",
        "Thunder",
    ),
    (
        "夬",
        "Guài",
        "Breakthrough",
        "Proclaim at the king's court; sincerity in danger",
        "Lake",
        "Heaven",
    ),
    (
        "姤",
        "Gòu",
        "Coming to Meet",
        "The maiden is powerful; don't marry such a maiden",
        "Heaven",
        "Wind",
    ),
    (
        "萃",
        "Cuì",
        "Gathering",
        "Success; the king approaches his temple; see the great person",
        "Lake",
        "Earth",
    ),
    (
        "升",
        "Shēng",
        "Pushing Upward",
        "Supreme success; see the great person; don't worry",
        "Earth",
        "Wind",
    ),
    (
        "困",
        "Kùn",
        "Oppression",
        "Success; perseverance of the great person; no blame",
        "Lake",
        "Water",
    ),
    (
        "井",
        "Jǐng",
        "The Well",
        "The town may change but not the well",
        "Water",
        "Wind",
    ),
    (
        "革",
        "Gé",
        "Revolution",
        "On your own day you are believed; great success",
        "Lake",
        "Fire",
    ),
    (
        "鼎",
        "Dǐng",
        "The Cauldron",
        "Supreme good fortune; success",
        "Fire",
        "Wind",
    ),
    (
        "震",
        "Zhèn",
        "The Arousing",
        "Success; thunder comes with fright; laughing and talking after",
        "Thunder",
        "Thunder",
    ),
    (
        "艮",
        "Gèn",
        "Keeping Still",
        "Keep your back still; go into the courtyard without seeing anyone",
        "Mountain",
        "Mountain",
    ),
    (
        "漸",
        "Jiàn",
        "Development",
        "The maiden is given in marriage; good fortune; perseverance",
        "Wind",
        "Mountain",
    ),
    (
        "歸妹",
        "Guī Mèi",
        "The Marrying Maiden",
        "Undertakings bring misfortune",
        "Thunder",
        "Lake",
    ),
    (
        "豐",
        "Fēng",
        "Abundance",
        "Success; the king attains it; don't worry; be like the sun at noon",
        "Thunder",
        "Fire",
    ),
    (
        "旅",
        "Lǚ",
        "The Wanderer",
        "Success through smallness; perseverance brings fortune",
        "Fire",
        "Mountain",
    ),
    (
        "巽",
        "Xùn",
        "The Gentle",
        "Success through small things; favorable to have somewhere to go",
        "Wind",
        "Wind",
    ),
    (
        "兌",
        "Duì",
        "The Joyous",
        "Success; perseverance",
        "Lake",
        "Lake",
    ),
    (
        "渙",
        "Huàn",
        "Dispersion",
        "Success; the king approaches his temple; cross the great water",
        "Wind",
        "Water",
    ),
    (
        "節",
        "Jié",
        "Limitation",
        "Success; bitter limitation should not be persevered in",
        "Water",
        "Lake",
    ),
    (
        "中孚",
        "Zhōng Fú",
        "Inner Truth",
        "Pigs and fishes; good fortune; cross the great water",
        "Wind",
        "Lake",
    ),
    (
        "小過",
        "Xiǎo Guò",
        "Small Exceeding",
        "Success; perseverance; small things yes, great things no",
        "Thunder",
        "Mountain",
    ),
    (
        "既濟",
        "Jì Jì",
        "After Completion",
        "Success in small matters; perseverance; good at start, disorder at end",
        "Water",
        "Fire",
    ),
    (
        "未濟",
        "Wèi Jì",
        "Before Completion",
        "Success; the young fox almost across; tail gets wet; no goal",
        "Fire",
        "Water",
    ),
];

fn binary_to_king_wen(binary: u8) -> u8 {
    // Maps binary hexagram representation to King Wen sequence number
    // This is a complex mapping based on traditional ordering
    const KING_WEN_ORDER: [u8; 64] = [
        1, 43, 14, 34, 9, 5, 26, 11, 10, 58, 38, 54, 61, 60, 41, 19, 13, 49, 30, 55, 37, 63, 22,
        36, 25, 17, 21, 51, 42, 3, 27, 24, 44, 28, 50, 32, 57, 48, 18, 46, 6, 47, 64, 40, 59, 29,
        4, 7, 33, 31, 56, 62, 53, 39, 52, 15, 12, 45, 35, 16, 20, 8, 23, 2,
    ];
    KING_WEN_ORDER[binary as usize] - 1
}

fn hebrew_gematria(c: char) -> i64 {
    match c {
        'א' | 'A' | 'a' => 1,
        'ב' | 'B' | 'b' => 2,
        'ג' | 'G' | 'g' => 3,
        'ד' | 'D' | 'd' => 4,
        'ה' | 'H' | 'h' => 5,
        'ו' | 'V' | 'v' | 'W' | 'w' => 6,
        'ז' | 'Z' | 'z' => 7,
        'ח' => 8,
        'ט' => 9,
        'י' | 'Y' | 'y' | 'I' | 'i' | 'J' | 'j' => 10,
        'כ' | 'K' | 'k' => 20,
        'ל' | 'L' | 'l' => 30,
        'מ' | 'M' | 'm' => 40,
        'נ' | 'N' | 'n' => 50,
        'ס' | 'S' | 's' | 'X' | 'x' => 60,
        'ע' | 'O' | 'o' => 70,
        'פ' | 'P' | 'p' | 'F' | 'f' => 80,
        'צ' => 90,
        'ק' | 'Q' | 'q' => 100,
        'ר' | 'R' | 'r' => 200,
        'ש' => 300,
        'ת' | 'T' | 't' => 400,
        'ך' => 500,             // Final kaph
        'ם' => 600,             // Final mem
        'ן' => 700,             // Final nun
        'ף' => 800,             // Final pe
        'ץ' | 'C' | 'c' => 900, // Final tzadi / C approximation
        'E' | 'e' => 5,         // Map to He
        'U' | 'u' => 6,         // Map to Vav
        _ => 0,
    }
}

fn greek_isopsephy(c: char) -> i64 {
    match c {
        'Α' | 'α' | 'A' | 'a' => 1,
        'Β' | 'β' | 'B' | 'b' => 2,
        'Γ' | 'γ' | 'G' | 'g' => 3,
        'Δ' | 'δ' | 'D' | 'd' => 4,
        'Ε' | 'ε' | 'E' | 'e' => 5,
        'Ϛ' | 'ϛ' => 6, // Stigma (archaic)
        'Ζ' | 'ζ' | 'Z' | 'z' => 7,
        'Η' | 'η' | 'H' | 'h' => 8,
        'Θ' | 'θ' => 9,
        'Ι' | 'ι' | 'I' | 'i' => 10,
        'Κ' | 'κ' | 'K' | 'k' => 20,
        'Λ' | 'λ' | 'L' | 'l' => 30,
        'Μ' | 'μ' | 'M' | 'm' => 40,
        'Ν' | 'ν' | 'N' | 'n' => 50,
        'Ξ' | 'ξ' | 'X' | 'x' => 60,
        'Ο' | 'ο' | 'O' | 'o' => 70,
        'Π' | 'π' | 'P' | 'p' => 80,
        'Ϙ' | 'ϙ' | 'Q' | 'q' => 90, // Qoppa
        'Ρ' | 'ρ' | 'R' | 'r' => 100,
        'Σ' | 'σ' | 'ς' | 'S' | 's' => 200,
        'Τ' | 'τ' | 'T' | 't' => 300,
        'Υ' | 'υ' | 'U' | 'u' | 'Y' | 'y' => 400,
        'Φ' | 'φ' | 'F' | 'f' => 500,
        'Χ' | 'χ' | 'C' | 'c' => 600,
        'Ψ' | 'ψ' => 700,
        'Ω' | 'ω' | 'W' | 'w' => 800,
        'Ϡ' | 'ϡ' => 900, // Sampi
        'J' | 'j' => 10,  // Map to Iota
        'V' | 'v' => 400, // Map to Upsilon
        _ => 0,
    }
}

fn arabic_abjad(c: char) -> i64 {
    match c {
        'ا' | 'أ' | 'إ' | 'آ' | 'A' | 'a' => 1,
        'ب' | 'B' | 'b' => 2,
        'ج' | 'J' | 'j' | 'G' | 'g' => 3,
        'د' | 'D' | 'd' => 4,
        'ه' | 'H' | 'h' => 5,
        'و' | 'W' | 'w' | 'V' | 'v' => 6,
        'ز' | 'Z' | 'z' => 7,
        'ح' => 8,
        'ط' => 9,
        'ي' | 'Y' | 'y' | 'I' | 'i' => 10,
        'ك' | 'K' | 'k' => 20,
        'ل' | 'L' | 'l' => 30,
        'م' | 'M' | 'm' => 40,
        'ن' | 'N' | 'n' => 50,
        'س' | 'S' | 's' => 60,
        'ع' | 'E' | 'e' => 70,
        'ف' | 'F' | 'f' => 80,
        'ص' => 90,
        'ق' | 'Q' | 'q' => 100,
        'ر' | 'R' | 'r' => 200,
        'ش' => 300,
        'ت' | 'T' | 't' => 400,
        'ث' => 500,
        'خ' | 'X' | 'x' => 600,
        'ذ' => 700,
        'ض' => 800,
        'ظ' => 900,
        'غ' => 1000,
        'C' | 'c' => 600, // Map to خ
        'O' | 'o' => 70,  // Map to ع
        'P' | 'p' => 80,  // Map to ف
        'U' | 'u' => 6,   // Map to و
        _ => 0,
    }
}

// =============================================================================
// Phase 16: Polycultural Color System
// =============================================================================
// Color meaning varies radically across cultures. This module provides mathematical
// color spaces + cultural color systems from around the world.

fn register_color(interp: &mut Interpreter) {
    // =========================================================================
    // COLOR SPACE CONVERSIONS
    // =========================================================================

    // rgb(r, g, b) - Create RGB color (0-255)
    define(interp, "rgb", Some(3), |_, args| {
        let r = match &args[0] {
            Value::Int(n) => (*n).clamp(0, 255) as u8,
            Value::Float(f) => (*f as i64).clamp(0, 255) as u8,
            _ => return Err(RuntimeError::new("rgb() requires numbers")),
        };
        let g = match &args[1] {
            Value::Int(n) => (*n).clamp(0, 255) as u8,
            Value::Float(f) => (*f as i64).clamp(0, 255) as u8,
            _ => return Err(RuntimeError::new("rgb() requires numbers")),
        };
        let b = match &args[2] {
            Value::Int(n) => (*n).clamp(0, 255) as u8,
            Value::Float(f) => (*f as i64).clamp(0, 255) as u8,
            _ => return Err(RuntimeError::new("rgb() requires numbers")),
        };
        let mut map = std::collections::HashMap::new();
        map.insert("r".to_string(), Value::Int(r as i64));
        map.insert("g".to_string(), Value::Int(g as i64));
        map.insert("b".to_string(), Value::Int(b as i64));
        map.insert(
            "hex".to_string(),
            Value::String(Rc::new(format!("#{:02X}{:02X}{:02X}", r, g, b))),
        );
        Ok(Value::Map(Rc::new(RefCell::new(map))))
    });

    // hex_to_rgb(hex) - Parse hex color string
    define(interp, "hex_to_rgb", Some(1), |_, args| {
        let hex = match &args[0] {
            Value::String(s) => s.to_string(),
            _ => return Err(RuntimeError::new("hex_to_rgb requires string")),
        };
        let hex = hex.trim_start_matches('#');
        if hex.len() != 6 {
            return Err(RuntimeError::new("hex_to_rgb requires 6 character hex"));
        }
        let r = u8::from_str_radix(&hex[0..2], 16).map_err(|_| RuntimeError::new("Invalid hex"))?;
        let g = u8::from_str_radix(&hex[2..4], 16).map_err(|_| RuntimeError::new("Invalid hex"))?;
        let b = u8::from_str_radix(&hex[4..6], 16).map_err(|_| RuntimeError::new("Invalid hex"))?;
        let mut map = std::collections::HashMap::new();
        map.insert("r".to_string(), Value::Int(r as i64));
        map.insert("g".to_string(), Value::Int(g as i64));
        map.insert("b".to_string(), Value::Int(b as i64));
        Ok(Value::Map(Rc::new(RefCell::new(map))))
    });

    // rgb_to_hsl(r, g, b) - Convert RGB to HSL
    define(interp, "rgb_to_hsl", Some(3), |_, args| {
        let r = match &args[0] {
            Value::Int(n) => *n as f64 / 255.0,
            Value::Float(f) => *f / 255.0,
            _ => return Err(RuntimeError::new("requires numbers")),
        };
        let g = match &args[1] {
            Value::Int(n) => *n as f64 / 255.0,
            Value::Float(f) => *f / 255.0,
            _ => return Err(RuntimeError::new("requires numbers")),
        };
        let b = match &args[2] {
            Value::Int(n) => *n as f64 / 255.0,
            Value::Float(f) => *f / 255.0,
            _ => return Err(RuntimeError::new("requires numbers")),
        };
        let max = r.max(g).max(b);
        let min = r.min(g).min(b);
        let l = (max + min) / 2.0;
        let (h, s) = if max == min {
            (0.0, 0.0)
        } else {
            let d = max - min;
            let s = if l > 0.5 {
                d / (2.0 - max - min)
            } else {
                d / (max + min)
            };
            let h = if max == r {
                (g - b) / d + if g < b { 6.0 } else { 0.0 }
            } else if max == g {
                (b - r) / d + 2.0
            } else {
                (r - g) / d + 4.0
            };
            (h * 60.0, s)
        };
        let mut map = std::collections::HashMap::new();
        map.insert("h".to_string(), Value::Float(h));
        map.insert("s".to_string(), Value::Float(s));
        map.insert("l".to_string(), Value::Float(l));
        Ok(Value::Map(Rc::new(RefCell::new(map))))
    });

    // complementary(r, g, b) - Opposite on color wheel
    define(interp, "complementary", Some(3), |_, args| {
        let r = match &args[0] {
            Value::Int(n) => *n as u8,
            _ => return Err(RuntimeError::new("requires int")),
        };
        let g = match &args[1] {
            Value::Int(n) => *n as u8,
            _ => return Err(RuntimeError::new("requires int")),
        };
        let b = match &args[2] {
            Value::Int(n) => *n as u8,
            _ => return Err(RuntimeError::new("requires int")),
        };
        let mut map = std::collections::HashMap::new();
        map.insert("r".to_string(), Value::Int(255 - r as i64));
        map.insert("g".to_string(), Value::Int(255 - g as i64));
        map.insert("b".to_string(), Value::Int(255 - b as i64));
        Ok(Value::Map(Rc::new(RefCell::new(map))))
    });

    // =========================================================================
    // WU XING (五行) - CHINESE FIVE ELEMENTS
    // =========================================================================
    define(interp, "wu_xing", Some(1), |_, args| {
        let element = match &args[0] {
            Value::String(s) => s.to_lowercase(),
            _ => return Err(RuntimeError::new("wu_xing requires string")),
        };
        let (name, chinese, color, hex, direction, season, organ, emotion, planet, animal) =
            match element.as_str() {
                "wood" | "mu" | "木" => (
                    "Wood",
                    "木 (Mù)",
                    "Green/Azure",
                    "#228B22",
                    "East",
                    "Spring",
                    "Liver",
                    "Anger",
                    "Jupiter",
                    "Azure Dragon",
                ),
                "fire" | "huo" | "火" => (
                    "Fire",
                    "火 (Huǒ)",
                    "Red",
                    "#FF0000",
                    "South",
                    "Summer",
                    "Heart",
                    "Joy",
                    "Mars",
                    "Vermilion Bird",
                ),
                "earth" | "tu" | "土" => (
                    "Earth",
                    "土 (Tǔ)",
                    "Yellow",
                    "#FFDB58",
                    "Center",
                    "Late Summer",
                    "Spleen",
                    "Worry",
                    "Saturn",
                    "Yellow Dragon",
                ),
                "metal" | "jin" | "金" => (
                    "Metal",
                    "金 (Jīn)",
                    "White/Gold",
                    "#FFD700",
                    "West",
                    "Autumn",
                    "Lung",
                    "Grief",
                    "Venus",
                    "White Tiger",
                ),
                "water" | "shui" | "水" => (
                    "Water",
                    "水 (Shuǐ)",
                    "Black/Blue",
                    "#000080",
                    "North",
                    "Winter",
                    "Kidney",
                    "Fear",
                    "Mercury",
                    "Black Tortoise",
                ),
                _ => {
                    return Err(RuntimeError::new(
                        "Unknown element. Use wood/fire/earth/metal/water",
                    ))
                }
            };
        let mut map = std::collections::HashMap::new();
        map.insert("name".to_string(), Value::String(Rc::new(name.to_string())));
        map.insert(
            "chinese".to_string(),
            Value::String(Rc::new(chinese.to_string())),
        );
        map.insert(
            "color".to_string(),
            Value::String(Rc::new(color.to_string())),
        );
        map.insert("hex".to_string(), Value::String(Rc::new(hex.to_string())));
        map.insert(
            "direction".to_string(),
            Value::String(Rc::new(direction.to_string())),
        );
        map.insert(
            "season".to_string(),
            Value::String(Rc::new(season.to_string())),
        );
        map.insert(
            "organ".to_string(),
            Value::String(Rc::new(organ.to_string())),
        );
        map.insert(
            "emotion".to_string(),
            Value::String(Rc::new(emotion.to_string())),
        );
        map.insert(
            "planet".to_string(),
            Value::String(Rc::new(planet.to_string())),
        );
        map.insert(
            "guardian".to_string(),
            Value::String(Rc::new(animal.to_string())),
        );
        Ok(Value::Map(Rc::new(RefCell::new(map))))
    });

    // =========================================================================
    // CHAKRA COLORS (Ayurveda/Hindu)
    // =========================================================================
    define(interp, "chakra_color", Some(1), |_, args| {
        let chakra = match &args[0] {
            Value::String(s) => s.to_lowercase(),
            Value::Int(n) => n.to_string(),
            _ => return Err(RuntimeError::new("chakra_color requires string or number")),
        };
        let (name, sanskrit, color, hex, location, freq, element, mantra) = match chakra.as_str() {
            "root" | "muladhara" | "1" => (
                "Root",
                "मूलाधार",
                "Red",
                "#FF0000",
                "Base of spine",
                396.0,
                "Earth",
                "LAM",
            ),
            "sacral" | "svadhisthana" | "2" => (
                "Sacral",
                "स्वाधिष्ठान",
                "Orange",
                "#FF7F00",
                "Below navel",
                417.0,
                "Water",
                "VAM",
            ),
            "solar" | "manipura" | "3" => (
                "Solar Plexus",
                "मणिपूर",
                "Yellow",
                "#FFFF00",
                "Stomach",
                528.0,
                "Fire",
                "RAM",
            ),
            "heart" | "anahata" | "4" => (
                "Heart",
                "अनाहत",
                "Green",
                "#00FF00",
                "Chest",
                639.0,
                "Air",
                "YAM",
            ),
            "throat" | "vishuddha" | "5" => (
                "Throat",
                "विशुद्ध",
                "Blue",
                "#00BFFF",
                "Throat",
                741.0,
                "Ether",
                "HAM",
            ),
            "third_eye" | "ajna" | "6" => (
                "Third Eye",
                "आज्ञा",
                "Indigo",
                "#4B0082",
                "Forehead",
                852.0,
                "Light",
                "OM",
            ),
            "crown" | "sahasrara" | "7" => (
                "Crown",
                "सहस्रार",
                "Violet",
                "#8B00FF",
                "Top of head",
                963.0,
                "Thought",
                "Silence",
            ),
            _ => {
                return Err(RuntimeError::new(
                    "Unknown chakra. Use root/sacral/solar/heart/throat/third_eye/crown or 1-7",
                ))
            }
        };
        let mut map = std::collections::HashMap::new();
        map.insert("name".to_string(), Value::String(Rc::new(name.to_string())));
        map.insert(
            "sanskrit".to_string(),
            Value::String(Rc::new(sanskrit.to_string())),
        );
        map.insert(
            "color".to_string(),
            Value::String(Rc::new(color.to_string())),
        );
        map.insert("hex".to_string(), Value::String(Rc::new(hex.to_string())));
        map.insert(
            "location".to_string(),
            Value::String(Rc::new(location.to_string())),
        );
        map.insert("frequency_hz".to_string(), Value::Float(freq));
        map.insert(
            "element".to_string(),
            Value::String(Rc::new(element.to_string())),
        );
        map.insert(
            "mantra".to_string(),
            Value::String(Rc::new(mantra.to_string())),
        );
        Ok(Value::Map(Rc::new(RefCell::new(map))))
    });

    // =========================================================================
    // MAYAN DIRECTIONAL COLORS
    // =========================================================================
    define(interp, "maya_direction", Some(1), |_, args| {
        let dir = match &args[0] {
            Value::String(s) => s.to_lowercase(),
            _ => return Err(RuntimeError::new("requires string")),
        };
        let (direction, yucatec, color, hex, deity, meaning) = match dir.as_str() {
            "east" | "lakin" => (
                "East",
                "Lak'in",
                "Red",
                "#FF0000",
                "Chac (Red)",
                "Sunrise, new beginnings",
            ),
            "north" | "xaman" => (
                "North",
                "Xaman",
                "White",
                "#FFFFFF",
                "Chac (White)",
                "Ancestors, death",
            ),
            "west" | "chikin" => (
                "West",
                "Chik'in",
                "Black",
                "#000000",
                "Chac (Black)",
                "Sunset, completion",
            ),
            "south" | "nohol" => (
                "South",
                "Nohol",
                "Yellow",
                "#FFFF00",
                "Chac (Yellow)",
                "Maize, abundance",
            ),
            "center" | "yax" => (
                "Center",
                "Yax",
                "Green/Blue",
                "#00CED1",
                "World Tree",
                "Balance",
            ),
            _ => {
                return Err(RuntimeError::new(
                    "Unknown direction. Use east/north/west/south/center",
                ))
            }
        };
        let mut map = std::collections::HashMap::new();
        map.insert(
            "direction".to_string(),
            Value::String(Rc::new(direction.to_string())),
        );
        map.insert(
            "yucatec".to_string(),
            Value::String(Rc::new(yucatec.to_string())),
        );
        map.insert(
            "color".to_string(),
            Value::String(Rc::new(color.to_string())),
        );
        map.insert("hex".to_string(), Value::String(Rc::new(hex.to_string())));
        map.insert(
            "deity".to_string(),
            Value::String(Rc::new(deity.to_string())),
        );
        map.insert(
            "meaning".to_string(),
            Value::String(Rc::new(meaning.to_string())),
        );
        Ok(Value::Map(Rc::new(RefCell::new(map))))
    });

    // =========================================================================
    // ORISHA COLORS (Yoruba/African)
    // =========================================================================
    define(interp, "orisha_color", Some(1), |_, args| {
        let orisha = match &args[0] {
            Value::String(s) => s.to_lowercase(),
            _ => return Err(RuntimeError::new("requires string")),
        };
        let (name, colors, hex, domain, day, number) = match orisha.as_str() {
            "obatala" | "oxala" => (
                "Obatalá",
                "White, silver",
                "#FFFFFF",
                "Creation, purity, wisdom",
                "Sunday",
                8,
            ),
            "yemoja" | "yemanja" => (
                "Yemọja",
                "Blue, white",
                "#4169E1",
                "Ocean, motherhood",
                "Saturday",
                7,
            ),
            "oshun" | "oxum" => (
                "Ọṣun",
                "Yellow, gold",
                "#FFD700",
                "Rivers, love, fertility",
                "Saturday",
                5,
            ),
            "shango" | "xango" => (
                "Ṣàngó",
                "Red, white",
                "#FF0000",
                "Thunder, fire, justice",
                "Wednesday",
                6,
            ),
            "ogun" | "ogum" => (
                "Ògún",
                "Green, black",
                "#006400",
                "Iron, war, labor",
                "Tuesday",
                7,
            ),
            "oya" | "iansa" => (
                "Ọya",
                "Brown, purple",
                "#800020",
                "Wind, storms, change",
                "Wednesday",
                9,
            ),
            "eshu" | "exu" => (
                "Èṣù",
                "Red, black",
                "#8B0000",
                "Crossroads, messages",
                "Monday",
                3,
            ),
            _ => {
                return Err(RuntimeError::new(
                    "Unknown Orisha. Use obatala/yemoja/oshun/shango/ogun/oya/eshu",
                ))
            }
        };
        let mut map = std::collections::HashMap::new();
        map.insert("name".to_string(), Value::String(Rc::new(name.to_string())));
        map.insert(
            "colors".to_string(),
            Value::String(Rc::new(colors.to_string())),
        );
        map.insert("hex".to_string(), Value::String(Rc::new(hex.to_string())));
        map.insert(
            "domain".to_string(),
            Value::String(Rc::new(domain.to_string())),
        );
        map.insert("day".to_string(), Value::String(Rc::new(day.to_string())));
        map.insert("number".to_string(), Value::Int(number));
        Ok(Value::Map(Rc::new(RefCell::new(map))))
    });

    // =========================================================================
    // JAPANESE TRADITIONAL COLORS (nihon_iro)
    // =========================================================================
    define(interp, "nihon_iro", Some(1), |_, args| {
        let color = match &args[0] {
            Value::String(s) => s.to_lowercase(),
            _ => return Err(RuntimeError::new("requires string")),
        };
        let (name, japanese, hex, meaning, season) = match color.as_str() {
            "sakura" => (
                "Sakura Pink",
                "桜色",
                "#FFB7C5",
                "Cherry blossoms, transience",
                "Spring",
            ),
            "fuji" => (
                "Wisteria",
                "藤色",
                "#C9A0DC",
                "Elegance, nobility",
                "Spring",
            ),
            "moegi" => (
                "Young Green",
                "萌黄",
                "#AACF53",
                "New growth, freshness",
                "Spring",
            ),
            "ai" => ("Indigo", "藍色", "#004D99", "Protection, depth", "All"),
            "akane" => ("Madder Red", "茜色", "#CF3A24", "Sunset, passion", "Autumn"),
            "shiro" => ("White", "白", "#FFFFFF", "Purity, death, sacred", "Winter"),
            "kuro" => ("Black", "黒", "#000000", "Formality, mystery", "All"),
            "aka" => ("Red", "赤", "#D7003A", "Life force, celebration", "All"),
            "murasaki" => ("Purple", "紫", "#884898", "Nobility, spirituality", "All"),
            _ => {
                return Err(RuntimeError::new(
                    "Unknown color. Try: sakura/fuji/moegi/ai/akane/shiro/kuro/aka/murasaki",
                ))
            }
        };
        let mut map = std::collections::HashMap::new();
        map.insert("name".to_string(), Value::String(Rc::new(name.to_string())));
        map.insert(
            "japanese".to_string(),
            Value::String(Rc::new(japanese.to_string())),
        );
        map.insert("hex".to_string(), Value::String(Rc::new(hex.to_string())));
        map.insert(
            "meaning".to_string(),
            Value::String(Rc::new(meaning.to_string())),
        );
        map.insert(
            "season".to_string(),
            Value::String(Rc::new(season.to_string())),
        );
        Ok(Value::Map(Rc::new(RefCell::new(map))))
    });

    // =========================================================================
    // ISLAMIC COLOR SYMBOLISM
    // =========================================================================
    define(interp, "islamic_color", Some(1), |_, args| {
        let color = match &args[0] {
            Value::String(s) => s.to_lowercase(),
            _ => return Err(RuntimeError::new("requires string")),
        };
        let (name, arabic, hex, meaning, usage) = match color.as_str() {
            "green" | "akhdar" => (
                "Green",
                "أخضر",
                "#00FF00",
                "Paradise, Prophet, life",
                "Mosques, Quran, flags",
            ),
            "white" | "abyad" => (
                "White",
                "أبيض",
                "#FFFFFF",
                "Purity, peace, ihram",
                "Pilgrimage, burial",
            ),
            "black" | "aswad" => (
                "Black",
                "أسود",
                "#000000",
                "Modesty, Kaaba",
                "Kiswah, abaya",
            ),
            "gold" | "dhahabi" => (
                "Gold",
                "ذهبي",
                "#FFD700",
                "Paradise, divine light",
                "Calligraphy, decoration",
            ),
            "blue" | "azraq" => (
                "Blue",
                "أزرق",
                "#0000CD",
                "Protection, heaven",
                "Tiles, evil eye",
            ),
            _ => {
                return Err(RuntimeError::new(
                    "Unknown color. Use green/white/black/gold/blue",
                ))
            }
        };
        let mut map = std::collections::HashMap::new();
        map.insert("name".to_string(), Value::String(Rc::new(name.to_string())));
        map.insert(
            "arabic".to_string(),
            Value::String(Rc::new(arabic.to_string())),
        );
        map.insert("hex".to_string(), Value::String(Rc::new(hex.to_string())));
        map.insert(
            "meaning".to_string(),
            Value::String(Rc::new(meaning.to_string())),
        );
        map.insert(
            "usage".to_string(),
            Value::String(Rc::new(usage.to_string())),
        );
        Ok(Value::Map(Rc::new(RefCell::new(map))))
    });

    // =========================================================================
    // THAI DAY COLORS
    // =========================================================================
    define(interp, "thai_day_color", Some(1), |_, args| {
        let day = match &args[0] {
            Value::String(s) => s.to_lowercase(),
            Value::Int(n) => n.to_string(),
            _ => return Err(RuntimeError::new("requires string or number")),
        };
        let (day_name, thai, color, hex, deity) = match day.as_str() {
            "sunday" | "0" => ("Sunday", "วันอาทิตย์", "Red", "#FF0000", "Surya"),
            "monday" | "1" => ("Monday", "วันจันทร์", "Yellow", "#FFFF00", "Chandra"),
            "tuesday" | "2" => ("Tuesday", "วันอังคาร", "Pink", "#FFC0CB", "Mangala"),
            "wednesday" | "3" => ("Wednesday", "วันพุธ", "Green", "#00FF00", "Budha"),
            "thursday" | "4" => ("Thursday", "วันพฤหัสบดี", "Orange", "#FFA500", "Brihaspati"),
            "friday" | "5" => ("Friday", "วันศุกร์", "Blue", "#00BFFF", "Shukra"),
            "saturday" | "6" => ("Saturday", "วันเสาร์", "Purple", "#800080", "Shani"),
            _ => return Err(RuntimeError::new("Unknown day. Use sunday-saturday or 0-6")),
        };
        let mut map = std::collections::HashMap::new();
        map.insert(
            "day".to_string(),
            Value::String(Rc::new(day_name.to_string())),
        );
        map.insert("thai".to_string(), Value::String(Rc::new(thai.to_string())));
        map.insert(
            "color".to_string(),
            Value::String(Rc::new(color.to_string())),
        );
        map.insert("hex".to_string(), Value::String(Rc::new(hex.to_string())));
        map.insert(
            "deity".to_string(),
            Value::String(Rc::new(deity.to_string())),
        );
        Ok(Value::Map(Rc::new(RefCell::new(map))))
    });

    // =========================================================================
    // ABORIGINAL AUSTRALIAN COLORS
    // =========================================================================
    define(interp, "aboriginal_color", Some(1), |_, args| {
        let color = match &args[0] {
            Value::String(s) => s.to_lowercase(),
            _ => return Err(RuntimeError::new("requires string")),
        };
        let (name, hex, meaning, source, dreamtime) = match color.as_str() {
            "red" | "ochre" => (
                "Red Ochre",
                "#CC5500",
                "Earth, blood, ceremony",
                "Hematite",
                "Ancestral beings",
            ),
            "yellow" => (
                "Yellow Ochre",
                "#D4A017",
                "Sun, healing",
                "Limonite",
                "Sun's journey",
            ),
            "white" => (
                "White",
                "#FFFFFF",
                "Sky, spirits, mourning",
                "Kaolin",
                "Sky beings",
            ),
            "black" => (
                "Black",
                "#000000",
                "Night, formality",
                "Charcoal",
                "Night, men's business",
            ),
            "brown" => (
                "Brown",
                "#8B4513",
                "Earth, land",
                "Earth pigments",
                "Country, connection",
            ),
            _ => {
                return Err(RuntimeError::new(
                    "Unknown color. Use red/yellow/white/black/brown",
                ))
            }
        };
        let mut map = std::collections::HashMap::new();
        map.insert("name".to_string(), Value::String(Rc::new(name.to_string())));
        map.insert("hex".to_string(), Value::String(Rc::new(hex.to_string())));
        map.insert(
            "meaning".to_string(),
            Value::String(Rc::new(meaning.to_string())),
        );
        map.insert(
            "source".to_string(),
            Value::String(Rc::new(source.to_string())),
        );
        map.insert(
            "dreamtime".to_string(),
            Value::String(Rc::new(dreamtime.to_string())),
        );
        Ok(Value::Map(Rc::new(RefCell::new(map))))
    });

    // =========================================================================
    // CELTIC COLORS
    // =========================================================================
    define(interp, "celtic_color", Some(1), |_, args| {
        let color = match &args[0] {
            Value::String(s) => s.to_lowercase(),
            _ => return Err(RuntimeError::new("requires string")),
        };
        let (name, gaelic, hex, meaning, element) = match color.as_str() {
            "green" => (
                "Green",
                "Glas",
                "#228B22",
                "Nature, fairies, Otherworld",
                "Earth",
            ),
            "white" => ("White", "Bán", "#FFFFFF", "Purity, spirits", "Air"),
            "red" => ("Red", "Dearg", "#FF0000", "War, courage, blood", "Fire"),
            "black" => (
                "Black",
                "Dubh",
                "#000000",
                "Otherworld, death, rebirth",
                "Water",
            ),
            "gold" => ("Gold", "Órga", "#FFD700", "Sun, sovereignty, Lugh", "Fire"),
            "silver" => (
                "Silver",
                "Airgid",
                "#C0C0C0",
                "Moon, feminine, intuition",
                "Water",
            ),
            _ => {
                return Err(RuntimeError::new(
                    "Unknown color. Use green/white/red/black/gold/silver",
                ))
            }
        };
        let mut map = std::collections::HashMap::new();
        map.insert("name".to_string(), Value::String(Rc::new(name.to_string())));
        map.insert(
            "gaelic".to_string(),
            Value::String(Rc::new(gaelic.to_string())),
        );
        map.insert("hex".to_string(), Value::String(Rc::new(hex.to_string())));
        map.insert(
            "meaning".to_string(),
            Value::String(Rc::new(meaning.to_string())),
        );
        map.insert(
            "element".to_string(),
            Value::String(Rc::new(element.to_string())),
        );
        Ok(Value::Map(Rc::new(RefCell::new(map))))
    });

    // =========================================================================
    // KENTE CLOTH COLORS (Ghana)
    // =========================================================================
    define(interp, "kente_color", Some(1), |_, args| {
        let color = match &args[0] {
            Value::String(s) => s.to_lowercase(),
            _ => return Err(RuntimeError::new("requires string")),
        };
        let (name, twi, hex, meaning) = match color.as_str() {
            "gold" | "yellow" => ("Gold", "Sika Kɔkɔɔ", "#FFD700", "Royalty, wealth, glory"),
            "green" => ("Green", "Ahabammono", "#228B22", "Growth, renewal, harvest"),
            "blue" => ("Blue", "Bruu", "#0000CD", "Peace, harmony, love"),
            "red" => ("Red", "Kɔkɔɔ", "#FF0000", "Blood, sacrifice, power"),
            "black" => ("Black", "Tuntum", "#000000", "Maturation, ancestors"),
            "white" => ("White", "Fitaa", "#FFFFFF", "Purification, virtue, joy"),
            "maroon" => ("Maroon", "Borɔnɔ", "#800000", "Earth, healing, protection"),
            _ => {
                return Err(RuntimeError::new(
                    "Unknown color. Use gold/green/blue/red/black/white/maroon",
                ))
            }
        };
        let mut map = std::collections::HashMap::new();
        map.insert("name".to_string(), Value::String(Rc::new(name.to_string())));
        map.insert("twi".to_string(), Value::String(Rc::new(twi.to_string())));
        map.insert("hex".to_string(), Value::String(Rc::new(hex.to_string())));
        map.insert(
            "meaning".to_string(),
            Value::String(Rc::new(meaning.to_string())),
        );
        Ok(Value::Map(Rc::new(RefCell::new(map))))
    });

    // =========================================================================
    // HINDU COLOR SYMBOLISM
    // =========================================================================
    define(interp, "hindu_color", Some(1), |_, args| {
        let color = match &args[0] {
            Value::String(s) => s.to_lowercase(),
            _ => return Err(RuntimeError::new("requires string")),
        };
        let (name, hindi, hex, meaning, deities) = match color.as_str() {
            "red" | "lal" => (
                "Red",
                "लाल",
                "#FF0000",
                "Purity, fertility, love",
                "Durga, Lakshmi",
            ),
            "orange" | "saffron" => (
                "Saffron",
                "केसरी",
                "#FF6600",
                "Sacred, renunciation",
                "Hanuman",
            ),
            "yellow" => (
                "Yellow",
                "पीला",
                "#FFFF00",
                "Knowledge, learning",
                "Vishnu, Saraswati",
            ),
            "green" => ("Green", "हरा", "#008000", "Life, happiness", "Krishna"),
            "white" => (
                "White",
                "सफ़ेद",
                "#FFFFFF",
                "Purity, mourning",
                "Saraswati, Shiva",
            ),
            "blue" => (
                "Blue",
                "नीला",
                "#0000FF",
                "Divinity, infinity",
                "Krishna, Vishnu",
            ),
            "black" => (
                "Black",
                "काला",
                "#000000",
                "Protection from evil",
                "Kali, Shani",
            ),
            _ => {
                return Err(RuntimeError::new(
                    "Unknown color. Use red/orange/yellow/green/white/blue/black",
                ))
            }
        };
        let mut map = std::collections::HashMap::new();
        map.insert("name".to_string(), Value::String(Rc::new(name.to_string())));
        map.insert(
            "hindi".to_string(),
            Value::String(Rc::new(hindi.to_string())),
        );
        map.insert("hex".to_string(), Value::String(Rc::new(hex.to_string())));
        map.insert(
            "meaning".to_string(),
            Value::String(Rc::new(meaning.to_string())),
        );
        map.insert(
            "deities".to_string(),
            Value::String(Rc::new(deities.to_string())),
        );
        Ok(Value::Map(Rc::new(RefCell::new(map))))
    });

    // =========================================================================
    // SYNESTHESIA - CROSS-MODAL MAPPING WITH CULTURAL CONTEXT
    // =========================================================================
    define(interp, "emotion_color", Some(2), |_, args| {
        let emotion = match &args[0] {
            Value::String(s) => s.to_lowercase(),
            _ => return Err(RuntimeError::new("requires string")),
        };
        let culture = match &args[1] {
            Value::String(s) => s.to_lowercase(),
            _ => return Err(RuntimeError::new("requires string")),
        };
        let (hex, name, reasoning) = match (emotion.as_str(), culture.as_str()) {
            ("joy", "western") | ("happy", "western") => {
                ("#FFD700", "Gold", "Sunshine = happiness")
            }
            ("joy", "chinese") | ("happy", "chinese") => ("#FF0000", "Red", "红 = luck, joy"),
            ("joy", "japanese") => ("#FFB7C5", "Sakura", "Cherry blossom = fleeting joy"),
            ("sadness", "western") | ("sad", "western") => ("#0000CD", "Blue", "'Feeling blue'"),
            ("sadness", "chinese") | ("sad", "chinese") => ("#FFFFFF", "White", "白 = mourning"),
            ("sadness", "indian") => ("#FFFFFF", "White", "सफ़ेद = mourning"),
            ("anger", _) => ("#FF0000", "Red", "Universal heat/fire"),
            ("love", "western") => ("#FF69B4", "Pink", "Valentine's hearts"),
            ("love", "chinese") | ("love", "indian") => ("#FF0000", "Red", "Red = marriage, love"),
            ("peace", "western") => ("#ADD8E6", "Light Blue", "Sky, serenity"),
            ("peace", "islamic") => ("#00FF00", "Green", "السلام = paradise"),
            ("fear", _) => ("#4B0082", "Indigo", "Deep, mysterious"),
            (_, _) => ("#808080", "Grey", "Neutral"),
        };
        let r = u8::from_str_radix(&hex[1..3], 16).unwrap_or(128);
        let g = u8::from_str_radix(&hex[3..5], 16).unwrap_or(128);
        let b = u8::from_str_radix(&hex[5..7], 16).unwrap_or(128);
        let mut map = std::collections::HashMap::new();
        map.insert("hex".to_string(), Value::String(Rc::new(hex.to_string())));
        map.insert("name".to_string(), Value::String(Rc::new(name.to_string())));
        map.insert("r".to_string(), Value::Int(r as i64));
        map.insert("g".to_string(), Value::Int(g as i64));
        map.insert("b".to_string(), Value::Int(b as i64));
        map.insert(
            "reasoning".to_string(),
            Value::String(Rc::new(reasoning.to_string())),
        );
        Ok(Value::Map(Rc::new(RefCell::new(map))))
    });

    // synesthesia - full cross-modal with cultural awareness
    define(interp, "synesthesia", Some(2), |_, args| {
        let culture = match &args[1] {
            Value::String(s) => s.to_lowercase(),
            _ => return Err(RuntimeError::new("requires culture string")),
        };
        let (r, g, b, emotion, freq) = match &args[0] {
            Value::String(s) => match s.to_lowercase().as_str() {
                "joy" | "happy" => (255u8, 215u8, 0u8, "joy", 528.0),
                "sadness" | "sad" => (0, 0, 139, "sadness", 396.0),
                "anger" => (255, 0, 0, "anger", 417.0),
                "fear" => (75, 0, 130, "fear", 369.0),
                "love" => (255, 105, 180, "love", 639.0),
                "peace" => (135, 206, 235, "peace", 741.0),
                _ => (128, 128, 128, "neutral", 432.0),
            },
            Value::Int(n) => (128, 128, 255, "resonance", *n as f64),
            Value::Float(f) => (128, 128, 255, "resonance", *f),
            _ => (128, 128, 128, "neutral", 432.0),
        };
        let cultural_meaning = match culture.as_str() {
            "chinese" if r > 200 && g < 100 => "luck/joy (红)",
            "japanese" if r > 200 && g < 100 => "vitality (赤)",
            "indian" if r > 200 && g < 100 => "shakti/auspicious",
            _ => "universal resonance",
        };
        let chakra = if r > 200 && g < 100 {
            "Root"
        } else if g > 200 {
            "Heart"
        } else if b > 200 {
            "Throat"
        } else {
            "Crown"
        };
        let wu_xing = if r > 200 && g < 100 {
            "Fire (火)"
        } else if g > 200 {
            "Wood (木)"
        } else if b > 200 {
            "Water (水)"
        } else {
            "Metal (金)"
        };
        let mut map = std::collections::HashMap::new();
        let mut color_map = std::collections::HashMap::new();
        color_map.insert("r".to_string(), Value::Int(r as i64));
        color_map.insert("g".to_string(), Value::Int(g as i64));
        color_map.insert("b".to_string(), Value::Int(b as i64));
        color_map.insert(
            "hex".to_string(),
            Value::String(Rc::new(format!("#{:02X}{:02X}{:02X}", r, g, b))),
        );
        map.insert(
            "color".to_string(),
            Value::Map(Rc::new(RefCell::new(color_map))),
        );
        map.insert(
            "emotion".to_string(),
            Value::String(Rc::new(emotion.to_string())),
        );
        map.insert("frequency".to_string(), Value::Float(freq));
        map.insert(
            "cultural_meaning".to_string(),
            Value::String(Rc::new(cultural_meaning.to_string())),
        );
        map.insert(
            "chakra".to_string(),
            Value::String(Rc::new(chakra.to_string())),
        );
        map.insert(
            "wu_xing".to_string(),
            Value::String(Rc::new(wu_xing.to_string())),
        );
        Ok(Value::Map(Rc::new(RefCell::new(map))))
    });

    // color_to_sound - Scriabin-inspired mapping
    define(interp, "color_to_sound", Some(3), |_, args| {
        let r = match &args[0] {
            Value::Int(n) => *n as f64 / 255.0,
            Value::Float(f) => *f / 255.0,
            _ => return Err(RuntimeError::new("requires numbers")),
        };
        let g = match &args[1] {
            Value::Int(n) => *n as f64 / 255.0,
            Value::Float(f) => *f / 255.0,
            _ => return Err(RuntimeError::new("requires numbers")),
        };
        let b = match &args[2] {
            Value::Int(n) => *n as f64 / 255.0,
            Value::Float(f) => *f / 255.0,
            _ => return Err(RuntimeError::new("requires numbers")),
        };
        let max = r.max(g).max(b);
        let min = r.min(g).min(b);
        let l = (max + min) / 2.0;
        let h = if max == min {
            0.0
        } else {
            let d = max - min;
            if max == r {
                (g - b) / d + if g < b { 6.0 } else { 0.0 }
            } else if max == g {
                (b - r) / d + 2.0
            } else {
                (r - g) / d + 4.0
            }
        } * 60.0;
        let (note, freq) = if h < 30.0 {
            ("C", 261.63)
        } else if h < 60.0 {
            ("G", 392.00)
        } else if h < 90.0 {
            ("D", 293.66)
        } else if h < 120.0 {
            ("A", 440.00)
        } else if h < 150.0 {
            ("E", 329.63)
        } else if h < 180.0 {
            ("B", 493.88)
        } else if h < 210.0 {
            ("F#", 369.99)
        } else if h < 240.0 {
            ("Db", 277.18)
        } else if h < 270.0 {
            ("Ab", 415.30)
        } else if h < 300.0 {
            ("Eb", 311.13)
        } else if h < 330.0 {
            ("Bb", 466.16)
        } else {
            ("F", 349.23)
        };
        let octave_shift = ((l - 0.5) * 4.0).round() as i32;
        let adjusted_freq = freq * 2.0_f64.powi(octave_shift);
        let mut map = std::collections::HashMap::new();
        map.insert("note".to_string(), Value::String(Rc::new(note.to_string())));
        map.insert("frequency".to_string(), Value::Float(adjusted_freq));
        map.insert("hue".to_string(), Value::Float(h));
        Ok(Value::Map(Rc::new(RefCell::new(map))))
    });

    // contrast_ratio - WCAG accessibility
    define(interp, "contrast_ratio", Some(6), |_, args| {
        fn lum(r: f64, g: f64, b: f64) -> f64 {
            fn ch(c: f64) -> f64 {
                let c = c / 255.0;
                if c <= 0.03928 {
                    c / 12.92
                } else {
                    ((c + 0.055) / 1.055).powf(2.4)
                }
            }
            0.2126 * ch(r) + 0.7152 * ch(g) + 0.0722 * ch(b)
        }
        let r1 = match &args[0] {
            Value::Int(n) => *n as f64,
            Value::Float(f) => *f,
            _ => return Err(RuntimeError::new("requires numbers")),
        };
        let g1 = match &args[1] {
            Value::Int(n) => *n as f64,
            Value::Float(f) => *f,
            _ => return Err(RuntimeError::new("requires numbers")),
        };
        let b1 = match &args[2] {
            Value::Int(n) => *n as f64,
            Value::Float(f) => *f,
            _ => return Err(RuntimeError::new("requires numbers")),
        };
        let r2 = match &args[3] {
            Value::Int(n) => *n as f64,
            Value::Float(f) => *f,
            _ => return Err(RuntimeError::new("requires numbers")),
        };
        let g2 = match &args[4] {
            Value::Int(n) => *n as f64,
            Value::Float(f) => *f,
            _ => return Err(RuntimeError::new("requires numbers")),
        };
        let b2 = match &args[5] {
            Value::Int(n) => *n as f64,
            Value::Float(f) => *f,
            _ => return Err(RuntimeError::new("requires numbers")),
        };
        let l1 = lum(r1, g1, b1);
        let l2 = lum(r2, g2, b2);
        let ratio = if l1 > l2 {
            (l1 + 0.05) / (l2 + 0.05)
        } else {
            (l2 + 0.05) / (l1 + 0.05)
        };
        let mut map = std::collections::HashMap::new();
        map.insert("ratio".to_string(), Value::Float(ratio));
        map.insert("aa_normal".to_string(), Value::Bool(ratio >= 4.5));
        map.insert("aa_large".to_string(), Value::Bool(ratio >= 3.0));
        map.insert("aaa_normal".to_string(), Value::Bool(ratio >= 7.0));
        Ok(Value::Map(Rc::new(RefCell::new(map))))
    });
}

// ============================================================================
// PROTOCOL FUNCTIONS (Phase 17)
// ============================================================================

/// Register protocol functions for HTTP, gRPC, WebSocket, Kafka, AMQP, GraphQL
/// Note: Actual async network operations require runtime support.
/// These functions provide protocol information and synchronous utilities.
fn register_protocol(interp: &mut Interpreter) {
    // protocol_info - Get information about supported protocols
    define(interp, "protocol_info", Some(0), |_, _args| {
        let mut map = std::collections::HashMap::new();
        map.insert(
            "http".to_string(),
            Value::Map(Rc::new(RefCell::new({
                let mut m = std::collections::HashMap::new();
                m.insert(
                    "name".to_string(),
                    Value::String(Rc::new("HTTP".to_string())),
                );
                m.insert(
                    "versions".to_string(),
                    Value::Array(Rc::new(RefCell::new(vec![
                        Value::String(Rc::new("1.1".to_string())),
                        Value::String(Rc::new("2".to_string())),
                    ]))),
                );
                m.insert(
                    "methods".to_string(),
                    Value::Array(Rc::new(RefCell::new(vec![
                        Value::String(Rc::new("GET".to_string())),
                        Value::String(Rc::new("POST".to_string())),
                        Value::String(Rc::new("PUT".to_string())),
                        Value::String(Rc::new("DELETE".to_string())),
                        Value::String(Rc::new("PATCH".to_string())),
                        Value::String(Rc::new("HEAD".to_string())),
                        Value::String(Rc::new("OPTIONS".to_string())),
                    ]))),
                );
                m
            }))),
        );
        map.insert(
            "grpc".to_string(),
            Value::Map(Rc::new(RefCell::new({
                let mut m = std::collections::HashMap::new();
                m.insert(
                    "name".to_string(),
                    Value::String(Rc::new("gRPC".to_string())),
                );
                m.insert(
                    "streaming_modes".to_string(),
                    Value::Array(Rc::new(RefCell::new(vec![
                        Value::String(Rc::new("unary".to_string())),
                        Value::String(Rc::new("server_streaming".to_string())),
                        Value::String(Rc::new("client_streaming".to_string())),
                        Value::String(Rc::new("bidirectional".to_string())),
                    ]))),
                );
                m
            }))),
        );
        map.insert(
            "websocket".to_string(),
            Value::Map(Rc::new(RefCell::new({
                let mut m = std::collections::HashMap::new();
                m.insert(
                    "name".to_string(),
                    Value::String(Rc::new("WebSocket".to_string())),
                );
                m.insert(
                    "message_types".to_string(),
                    Value::Array(Rc::new(RefCell::new(vec![
                        Value::String(Rc::new("text".to_string())),
                        Value::String(Rc::new("binary".to_string())),
                        Value::String(Rc::new("ping".to_string())),
                        Value::String(Rc::new("pong".to_string())),
                        Value::String(Rc::new("close".to_string())),
                    ]))),
                );
                m
            }))),
        );
        map.insert(
            "kafka".to_string(),
            Value::Map(Rc::new(RefCell::new({
                let mut m = std::collections::HashMap::new();
                m.insert(
                    "name".to_string(),
                    Value::String(Rc::new("Apache Kafka".to_string())),
                );
                m.insert(
                    "acks".to_string(),
                    Value::Array(Rc::new(RefCell::new(vec![
                        Value::String(Rc::new("none".to_string())),
                        Value::String(Rc::new("leader".to_string())),
                        Value::String(Rc::new("all".to_string())),
                    ]))),
                );
                m
            }))),
        );
        map.insert(
            "amqp".to_string(),
            Value::Map(Rc::new(RefCell::new({
                let mut m = std::collections::HashMap::new();
                m.insert(
                    "name".to_string(),
                    Value::String(Rc::new("AMQP".to_string())),
                );
                m.insert(
                    "exchange_types".to_string(),
                    Value::Array(Rc::new(RefCell::new(vec![
                        Value::String(Rc::new("direct".to_string())),
                        Value::String(Rc::new("fanout".to_string())),
                        Value::String(Rc::new("topic".to_string())),
                        Value::String(Rc::new("headers".to_string())),
                    ]))),
                );
                m
            }))),
        );
        map.insert(
            "graphql".to_string(),
            Value::Map(Rc::new(RefCell::new({
                let mut m = std::collections::HashMap::new();
                m.insert(
                    "name".to_string(),
                    Value::String(Rc::new("GraphQL".to_string())),
                );
                m.insert(
                    "operations".to_string(),
                    Value::Array(Rc::new(RefCell::new(vec![
                        Value::String(Rc::new("query".to_string())),
                        Value::String(Rc::new("mutation".to_string())),
                        Value::String(Rc::new("subscription".to_string())),
                    ]))),
                );
                m
            }))),
        );
        Ok(Value::Map(Rc::new(RefCell::new(map))))
    });

    // http_status_text - Get status text for HTTP status code
    define(interp, "http_status_text", Some(1), |_, args| {
        let code = match &args[0] {
            Value::Int(n) => *n,
            _ => {
                return Err(RuntimeError::new(
                    "http_status_text requires integer status code",
                ))
            }
        };
        let text = match code {
            100 => "Continue",
            101 => "Switching Protocols",
            200 => "OK",
            201 => "Created",
            202 => "Accepted",
            204 => "No Content",
            301 => "Moved Permanently",
            302 => "Found",
            304 => "Not Modified",
            307 => "Temporary Redirect",
            308 => "Permanent Redirect",
            400 => "Bad Request",
            401 => "Unauthorized",
            403 => "Forbidden",
            404 => "Not Found",
            405 => "Method Not Allowed",
            409 => "Conflict",
            422 => "Unprocessable Entity",
            429 => "Too Many Requests",
            500 => "Internal Server Error",
            502 => "Bad Gateway",
            503 => "Service Unavailable",
            504 => "Gateway Timeout",
            _ => "Unknown",
        };
        Ok(Value::String(Rc::new(text.to_string())))
    });

    // http_status_type - Get status type (informational, success, redirect, client_error, server_error)
    define(interp, "http_status_type", Some(1), |_, args| {
        let code = match &args[0] {
            Value::Int(n) => *n,
            _ => {
                return Err(RuntimeError::new(
                    "http_status_type requires integer status code",
                ))
            }
        };
        let status_type = match code {
            100..=199 => "informational",
            200..=299 => "success",
            300..=399 => "redirect",
            400..=499 => "client_error",
            500..=599 => "server_error",
            _ => "unknown",
        };
        Ok(Value::String(Rc::new(status_type.to_string())))
    });

    // grpc_status_text - Get status text for gRPC status code
    define(interp, "grpc_status_text", Some(1), |_, args| {
        let code = match &args[0] {
            Value::Int(n) => *n,
            _ => {
                return Err(RuntimeError::new(
                    "grpc_status_text requires integer status code",
                ))
            }
        };
        let text = match code {
            0 => "OK",
            1 => "CANCELLED",
            2 => "UNKNOWN",
            3 => "INVALID_ARGUMENT",
            4 => "DEADLINE_EXCEEDED",
            5 => "NOT_FOUND",
            6 => "ALREADY_EXISTS",
            7 => "PERMISSION_DENIED",
            8 => "RESOURCE_EXHAUSTED",
            9 => "FAILED_PRECONDITION",
            10 => "ABORTED",
            11 => "OUT_OF_RANGE",
            12 => "UNIMPLEMENTED",
            13 => "INTERNAL",
            14 => "UNAVAILABLE",
            15 => "DATA_LOSS",
            16 => "UNAUTHENTICATED",
            _ => "UNKNOWN",
        };
        Ok(Value::String(Rc::new(text.to_string())))
    });

    // url_parse - Parse a URL into components
    define(interp, "url_parse", Some(1), |_, args| {
        let url_str = match &args[0] {
            Value::String(s) => s.as_str().to_string(),
            _ => return Err(RuntimeError::new("url_parse requires string URL")),
        };

        // Simple URL parsing
        let mut map = std::collections::HashMap::new();

        // Parse scheme
        let (scheme, rest) = if let Some(pos) = url_str.find("://") {
            (url_str[..pos].to_string(), &url_str[pos + 3..])
        } else {
            return Err(RuntimeError::new("Invalid URL: missing scheme"));
        };
        map.insert("scheme".to_string(), Value::String(Rc::new(scheme)));

        // Parse host and path
        let (authority, path_and_rest) = if let Some(pos) = rest.find('/') {
            (&rest[..pos], &rest[pos..])
        } else {
            (rest, "/")
        };

        // Parse host and port
        let (host, port) = if let Some(pos) = authority.rfind(':') {
            if let Ok(p) = authority[pos + 1..].parse::<i64>() {
                (authority[..pos].to_string(), Some(p))
            } else {
                (authority.to_string(), None)
            }
        } else {
            (authority.to_string(), None)
        };
        map.insert("host".to_string(), Value::String(Rc::new(host)));
        map.insert(
            "port".to_string(),
            port.map(Value::Int).unwrap_or(Value::Null),
        );

        // Parse path and query
        let (path, query) = if let Some(pos) = path_and_rest.find('?') {
            (&path_and_rest[..pos], Some(&path_and_rest[pos + 1..]))
        } else {
            (path_and_rest, None)
        };
        map.insert("path".to_string(), Value::String(Rc::new(path.to_string())));
        map.insert(
            "query".to_string(),
            query
                .map(|q| Value::String(Rc::new(q.to_string())))
                .unwrap_or(Value::Null),
        );

        Ok(Value::Map(Rc::new(RefCell::new(map))))
    });

    // url_encode - URL-encode a string
    define(interp, "url_encode", Some(1), |_, args| {
        let s = match &args[0] {
            Value::String(s) => s.as_str(),
            _ => return Err(RuntimeError::new("url_encode requires string")),
        };
        let mut result = String::new();
        for c in s.chars() {
            match c {
                'a'..='z' | 'A'..='Z' | '0'..='9' | '-' | '_' | '.' | '~' => {
                    result.push(c);
                }
                ' ' => result.push_str("%20"),
                _ => {
                    for b in c.to_string().as_bytes() {
                        result.push_str(&format!("%{:02X}", b));
                    }
                }
            }
        }
        Ok(Value::String(Rc::new(result)))
    });

    // url_decode - URL-decode a string
    define(interp, "url_decode", Some(1), |_, args| {
        let s = match &args[0] {
            Value::String(s) => s.as_str().to_string(),
            _ => return Err(RuntimeError::new("url_decode requires string")),
        };
        let mut result = Vec::new();
        let bytes = s.as_bytes();
        let mut i = 0;
        while i < bytes.len() {
            if bytes[i] == b'%' && i + 2 < bytes.len() {
                if let Ok(b) =
                    u8::from_str_radix(&String::from_utf8_lossy(&bytes[i + 1..i + 3]), 16)
                {
                    result.push(b);
                    i += 3;
                    continue;
                }
            } else if bytes[i] == b'+' {
                result.push(b' ');
                i += 1;
                continue;
            }
            result.push(bytes[i]);
            i += 1;
        }
        Ok(Value::String(Rc::new(
            String::from_utf8_lossy(&result).to_string(),
        )))
    });

    // ws_close_code_text - Get text for WebSocket close code
    define(interp, "ws_close_code_text", Some(1), |_, args| {
        let code = match &args[0] {
            Value::Int(n) => *n,
            _ => {
                return Err(RuntimeError::new(
                    "ws_close_code_text requires integer code",
                ))
            }
        };
        let text = match code {
            1000 => "Normal Closure",
            1001 => "Going Away",
            1002 => "Protocol Error",
            1003 => "Unsupported Data",
            1005 => "No Status Received",
            1006 => "Abnormal Closure",
            1007 => "Invalid Payload Data",
            1008 => "Policy Violation",
            1009 => "Message Too Big",
            1010 => "Missing Extension",
            1011 => "Internal Error",
            1015 => "TLS Handshake Failure",
            _ => "Unknown",
        };
        Ok(Value::String(Rc::new(text.to_string())))
    });

    // mime_type - Get MIME type for file extension
    define(interp, "mime_type", Some(1), |_, args| {
        let ext = match &args[0] {
            Value::String(s) => s.as_str().to_lowercase(),
            _ => return Err(RuntimeError::new("mime_type requires string extension")),
        };
        let ext = ext.trim_start_matches('.');
        let mime = match ext {
            "html" | "htm" => "text/html",
            "css" => "text/css",
            "js" | "mjs" => "text/javascript",
            "json" => "application/json",
            "xml" => "application/xml",
            "txt" => "text/plain",
            "csv" => "text/csv",
            "png" => "image/png",
            "jpg" | "jpeg" => "image/jpeg",
            "gif" => "image/gif",
            "svg" => "image/svg+xml",
            "webp" => "image/webp",
            "ico" => "image/x-icon",
            "pdf" => "application/pdf",
            "zip" => "application/zip",
            "gz" | "gzip" => "application/gzip",
            "mp3" => "audio/mpeg",
            "mp4" => "video/mp4",
            "webm" => "video/webm",
            "woff" => "font/woff",
            "woff2" => "font/woff2",
            "ttf" => "font/ttf",
            "otf" => "font/otf",
            "wasm" => "application/wasm",
            "proto" => "application/protobuf",
            _ => "application/octet-stream",
        };
        Ok(Value::String(Rc::new(mime.to_string())))
    });

    // content_type_parse - Parse Content-Type header
    define(interp, "content_type_parse", Some(1), |_, args| {
        let ct = match &args[0] {
            Value::String(s) => s.as_str().to_string(),
            _ => return Err(RuntimeError::new("content_type_parse requires string")),
        };
        let mut map = std::collections::HashMap::new();
        let parts: Vec<&str> = ct.split(';').collect();
        map.insert(
            "media_type".to_string(),
            Value::String(Rc::new(parts[0].trim().to_string())),
        );

        let mut params = std::collections::HashMap::new();
        for part in parts.iter().skip(1) {
            let kv: Vec<&str> = part.splitn(2, '=').collect();
            if kv.len() == 2 {
                let key = kv[0].trim().to_lowercase();
                let value = kv[1].trim().trim_matches('"').to_string();
                params.insert(key, Value::String(Rc::new(value)));
            }
        }
        map.insert(
            "params".to_string(),
            Value::Map(Rc::new(RefCell::new(params))),
        );
        Ok(Value::Map(Rc::new(RefCell::new(map))))
    });
}

// ============================================================================
// PHASE 18: AI AGENT INFRASTRUCTURE
// ============================================================================
// Tools for building AI agents with:
// - Tool registry for introspectable function definitions
// - LLM client for model calls (OpenAI, Claude, local)
// - Agent memory for context and session persistence
// - Planning framework for state machines and goal tracking
// - Vector operations for embeddings and similarity search

/// Global tool registry for agent introspection
thread_local! {
    static TOOL_REGISTRY: RefCell<HashMap<String, ToolDefinition>> = RefCell::new(HashMap::new());
    static AGENT_MEMORY: RefCell<HashMap<String, AgentSession>> = RefCell::new(HashMap::new());
    static STATE_MACHINES: RefCell<HashMap<String, StateMachine>> = RefCell::new(HashMap::new());
}

/// Tool definition for LLM function calling
#[derive(Clone)]
struct ToolDefinition {
    name: String,
    description: String,
    parameters: Vec<ToolParameter>,
    returns: String,
    evidence_in: Evidence,
    evidence_out: Evidence,
    handler: Option<Rc<Function>>,
}

#[derive(Clone)]
struct ToolParameter {
    name: String,
    param_type: String,
    description: String,
    required: bool,
    evidence: Evidence,
}

/// Agent session for memory persistence
#[derive(Clone)]
struct AgentSession {
    id: String,
    context: HashMap<String, Value>,
    history: Vec<(String, String)>, // (role, content)
    created_at: u64,
    last_accessed: u64,
}

/// State machine for planning
#[derive(Clone)]
struct StateMachine {
    name: String,
    current_state: String,
    states: Vec<String>,
    transitions: HashMap<String, Vec<(String, String)>>, // from -> [(to, condition)]
    history: Vec<(String, u64)>,                         // (state, timestamp)
}

// ============================================================================
// TOOL REGISTRY - Introspectable function definitions for LLM tool_choice
// ============================================================================

fn register_agent_tools(interp: &mut Interpreter) {
    // tool_define - Define a tool with metadata for LLM introspection
    // tool_define(name, description, params, returns, handler?)
    define(interp, "tool_define", None, |_interp, args| {
        if args.len() < 4 {
            return Err(RuntimeError::new(
                "tool_define requires at least 4 arguments: name, description, params, returns",
            ));
        }

        let name = match &args[0] {
            Value::String(s) => s.as_str().to_string(),
            _ => return Err(RuntimeError::new("tool name must be a string")),
        };

        let description = match &args[1] {
            Value::String(s) => s.as_str().to_string(),
            _ => return Err(RuntimeError::new("tool description must be a string")),
        };

        // Parse parameters array
        let params = match &args[2] {
            Value::Array(arr) => {
                let arr = arr.borrow();
                let mut params = Vec::new();
                for param in arr.iter() {
                    if let Value::Map(map) = param {
                        let map = map.borrow();
                        let param_name = map
                            .get("name")
                            .and_then(|v| {
                                if let Value::String(s) = v {
                                    Some(s.as_str().to_string())
                                } else {
                                    None
                                }
                            })
                            .unwrap_or_default();
                        let param_type = map
                            .get("type")
                            .and_then(|v| {
                                if let Value::String(s) = v {
                                    Some(s.as_str().to_string())
                                } else {
                                    None
                                }
                            })
                            .unwrap_or_else(|| "any".to_string());
                        let param_desc = map
                            .get("description")
                            .and_then(|v| {
                                if let Value::String(s) = v {
                                    Some(s.as_str().to_string())
                                } else {
                                    None
                                }
                            })
                            .unwrap_or_default();
                        let required = map
                            .get("required")
                            .and_then(|v| {
                                if let Value::Bool(b) = v {
                                    Some(*b)
                                } else {
                                    None
                                }
                            })
                            .unwrap_or(true);
                        let evidence_str = map
                            .get("evidence")
                            .and_then(|v| {
                                if let Value::String(s) = v {
                                    Some(s.as_str())
                                } else {
                                    None
                                }
                            })
                            .unwrap_or("~");
                        let evidence = match evidence_str {
                            "!" => Evidence::Known,
                            "?" => Evidence::Uncertain,
                            "~" => Evidence::Reported,
                            "‽" => Evidence::Paradox,
                            _ => Evidence::Reported,
                        };
                        params.push(ToolParameter {
                            name: param_name,
                            param_type,
                            description: param_desc,
                            required,
                            evidence,
                        });
                    }
                }
                params
            }
            _ => Vec::new(),
        };

        let returns = match &args[3] {
            Value::String(s) => s.as_str().to_string(),
            _ => "any".to_string(),
        };

        let handler = if args.len() > 4 {
            match &args[4] {
                Value::Function(f) => Some(f.clone()),
                _ => None,
            }
        } else {
            None
        };

        let tool = ToolDefinition {
            name: name.clone(),
            description,
            parameters: params,
            returns,
            evidence_in: Evidence::Reported,
            evidence_out: Evidence::Reported,
            handler,
        };

        TOOL_REGISTRY.with(|registry| {
            registry.borrow_mut().insert(name.clone(), tool);
        });

        Ok(Value::String(Rc::new(name)))
    });

    // tool_list - List all registered tools
    define(interp, "tool_list", Some(0), |_, _args| {
        let tools: Vec<Value> = TOOL_REGISTRY.with(|registry| {
            registry
                .borrow()
                .keys()
                .map(|k| Value::String(Rc::new(k.clone())))
                .collect()
        });
        Ok(Value::Array(Rc::new(RefCell::new(tools))))
    });

    // tool_get - Get tool definition by name
    define(interp, "tool_get", Some(1), |_, args| {
        let name = match &args[0] {
            Value::String(s) => s.as_str().to_string(),
            _ => return Err(RuntimeError::new("tool_get requires string name")),
        };

        TOOL_REGISTRY.with(|registry| {
            if let Some(tool) = registry.borrow().get(&name) {
                let mut map = HashMap::new();
                map.insert(
                    "name".to_string(),
                    Value::String(Rc::new(tool.name.clone())),
                );
                map.insert(
                    "description".to_string(),
                    Value::String(Rc::new(tool.description.clone())),
                );
                map.insert(
                    "returns".to_string(),
                    Value::String(Rc::new(tool.returns.clone())),
                );

                let params: Vec<Value> = tool
                    .parameters
                    .iter()
                    .map(|p| {
                        let mut pmap = HashMap::new();
                        pmap.insert("name".to_string(), Value::String(Rc::new(p.name.clone())));
                        pmap.insert(
                            "type".to_string(),
                            Value::String(Rc::new(p.param_type.clone())),
                        );
                        pmap.insert(
                            "description".to_string(),
                            Value::String(Rc::new(p.description.clone())),
                        );
                        pmap.insert("required".to_string(), Value::Bool(p.required));
                        Value::Map(Rc::new(RefCell::new(pmap)))
                    })
                    .collect();
                map.insert(
                    "parameters".to_string(),
                    Value::Array(Rc::new(RefCell::new(params))),
                );

                Ok(Value::Map(Rc::new(RefCell::new(map))))
            } else {
                Ok(Value::Null)
            }
        })
    });

    // tool_schema - Generate OpenAI/Claude compatible tool schema
    define(interp, "tool_schema", Some(1), |_, args| {
        let name = match &args[0] {
            Value::String(s) => s.as_str().to_string(),
            _ => return Err(RuntimeError::new("tool_schema requires string name")),
        };

        TOOL_REGISTRY.with(|registry| {
            if let Some(tool) = registry.borrow().get(&name) {
                // Generate OpenAI function calling schema
                let mut schema = HashMap::new();
                schema.insert(
                    "type".to_string(),
                    Value::String(Rc::new("function".to_string())),
                );

                let mut function = HashMap::new();
                function.insert(
                    "name".to_string(),
                    Value::String(Rc::new(tool.name.clone())),
                );
                function.insert(
                    "description".to_string(),
                    Value::String(Rc::new(tool.description.clone())),
                );

                // Build parameters schema (JSON Schema format)
                let mut params_schema = HashMap::new();
                params_schema.insert(
                    "type".to_string(),
                    Value::String(Rc::new("object".to_string())),
                );

                let mut properties = HashMap::new();
                let mut required: Vec<Value> = Vec::new();

                for param in &tool.parameters {
                    let mut prop = HashMap::new();
                    let json_type = match param.param_type.as_str() {
                        "int" | "i64" | "i32" => "integer",
                        "float" | "f64" | "f32" => "number",
                        "bool" => "boolean",
                        "string" | "str" => "string",
                        "array" | "list" => "array",
                        "map" | "object" => "object",
                        _ => "string",
                    };
                    prop.insert(
                        "type".to_string(),
                        Value::String(Rc::new(json_type.to_string())),
                    );
                    prop.insert(
                        "description".to_string(),
                        Value::String(Rc::new(param.description.clone())),
                    );
                    properties.insert(param.name.clone(), Value::Map(Rc::new(RefCell::new(prop))));

                    if param.required {
                        required.push(Value::String(Rc::new(param.name.clone())));
                    }
                }

                params_schema.insert(
                    "properties".to_string(),
                    Value::Map(Rc::new(RefCell::new(properties))),
                );
                params_schema.insert(
                    "required".to_string(),
                    Value::Array(Rc::new(RefCell::new(required))),
                );

                function.insert(
                    "parameters".to_string(),
                    Value::Map(Rc::new(RefCell::new(params_schema))),
                );
                schema.insert(
                    "function".to_string(),
                    Value::Map(Rc::new(RefCell::new(function))),
                );

                Ok(Value::Map(Rc::new(RefCell::new(schema))))
            } else {
                Err(RuntimeError::new(format!("Tool '{}' not found", name)))
            }
        })
    });

    // tool_schemas_all - Get all tool schemas for LLM
    define(interp, "tool_schemas_all", Some(0), |_, _args| {
        let schemas: Vec<Value> = TOOL_REGISTRY.with(|registry| {
            registry
                .borrow()
                .values()
                .map(|tool| {
                    let mut schema = HashMap::new();
                    schema.insert(
                        "type".to_string(),
                        Value::String(Rc::new("function".to_string())),
                    );

                    let mut function = HashMap::new();
                    function.insert(
                        "name".to_string(),
                        Value::String(Rc::new(tool.name.clone())),
                    );
                    function.insert(
                        "description".to_string(),
                        Value::String(Rc::new(tool.description.clone())),
                    );

                    let mut params_schema = HashMap::new();
                    params_schema.insert(
                        "type".to_string(),
                        Value::String(Rc::new("object".to_string())),
                    );

                    let mut properties = HashMap::new();
                    let mut required: Vec<Value> = Vec::new();

                    for param in &tool.parameters {
                        let mut prop = HashMap::new();
                        let json_type = match param.param_type.as_str() {
                            "int" | "i64" | "i32" => "integer",
                            "float" | "f64" | "f32" => "number",
                            "bool" => "boolean",
                            _ => "string",
                        };
                        prop.insert(
                            "type".to_string(),
                            Value::String(Rc::new(json_type.to_string())),
                        );
                        prop.insert(
                            "description".to_string(),
                            Value::String(Rc::new(param.description.clone())),
                        );
                        properties
                            .insert(param.name.clone(), Value::Map(Rc::new(RefCell::new(prop))));
                        if param.required {
                            required.push(Value::String(Rc::new(param.name.clone())));
                        }
                    }

                    params_schema.insert(
                        "properties".to_string(),
                        Value::Map(Rc::new(RefCell::new(properties))),
                    );
                    params_schema.insert(
                        "required".to_string(),
                        Value::Array(Rc::new(RefCell::new(required))),
                    );
                    function.insert(
                        "parameters".to_string(),
                        Value::Map(Rc::new(RefCell::new(params_schema))),
                    );
                    schema.insert(
                        "function".to_string(),
                        Value::Map(Rc::new(RefCell::new(function))),
                    );

                    Value::Map(Rc::new(RefCell::new(schema)))
                })
                .collect()
        });
        Ok(Value::Array(Rc::new(RefCell::new(schemas))))
    });

    // tool_call - Execute a registered tool by name
    define(interp, "tool_call", None, |interp, args| {
        if args.is_empty() {
            return Err(RuntimeError::new("tool_call requires at least tool name"));
        }

        let name = match &args[0] {
            Value::String(s) => s.as_str().to_string(),
            _ => {
                return Err(RuntimeError::new(
                    "tool_call first argument must be tool name",
                ))
            }
        };

        let tool_args: Vec<Value> = args.into_iter().skip(1).collect();

        TOOL_REGISTRY.with(|registry| {
            if let Some(tool) = registry.borrow().get(&name) {
                if let Some(handler) = &tool.handler {
                    // Execute the handler function
                    let result = interp.call_function(handler.as_ref(), tool_args)?;
                    // Wrap result with reported evidence (external call)
                    Ok(Value::Evidential {
                        value: Box::new(result),
                        evidence: Evidence::Reported,
                    })
                } else {
                    Err(RuntimeError::new(format!("Tool '{}' has no handler", name)))
                }
            } else {
                Err(RuntimeError::new(format!("Tool '{}' not found", name)))
            }
        })
    });

    // tool_remove - Remove a tool from registry
    define(interp, "tool_remove", Some(1), |_, args| {
        let name = match &args[0] {
            Value::String(s) => s.as_str().to_string(),
            _ => return Err(RuntimeError::new("tool_remove requires string name")),
        };

        TOOL_REGISTRY.with(|registry| {
            let removed = registry.borrow_mut().remove(&name).is_some();
            Ok(Value::Bool(removed))
        })
    });

    // tool_clear - Clear all registered tools
    define(interp, "tool_clear", Some(0), |_, _args| {
        TOOL_REGISTRY.with(|registry| {
            registry.borrow_mut().clear();
        });
        Ok(Value::Null)
    });
}

// ============================================================================
// LLM CLIENT - AI model interaction with evidentiality
// ============================================================================

fn register_agent_llm(interp: &mut Interpreter) {
    // llm_message - Create a chat message
    define(interp, "llm_message", Some(2), |_, args| {
        let role = match &args[0] {
            Value::String(s) => s.as_str().to_string(),
            _ => return Err(RuntimeError::new("llm_message role must be string")),
        };
        let content = match &args[1] {
            Value::String(s) => s.as_str().to_string(),
            _ => return Err(RuntimeError::new("llm_message content must be string")),
        };

        let mut map = HashMap::new();
        map.insert("role".to_string(), Value::String(Rc::new(role)));
        map.insert("content".to_string(), Value::String(Rc::new(content)));
        Ok(Value::Map(Rc::new(RefCell::new(map))))
    });

    // llm_messages - Create a messages array
    define(interp, "llm_messages", None, |_, args| {
        let messages: Vec<Value> = args.into_iter().collect();
        Ok(Value::Array(Rc::new(RefCell::new(messages))))
    });

    // llm_request - Build an LLM API request (returns reported~ since it's external)
    define(interp, "llm_request", None, |_, args| {
        if args.is_empty() {
            return Err(RuntimeError::new("llm_request requires provider"));
        }

        let provider = match &args[0] {
            Value::String(s) => s.as_str().to_string(),
            _ => return Err(RuntimeError::new("provider must be string")),
        };

        let mut request = HashMap::new();
        request.insert(
            "provider".to_string(),
            Value::String(Rc::new(provider.clone())),
        );

        // Default models per provider
        let default_model = match provider.as_str() {
            "openai" => "gpt-4-turbo-preview",
            "anthropic" | "claude" => "claude-3-opus-20240229",
            "google" | "gemini" => "gemini-pro",
            "mistral" => "mistral-large-latest",
            "ollama" | "local" => "llama2",
            _ => "gpt-4",
        };
        request.insert(
            "model".to_string(),
            Value::String(Rc::new(default_model.to_string())),
        );

        // Parse optional arguments
        for (i, arg) in args.iter().enumerate().skip(1) {
            if let Value::Map(map) = arg {
                let map = map.borrow();
                for (k, v) in map.iter() {
                    request.insert(k.clone(), v.clone());
                }
            } else if i == 1 {
                // Second arg is model
                if let Value::String(s) = arg {
                    request.insert("model".to_string(), Value::String(s.clone()));
                }
            }
        }

        // Default values
        if !request.contains_key("temperature") {
            request.insert("temperature".to_string(), Value::Float(0.7));
        }
        if !request.contains_key("max_tokens") {
            request.insert("max_tokens".to_string(), Value::Int(4096));
        }

        Ok(Value::Map(Rc::new(RefCell::new(request))))
    });

    // llm_with_tools - Add tools to a request
    define(interp, "llm_with_tools", Some(2), |_, args| {
        let request = match &args[0] {
            Value::Map(m) => m.clone(),
            _ => {
                return Err(RuntimeError::new(
                    "llm_with_tools first arg must be request map",
                ))
            }
        };

        let tools = match &args[1] {
            Value::Array(arr) => arr.clone(),
            _ => {
                return Err(RuntimeError::new(
                    "llm_with_tools second arg must be tools array",
                ))
            }
        };

        request
            .borrow_mut()
            .insert("tools".to_string(), Value::Array(tools));
        request.borrow_mut().insert(
            "tool_choice".to_string(),
            Value::String(Rc::new("auto".to_string())),
        );

        Ok(Value::Map(request))
    });

    // llm_with_system - Add system prompt to request
    define(interp, "llm_with_system", Some(2), |_, args| {
        let request = match &args[0] {
            Value::Map(m) => m.clone(),
            _ => {
                return Err(RuntimeError::new(
                    "llm_with_system first arg must be request map",
                ))
            }
        };

        let system = match &args[1] {
            Value::String(s) => s.clone(),
            _ => {
                return Err(RuntimeError::new(
                    "llm_with_system second arg must be string",
                ))
            }
        };

        request
            .borrow_mut()
            .insert("system".to_string(), Value::String(system));
        Ok(Value::Map(request))
    });

    // llm_with_messages - Add messages to request
    define(interp, "llm_with_messages", Some(2), |_, args| {
        let request = match &args[0] {
            Value::Map(m) => m.clone(),
            _ => {
                return Err(RuntimeError::new(
                    "llm_with_messages first arg must be request map",
                ))
            }
        };

        let messages = match &args[1] {
            Value::Array(arr) => arr.clone(),
            _ => {
                return Err(RuntimeError::new(
                    "llm_with_messages second arg must be messages array",
                ))
            }
        };

        request
            .borrow_mut()
            .insert("messages".to_string(), Value::Array(messages));
        Ok(Value::Map(request))
    });

    // llm_send - Send request (simulated - returns reported~ data)
    // In production, this would make actual HTTP calls
    define(interp, "llm_send", Some(1), |_, args| {
        let request = match &args[0] {
            Value::Map(m) => m.borrow().clone(),
            _ => return Err(RuntimeError::new("llm_send requires request map")),
        };

        let provider = request
            .get("provider")
            .and_then(|v| {
                if let Value::String(s) = v {
                    Some(s.as_str().to_string())
                } else {
                    None
                }
            })
            .unwrap_or_else(|| "unknown".to_string());

        let model = request
            .get("model")
            .and_then(|v| {
                if let Value::String(s) = v {
                    Some(s.as_str().to_string())
                } else {
                    None
                }
            })
            .unwrap_or_else(|| "unknown".to_string());

        // Build response structure (simulated)
        let mut response = HashMap::new();
        response.insert(
            "id".to_string(),
            Value::String(Rc::new(format!("msg_{}", Uuid::new_v4()))),
        );
        response.insert("provider".to_string(), Value::String(Rc::new(provider)));
        response.insert("model".to_string(), Value::String(Rc::new(model)));
        response.insert(
            "created".to_string(),
            Value::Int(
                std::time::SystemTime::now()
                    .duration_since(std::time::UNIX_EPOCH)
                    .unwrap_or_default()
                    .as_secs() as i64,
            ),
        );

        // Check if this would be a tool call
        if request.contains_key("tools") {
            response.insert(
                "type".to_string(),
                Value::String(Rc::new("tool_use".to_string())),
            );
            response.insert(
                "tool_name".to_string(),
                Value::String(Rc::new("pending".to_string())),
            );
            response.insert(
                "tool_input".to_string(),
                Value::Map(Rc::new(RefCell::new(HashMap::new()))),
            );
        } else {
            response.insert(
                "type".to_string(),
                Value::String(Rc::new("text".to_string())),
            );
            response.insert(
                "content".to_string(),
                Value::String(Rc::new(
                    "[LLM Response - Connect to actual API for real responses]".to_string(),
                )),
            );
        }

        // Usage stats (simulated)
        let mut usage = HashMap::new();
        usage.insert("input_tokens".to_string(), Value::Int(0));
        usage.insert("output_tokens".to_string(), Value::Int(0));
        response.insert(
            "usage".to_string(),
            Value::Map(Rc::new(RefCell::new(usage))),
        );

        // Return as reported evidence (external data)
        Ok(Value::Evidential {
            value: Box::new(Value::Map(Rc::new(RefCell::new(response)))),
            evidence: Evidence::Reported,
        })
    });

    // llm_parse_tool_call - Parse tool call from LLM response
    define(interp, "llm_parse_tool_call", Some(1), |_, args| {
        let response = match &args[0] {
            Value::Map(m) => m.borrow().clone(),
            Value::Evidential { value, .. } => {
                if let Value::Map(m) = value.as_ref() {
                    m.borrow().clone()
                } else {
                    return Err(RuntimeError::new(
                        "llm_parse_tool_call requires map response",
                    ));
                }
            }
            _ => {
                return Err(RuntimeError::new(
                    "llm_parse_tool_call requires response map",
                ))
            }
        };

        let resp_type = response
            .get("type")
            .and_then(|v| {
                if let Value::String(s) = v {
                    Some(s.as_str().to_string())
                } else {
                    None
                }
            })
            .unwrap_or_default();

        if resp_type == "tool_use" {
            let tool_name = response
                .get("tool_name")
                .and_then(|v| {
                    if let Value::String(s) = v {
                        Some(s.as_str().to_string())
                    } else {
                        None
                    }
                })
                .unwrap_or_default();

            let tool_input = response.get("tool_input").cloned().unwrap_or(Value::Null);

            let mut result = HashMap::new();
            result.insert("is_tool_call".to_string(), Value::Bool(true));
            result.insert("tool_name".to_string(), Value::String(Rc::new(tool_name)));
            result.insert("tool_input".to_string(), tool_input);
            Ok(Value::Map(Rc::new(RefCell::new(result))))
        } else {
            let mut result = HashMap::new();
            result.insert("is_tool_call".to_string(), Value::Bool(false));
            result.insert(
                "content".to_string(),
                response.get("content").cloned().unwrap_or(Value::Null),
            );
            Ok(Value::Map(Rc::new(RefCell::new(result))))
        }
    });

    // llm_extract - Extract structured data (returns uncertain? - needs validation)
    define(interp, "llm_extract", Some(2), |_, args| {
        let _response = match &args[0] {
            Value::Map(m) => m.borrow().clone(),
            Value::Evidential { value, .. } => {
                if let Value::Map(m) = value.as_ref() {
                    m.borrow().clone()
                } else {
                    return Err(RuntimeError::new("llm_extract requires response"));
                }
            }
            _ => return Err(RuntimeError::new("llm_extract requires response")),
        };

        let _schema = match &args[1] {
            Value::Map(m) => m.borrow().clone(),
            _ => return Err(RuntimeError::new("llm_extract requires schema map")),
        };

        // In production, this would parse the LLM output against the schema
        // For now, return uncertain evidence since extraction may fail
        let mut result = HashMap::new();
        result.insert("success".to_string(), Value::Bool(true));
        result.insert("data".to_string(), Value::Null);
        result.insert(
            "errors".to_string(),
            Value::Array(Rc::new(RefCell::new(Vec::new()))),
        );

        Ok(Value::Evidential {
            value: Box::new(Value::Map(Rc::new(RefCell::new(result)))),
            evidence: Evidence::Uncertain,
        })
    });

    // prompt_template - Create a prompt template with variable substitution
    define(interp, "prompt_template", Some(1), |_, args| {
        let template = match &args[0] {
            Value::String(s) => s.as_str().to_string(),
            _ => return Err(RuntimeError::new("prompt_template requires string")),
        };

        // Parse template to extract variable names
        let mut variables = Vec::new();
        let mut in_var = false;
        let mut var_name = String::new();

        for c in template.chars() {
            match c {
                '{' if !in_var => {
                    in_var = true;
                    var_name.clear();
                }
                '}' if in_var => {
                    if !var_name.is_empty() {
                        variables.push(Value::String(Rc::new(var_name.clone())));
                    }
                    in_var = false;
                }
                _ if in_var => {
                    var_name.push(c);
                }
                _ => {}
            }
        }

        let mut result = HashMap::new();
        result.insert("template".to_string(), Value::String(Rc::new(template)));
        result.insert(
            "variables".to_string(),
            Value::Array(Rc::new(RefCell::new(variables))),
        );
        Ok(Value::Map(Rc::new(RefCell::new(result))))
    });

    // prompt_render - Render a template with values
    define(interp, "prompt_render", Some(2), |_, args| {
        let template_obj = match &args[0] {
            Value::Map(m) => m.borrow().clone(),
            Value::String(s) => {
                let mut m = HashMap::new();
                m.insert("template".to_string(), Value::String(s.clone()));
                m
            }
            _ => return Err(RuntimeError::new("prompt_render requires template")),
        };

        let values = match &args[1] {
            Value::Map(m) => m.borrow().clone(),
            _ => return Err(RuntimeError::new("prompt_render requires values map")),
        };

        let template = template_obj
            .get("template")
            .and_then(|v| {
                if let Value::String(s) = v {
                    Some(s.as_str().to_string())
                } else {
                    None
                }
            })
            .unwrap_or_default();

        let mut result = template;
        for (key, value) in values.iter() {
            let value_str = match value {
                Value::String(s) => s.as_str().to_string(),
                Value::Int(n) => n.to_string(),
                Value::Float(f) => f.to_string(),
                Value::Bool(b) => b.to_string(),
                _ => format!("{}", value),
            };
            result = result.replace(&format!("{{{}}}", key), &value_str);
        }

        Ok(Value::String(Rc::new(result)))
    });
}

// ============================================================================
// AGENT MEMORY - Session and context persistence
// ============================================================================

fn register_agent_memory(interp: &mut Interpreter) {
    // memory_session - Create or get a session
    define(interp, "memory_session", Some(1), |_, args| {
        let session_id = match &args[0] {
            Value::String(s) => s.as_str().to_string(),
            _ => return Err(RuntimeError::new("memory_session requires string id")),
        };

        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap_or_default()
            .as_secs();

        AGENT_MEMORY.with(|memory| {
            let mut mem = memory.borrow_mut();
            if !mem.contains_key(&session_id) {
                mem.insert(
                    session_id.clone(),
                    AgentSession {
                        id: session_id.clone(),
                        context: HashMap::new(),
                        history: Vec::new(),
                        created_at: now,
                        last_accessed: now,
                    },
                );
            } else if let Some(session) = mem.get_mut(&session_id) {
                session.last_accessed = now;
            }
        });

        let mut result = HashMap::new();
        result.insert("id".to_string(), Value::String(Rc::new(session_id)));
        result.insert("created_at".to_string(), Value::Int(now as i64));
        Ok(Value::Map(Rc::new(RefCell::new(result))))
    });

    // memory_set - Store a value in session context
    define(interp, "memory_set", Some(3), |_, args| {
        let session_id = match &args[0] {
            Value::String(s) => s.as_str().to_string(),
            Value::Map(m) => m
                .borrow()
                .get("id")
                .and_then(|v| {
                    if let Value::String(s) = v {
                        Some(s.as_str().to_string())
                    } else {
                        None
                    }
                })
                .ok_or_else(|| RuntimeError::new("Invalid session"))?,
            _ => return Err(RuntimeError::new("memory_set requires session")),
        };

        let key = match &args[1] {
            Value::String(s) => s.as_str().to_string(),
            _ => return Err(RuntimeError::new("memory_set key must be string")),
        };

        let value = args[2].clone();

        AGENT_MEMORY.with(|memory| {
            if let Some(session) = memory.borrow_mut().get_mut(&session_id) {
                session.context.insert(key, value);
                session.last_accessed = std::time::SystemTime::now()
                    .duration_since(std::time::UNIX_EPOCH)
                    .unwrap_or_default()
                    .as_secs();
                Ok(Value::Bool(true))
            } else {
                Err(RuntimeError::new(format!(
                    "Session '{}' not found",
                    session_id
                )))
            }
        })
    });

    // memory_get - Retrieve a value from session context
    define(interp, "memory_get", Some(2), |_, args| {
        let session_id = match &args[0] {
            Value::String(s) => s.as_str().to_string(),
            Value::Map(m) => m
                .borrow()
                .get("id")
                .and_then(|v| {
                    if let Value::String(s) = v {
                        Some(s.as_str().to_string())
                    } else {
                        None
                    }
                })
                .ok_or_else(|| RuntimeError::new("Invalid session"))?,
            _ => return Err(RuntimeError::new("memory_get requires session")),
        };

        let key = match &args[1] {
            Value::String(s) => s.as_str().to_string(),
            _ => return Err(RuntimeError::new("memory_get key must be string")),
        };

        AGENT_MEMORY.with(|memory| {
            if let Some(session) = memory.borrow().get(&session_id) {
                Ok(session.context.get(&key).cloned().unwrap_or(Value::Null))
            } else {
                Ok(Value::Null)
            }
        })
    });

    // memory_history_add - Add to conversation history
    define(interp, "memory_history_add", Some(3), |_, args| {
        let session_id = match &args[0] {
            Value::String(s) => s.as_str().to_string(),
            Value::Map(m) => m
                .borrow()
                .get("id")
                .and_then(|v| {
                    if let Value::String(s) = v {
                        Some(s.as_str().to_string())
                    } else {
                        None
                    }
                })
                .ok_or_else(|| RuntimeError::new("Invalid session"))?,
            _ => return Err(RuntimeError::new("memory_history_add requires session")),
        };

        let role = match &args[1] {
            Value::String(s) => s.as_str().to_string(),
            _ => return Err(RuntimeError::new("role must be string")),
        };

        let content = match &args[2] {
            Value::String(s) => s.as_str().to_string(),
            _ => return Err(RuntimeError::new("content must be string")),
        };

        AGENT_MEMORY.with(|memory| {
            if let Some(session) = memory.borrow_mut().get_mut(&session_id) {
                session.history.push((role, content));
                session.last_accessed = std::time::SystemTime::now()
                    .duration_since(std::time::UNIX_EPOCH)
                    .unwrap_or_default()
                    .as_secs();
                Ok(Value::Int(session.history.len() as i64))
            } else {
                Err(RuntimeError::new(format!(
                    "Session '{}' not found",
                    session_id
                )))
            }
        })
    });

    // memory_history_get - Get conversation history
    define(interp, "memory_history_get", None, |_, args| {
        if args.is_empty() {
            return Err(RuntimeError::new("memory_history_get requires session"));
        }

        let session_id = match &args[0] {
            Value::String(s) => s.as_str().to_string(),
            Value::Map(m) => m
                .borrow()
                .get("id")
                .and_then(|v| {
                    if let Value::String(s) = v {
                        Some(s.as_str().to_string())
                    } else {
                        None
                    }
                })
                .ok_or_else(|| RuntimeError::new("Invalid session"))?,
            _ => return Err(RuntimeError::new("memory_history_get requires session")),
        };

        let limit = if args.len() > 1 {
            match &args[1] {
                Value::Int(n) => Some(*n as usize),
                _ => None,
            }
        } else {
            None
        };

        AGENT_MEMORY.with(|memory| {
            if let Some(session) = memory.borrow().get(&session_id) {
                let history: Vec<Value> = session
                    .history
                    .iter()
                    .rev()
                    .take(limit.unwrap_or(usize::MAX))
                    .rev()
                    .map(|(role, content)| {
                        let mut msg = HashMap::new();
                        msg.insert("role".to_string(), Value::String(Rc::new(role.clone())));
                        msg.insert(
                            "content".to_string(),
                            Value::String(Rc::new(content.clone())),
                        );
                        Value::Map(Rc::new(RefCell::new(msg)))
                    })
                    .collect();
                Ok(Value::Array(Rc::new(RefCell::new(history))))
            } else {
                Ok(Value::Array(Rc::new(RefCell::new(Vec::new()))))
            }
        })
    });

    // memory_context_all - Get all context for a session
    define(interp, "memory_context_all", Some(1), |_, args| {
        let session_id = match &args[0] {
            Value::String(s) => s.as_str().to_string(),
            Value::Map(m) => m
                .borrow()
                .get("id")
                .and_then(|v| {
                    if let Value::String(s) = v {
                        Some(s.as_str().to_string())
                    } else {
                        None
                    }
                })
                .ok_or_else(|| RuntimeError::new("Invalid session"))?,
            _ => return Err(RuntimeError::new("memory_context_all requires session")),
        };

        AGENT_MEMORY.with(|memory| {
            if let Some(session) = memory.borrow().get(&session_id) {
                let context: HashMap<String, Value> = session.context.clone();
                Ok(Value::Map(Rc::new(RefCell::new(context))))
            } else {
                Ok(Value::Map(Rc::new(RefCell::new(HashMap::new()))))
            }
        })
    });

    // memory_clear - Clear session data
    define(interp, "memory_clear", Some(1), |_, args| {
        let session_id = match &args[0] {
            Value::String(s) => s.as_str().to_string(),
            Value::Map(m) => m
                .borrow()
                .get("id")
                .and_then(|v| {
                    if let Value::String(s) = v {
                        Some(s.as_str().to_string())
                    } else {
                        None
                    }
                })
                .ok_or_else(|| RuntimeError::new("Invalid session"))?,
            _ => return Err(RuntimeError::new("memory_clear requires session")),
        };

        AGENT_MEMORY.with(|memory| {
            let removed = memory.borrow_mut().remove(&session_id).is_some();
            Ok(Value::Bool(removed))
        })
    });

    // memory_sessions_list - List all active sessions
    define(interp, "memory_sessions_list", Some(0), |_, _args| {
        let sessions: Vec<Value> = AGENT_MEMORY.with(|memory| {
            memory
                .borrow()
                .values()
                .map(|session| {
                    let mut info = HashMap::new();
                    info.insert("id".to_string(), Value::String(Rc::new(session.id.clone())));
                    info.insert(
                        "created_at".to_string(),
                        Value::Int(session.created_at as i64),
                    );
                    info.insert(
                        "last_accessed".to_string(),
                        Value::Int(session.last_accessed as i64),
                    );
                    info.insert(
                        "context_keys".to_string(),
                        Value::Int(session.context.len() as i64),
                    );
                    info.insert(
                        "history_length".to_string(),
                        Value::Int(session.history.len() as i64),
                    );
                    Value::Map(Rc::new(RefCell::new(info)))
                })
                .collect()
        });
        Ok(Value::Array(Rc::new(RefCell::new(sessions))))
    });
}

// ============================================================================
// PLANNING FRAMEWORK - State machines and goal tracking
// ============================================================================

fn register_agent_planning(interp: &mut Interpreter) {
    // plan_state_machine - Create a new state machine
    define(interp, "plan_state_machine", Some(2), |_, args| {
        let name = match &args[0] {
            Value::String(s) => s.as_str().to_string(),
            _ => return Err(RuntimeError::new("plan_state_machine name must be string")),
        };

        let states = match &args[1] {
            Value::Array(arr) => arr
                .borrow()
                .iter()
                .filter_map(|v| {
                    if let Value::String(s) = v {
                        Some(s.as_str().to_string())
                    } else {
                        None
                    }
                })
                .collect::<Vec<_>>(),
            _ => return Err(RuntimeError::new("plan_state_machine states must be array")),
        };

        if states.is_empty() {
            return Err(RuntimeError::new(
                "State machine must have at least one state",
            ));
        }

        let initial_state = states[0].clone();
        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap_or_default()
            .as_secs();

        let machine = StateMachine {
            name: name.clone(),
            current_state: initial_state.clone(),
            states,
            transitions: HashMap::new(),
            history: vec![(initial_state, now)],
        };

        STATE_MACHINES.with(|machines| {
            machines.borrow_mut().insert(name.clone(), machine);
        });

        let mut result = HashMap::new();
        result.insert("name".to_string(), Value::String(Rc::new(name)));
        result.insert(
            "type".to_string(),
            Value::String(Rc::new("state_machine".to_string())),
        );
        Ok(Value::Map(Rc::new(RefCell::new(result))))
    });

    // plan_add_transition - Add a transition rule
    define(interp, "plan_add_transition", Some(3), |_, args| {
        let machine_name = match &args[0] {
            Value::String(s) => s.as_str().to_string(),
            Value::Map(m) => m
                .borrow()
                .get("name")
                .and_then(|v| {
                    if let Value::String(s) = v {
                        Some(s.as_str().to_string())
                    } else {
                        None
                    }
                })
                .ok_or_else(|| RuntimeError::new("Invalid state machine"))?,
            _ => return Err(RuntimeError::new("plan_add_transition requires machine")),
        };

        let from_state = match &args[1] {
            Value::String(s) => s.as_str().to_string(),
            _ => return Err(RuntimeError::new("from_state must be string")),
        };

        let to_state = match &args[2] {
            Value::String(s) => s.as_str().to_string(),
            _ => return Err(RuntimeError::new("to_state must be string")),
        };

        STATE_MACHINES.with(|machines| {
            if let Some(machine) = machines.borrow_mut().get_mut(&machine_name) {
                // Validate states exist
                if !machine.states.contains(&from_state) {
                    return Err(RuntimeError::new(format!(
                        "State '{}' not in machine",
                        from_state
                    )));
                }
                if !machine.states.contains(&to_state) {
                    return Err(RuntimeError::new(format!(
                        "State '{}' not in machine",
                        to_state
                    )));
                }

                machine
                    .transitions
                    .entry(from_state)
                    .or_insert_with(Vec::new)
                    .push((to_state, "".to_string()));

                Ok(Value::Bool(true))
            } else {
                Err(RuntimeError::new(format!(
                    "State machine '{}' not found",
                    machine_name
                )))
            }
        })
    });

    // plan_current_state - Get current state
    define(interp, "plan_current_state", Some(1), |_, args| {
        let machine_name = match &args[0] {
            Value::String(s) => s.as_str().to_string(),
            Value::Map(m) => m
                .borrow()
                .get("name")
                .and_then(|v| {
                    if let Value::String(s) = v {
                        Some(s.as_str().to_string())
                    } else {
                        None
                    }
                })
                .ok_or_else(|| RuntimeError::new("Invalid state machine"))?,
            _ => return Err(RuntimeError::new("plan_current_state requires machine")),
        };

        STATE_MACHINES.with(|machines| {
            if let Some(machine) = machines.borrow().get(&machine_name) {
                Ok(Value::String(Rc::new(machine.current_state.clone())))
            } else {
                Err(RuntimeError::new(format!(
                    "State machine '{}' not found",
                    machine_name
                )))
            }
        })
    });

    // plan_transition - Execute a state transition
    define(interp, "plan_transition", Some(2), |_, args| {
        let machine_name = match &args[0] {
            Value::String(s) => s.as_str().to_string(),
            Value::Map(m) => m
                .borrow()
                .get("name")
                .and_then(|v| {
                    if let Value::String(s) = v {
                        Some(s.as_str().to_string())
                    } else {
                        None
                    }
                })
                .ok_or_else(|| RuntimeError::new("Invalid state machine"))?,
            _ => return Err(RuntimeError::new("plan_transition requires machine")),
        };

        let to_state = match &args[1] {
            Value::String(s) => s.as_str().to_string(),
            _ => return Err(RuntimeError::new("to_state must be string")),
        };

        STATE_MACHINES.with(|machines| {
            if let Some(machine) = machines.borrow_mut().get_mut(&machine_name) {
                let current = machine.current_state.clone();

                // Check if transition is valid
                let valid = machine
                    .transitions
                    .get(&current)
                    .map(|transitions| transitions.iter().any(|(to, _)| to == &to_state))
                    .unwrap_or(false);

                if valid || machine.states.contains(&to_state) {
                    let now = std::time::SystemTime::now()
                        .duration_since(std::time::UNIX_EPOCH)
                        .unwrap_or_default()
                        .as_secs();

                    machine.current_state = to_state.clone();
                    machine.history.push((to_state.clone(), now));

                    let mut result = HashMap::new();
                    result.insert("success".to_string(), Value::Bool(true));
                    result.insert("from".to_string(), Value::String(Rc::new(current)));
                    result.insert("to".to_string(), Value::String(Rc::new(to_state)));
                    Ok(Value::Map(Rc::new(RefCell::new(result))))
                } else {
                    let mut result = HashMap::new();
                    result.insert("success".to_string(), Value::Bool(false));
                    result.insert(
                        "error".to_string(),
                        Value::String(Rc::new(format!(
                            "No valid transition from '{}' to '{}'",
                            current, to_state
                        ))),
                    );
                    Ok(Value::Map(Rc::new(RefCell::new(result))))
                }
            } else {
                Err(RuntimeError::new(format!(
                    "State machine '{}' not found",
                    machine_name
                )))
            }
        })
    });

    // plan_can_transition - Check if a transition is valid
    define(interp, "plan_can_transition", Some(2), |_, args| {
        let machine_name = match &args[0] {
            Value::String(s) => s.as_str().to_string(),
            Value::Map(m) => m
                .borrow()
                .get("name")
                .and_then(|v| {
                    if let Value::String(s) = v {
                        Some(s.as_str().to_string())
                    } else {
                        None
                    }
                })
                .ok_or_else(|| RuntimeError::new("Invalid state machine"))?,
            _ => return Err(RuntimeError::new("plan_can_transition requires machine")),
        };

        let to_state = match &args[1] {
            Value::String(s) => s.as_str().to_string(),
            _ => return Err(RuntimeError::new("to_state must be string")),
        };

        STATE_MACHINES.with(|machines| {
            if let Some(machine) = machines.borrow().get(&machine_name) {
                let current = &machine.current_state;
                let can = machine
                    .transitions
                    .get(current)
                    .map(|transitions| transitions.iter().any(|(to, _)| to == &to_state))
                    .unwrap_or(false);
                Ok(Value::Bool(can))
            } else {
                Ok(Value::Bool(false))
            }
        })
    });

    // plan_available_transitions - Get available transitions from current state
    define(interp, "plan_available_transitions", Some(1), |_, args| {
        let machine_name = match &args[0] {
            Value::String(s) => s.as_str().to_string(),
            Value::Map(m) => m
                .borrow()
                .get("name")
                .and_then(|v| {
                    if let Value::String(s) = v {
                        Some(s.as_str().to_string())
                    } else {
                        None
                    }
                })
                .ok_or_else(|| RuntimeError::new("Invalid state machine"))?,
            _ => {
                return Err(RuntimeError::new(
                    "plan_available_transitions requires machine",
                ))
            }
        };

        STATE_MACHINES.with(|machines| {
            if let Some(machine) = machines.borrow().get(&machine_name) {
                let current = &machine.current_state;
                let available: Vec<Value> = machine
                    .transitions
                    .get(current)
                    .map(|transitions| {
                        transitions
                            .iter()
                            .map(|(to, _)| Value::String(Rc::new(to.clone())))
                            .collect()
                    })
                    .unwrap_or_default();
                Ok(Value::Array(Rc::new(RefCell::new(available))))
            } else {
                Ok(Value::Array(Rc::new(RefCell::new(Vec::new()))))
            }
        })
    });

    // plan_history - Get state transition history
    define(interp, "plan_history", Some(1), |_, args| {
        let machine_name = match &args[0] {
            Value::String(s) => s.as_str().to_string(),
            Value::Map(m) => m
                .borrow()
                .get("name")
                .and_then(|v| {
                    if let Value::String(s) = v {
                        Some(s.as_str().to_string())
                    } else {
                        None
                    }
                })
                .ok_or_else(|| RuntimeError::new("Invalid state machine"))?,
            _ => return Err(RuntimeError::new("plan_history requires machine")),
        };

        STATE_MACHINES.with(|machines| {
            if let Some(machine) = machines.borrow().get(&machine_name) {
                let history: Vec<Value> = machine
                    .history
                    .iter()
                    .map(|(state, timestamp)| {
                        let mut entry = HashMap::new();
                        entry.insert("state".to_string(), Value::String(Rc::new(state.clone())));
                        entry.insert("timestamp".to_string(), Value::Int(*timestamp as i64));
                        Value::Map(Rc::new(RefCell::new(entry)))
                    })
                    .collect();
                Ok(Value::Array(Rc::new(RefCell::new(history))))
            } else {
                Ok(Value::Array(Rc::new(RefCell::new(Vec::new()))))
            }
        })
    });

    // plan_goal - Create a goal with success criteria
    define(interp, "plan_goal", Some(2), |_, args| {
        let name = match &args[0] {
            Value::String(s) => s.as_str().to_string(),
            _ => return Err(RuntimeError::new("plan_goal name must be string")),
        };

        let criteria = args[1].clone();

        let mut goal = HashMap::new();
        goal.insert("name".to_string(), Value::String(Rc::new(name)));
        goal.insert("criteria".to_string(), criteria);
        goal.insert(
            "status".to_string(),
            Value::String(Rc::new("pending".to_string())),
        );
        goal.insert("progress".to_string(), Value::Float(0.0));
        goal.insert(
            "created_at".to_string(),
            Value::Int(
                std::time::SystemTime::now()
                    .duration_since(std::time::UNIX_EPOCH)
                    .unwrap_or_default()
                    .as_secs() as i64,
            ),
        );

        Ok(Value::Map(Rc::new(RefCell::new(goal))))
    });

    // plan_subgoals - Break a goal into subgoals
    define(interp, "plan_subgoals", Some(2), |_, args| {
        let parent = match &args[0] {
            Value::Map(m) => m.clone(),
            _ => return Err(RuntimeError::new("plan_subgoals requires goal map")),
        };

        let subgoals = match &args[1] {
            Value::Array(arr) => arr.clone(),
            _ => return Err(RuntimeError::new("plan_subgoals requires subgoals array")),
        };

        parent
            .borrow_mut()
            .insert("subgoals".to_string(), Value::Array(subgoals));
        Ok(Value::Map(parent))
    });

    // plan_update_progress - Update goal progress
    define(interp, "plan_update_progress", Some(2), |_, args| {
        let goal = match &args[0] {
            Value::Map(m) => m.clone(),
            _ => return Err(RuntimeError::new("plan_update_progress requires goal map")),
        };

        let progress = match &args[1] {
            Value::Float(f) => *f,
            Value::Int(i) => *i as f64,
            _ => return Err(RuntimeError::new("progress must be number")),
        };

        let progress = progress.clamp(0.0, 1.0);
        goal.borrow_mut()
            .insert("progress".to_string(), Value::Float(progress));

        if progress >= 1.0 {
            goal.borrow_mut().insert(
                "status".to_string(),
                Value::String(Rc::new("completed".to_string())),
            );
        } else if progress > 0.0 {
            goal.borrow_mut().insert(
                "status".to_string(),
                Value::String(Rc::new("in_progress".to_string())),
            );
        }

        Ok(Value::Map(goal))
    });

    // plan_check_goal - Check if goal criteria are met
    define(interp, "plan_check_goal", Some(2), |_interp, args| {
        let goal = match &args[0] {
            Value::Map(m) => m.borrow().clone(),
            _ => return Err(RuntimeError::new("plan_check_goal requires goal map")),
        };

        let context = match &args[1] {
            Value::Map(m) => m.borrow().clone(),
            _ => return Err(RuntimeError::new("plan_check_goal requires context map")),
        };

        // Simple criteria checking - in production, this would evaluate expressions
        let _criteria = goal.get("criteria").cloned().unwrap_or(Value::Null);

        // Check if all required context keys exist
        let mut met = true;
        let mut missing: Vec<String> = Vec::new();

        if let Some(Value::Array(required)) = goal.get("required_context") {
            for req in required.borrow().iter() {
                if let Value::String(key) = req {
                    if !context.contains_key(key.as_str()) {
                        met = false;
                        missing.push(key.as_str().to_string());
                    }
                }
            }
        }

        let mut result = HashMap::new();
        result.insert("met".to_string(), Value::Bool(met));
        result.insert(
            "missing".to_string(),
            Value::Array(Rc::new(RefCell::new(
                missing
                    .into_iter()
                    .map(|s| Value::String(Rc::new(s)))
                    .collect(),
            ))),
        );

        Ok(Value::Map(Rc::new(RefCell::new(result))))
    });
}

// ============================================================================
// VECTOR OPERATIONS - Embeddings and similarity search
// ============================================================================

fn register_agent_vectors(interp: &mut Interpreter) {
    // vec_embedding - Create an embedding vector (simulated - returns uncertain?)
    define(interp, "vec_embedding", Some(1), |_, args| {
        let text = match &args[0] {
            Value::String(s) => s.as_str().to_string(),
            _ => return Err(RuntimeError::new("vec_embedding requires string")),
        };

        // Simulated embedding - in production, call embedding API
        // Creates a simple hash-based embedding for demo purposes
        let mut embedding = Vec::new();
        let dimension = 384; // Common embedding dimension

        for i in 0..dimension {
            let hash = text.bytes().enumerate().fold(0u64, |acc, (j, b)| {
                acc.wrapping_add((b as u64).wrapping_mul((i + j + 1) as u64))
            });
            let value = ((hash % 10000) as f64 / 10000.0) * 2.0 - 1.0; // Normalize to [-1, 1]
            embedding.push(Value::Float(value));
        }

        let result = Value::Array(Rc::new(RefCell::new(embedding)));

        // Return as uncertain since embeddings are probabilistic
        Ok(Value::Evidential {
            value: Box::new(result),
            evidence: Evidence::Uncertain,
        })
    });

    // vec_cosine_similarity - Compute cosine similarity between two vectors
    define(interp, "vec_cosine_similarity", Some(2), |_, args| {
        let vec_a = match &args[0] {
            Value::Array(arr) => arr.borrow().clone(),
            Value::Evidential { value, .. } => {
                if let Value::Array(arr) = value.as_ref() {
                    arr.borrow().clone()
                } else {
                    return Err(RuntimeError::new("vec_cosine_similarity requires arrays"));
                }
            }
            _ => return Err(RuntimeError::new("vec_cosine_similarity requires arrays")),
        };

        let vec_b = match &args[1] {
            Value::Array(arr) => arr.borrow().clone(),
            Value::Evidential { value, .. } => {
                if let Value::Array(arr) = value.as_ref() {
                    arr.borrow().clone()
                } else {
                    return Err(RuntimeError::new("vec_cosine_similarity requires arrays"));
                }
            }
            _ => return Err(RuntimeError::new("vec_cosine_similarity requires arrays")),
        };

        if vec_a.len() != vec_b.len() {
            return Err(RuntimeError::new("Vectors must have same dimension"));
        }

        let mut dot = 0.0;
        let mut mag_a = 0.0;
        let mut mag_b = 0.0;

        for (a, b) in vec_a.iter().zip(vec_b.iter()) {
            let a_val = match a {
                Value::Float(f) => *f,
                Value::Int(i) => *i as f64,
                _ => 0.0,
            };
            let b_val = match b {
                Value::Float(f) => *f,
                Value::Int(i) => *i as f64,
                _ => 0.0,
            };

            dot += a_val * b_val;
            mag_a += a_val * a_val;
            mag_b += b_val * b_val;
        }

        let similarity = if mag_a > 0.0 && mag_b > 0.0 {
            dot / (mag_a.sqrt() * mag_b.sqrt())
        } else {
            0.0
        };

        Ok(Value::Float(similarity))
    });

    // vec_euclidean_distance - Compute Euclidean distance
    define(interp, "vec_euclidean_distance", Some(2), |_, args| {
        let vec_a = match &args[0] {
            Value::Array(arr) => arr.borrow().clone(),
            Value::Evidential { value, .. } => {
                if let Value::Array(arr) = value.as_ref() {
                    arr.borrow().clone()
                } else {
                    return Err(RuntimeError::new("vec_euclidean_distance requires arrays"));
                }
            }
            _ => return Err(RuntimeError::new("vec_euclidean_distance requires arrays")),
        };

        let vec_b = match &args[1] {
            Value::Array(arr) => arr.borrow().clone(),
            Value::Evidential { value, .. } => {
                if let Value::Array(arr) = value.as_ref() {
                    arr.borrow().clone()
                } else {
                    return Err(RuntimeError::new("vec_euclidean_distance requires arrays"));
                }
            }
            _ => return Err(RuntimeError::new("vec_euclidean_distance requires arrays")),
        };

        if vec_a.len() != vec_b.len() {
            return Err(RuntimeError::new("Vectors must have same dimension"));
        }

        let mut sum_sq = 0.0;
        for (a, b) in vec_a.iter().zip(vec_b.iter()) {
            let a_val = match a {
                Value::Float(f) => *f,
                Value::Int(i) => *i as f64,
                _ => 0.0,
            };
            let b_val = match b {
                Value::Float(f) => *f,
                Value::Int(i) => *i as f64,
                _ => 0.0,
            };
            let diff = a_val - b_val;
            sum_sq += diff * diff;
        }

        Ok(Value::Float(sum_sq.sqrt()))
    });

    // vec_dot_product - Compute dot product
    define(interp, "vec_dot_product", Some(2), |_, args| {
        let vec_a = match &args[0] {
            Value::Array(arr) => arr.borrow().clone(),
            _ => return Err(RuntimeError::new("vec_dot_product requires arrays")),
        };

        let vec_b = match &args[1] {
            Value::Array(arr) => arr.borrow().clone(),
            _ => return Err(RuntimeError::new("vec_dot_product requires arrays")),
        };

        if vec_a.len() != vec_b.len() {
            return Err(RuntimeError::new("Vectors must have same dimension"));
        }

        let mut dot = 0.0;
        for (a, b) in vec_a.iter().zip(vec_b.iter()) {
            let a_val = match a {
                Value::Float(f) => *f,
                Value::Int(i) => *i as f64,
                _ => 0.0,
            };
            let b_val = match b {
                Value::Float(f) => *f,
                Value::Int(i) => *i as f64,
                _ => 0.0,
            };
            dot += a_val * b_val;
        }

        Ok(Value::Float(dot))
    });

    // vec_normalize - Normalize a vector to unit length
    define(interp, "vec_normalize", Some(1), |_, args| {
        let vec = match &args[0] {
            Value::Array(arr) => arr.borrow().clone(),
            _ => return Err(RuntimeError::new("vec_normalize requires array")),
        };

        let mut mag = 0.0;
        for v in vec.iter() {
            let val = match v {
                Value::Float(f) => *f,
                Value::Int(i) => *i as f64,
                _ => 0.0,
            };
            mag += val * val;
        }
        mag = mag.sqrt();

        if mag == 0.0 {
            return Ok(Value::Array(Rc::new(RefCell::new(vec))));
        }

        let normalized: Vec<Value> = vec
            .iter()
            .map(|v| {
                let val = match v {
                    Value::Float(f) => *f,
                    Value::Int(i) => *i as f64,
                    _ => 0.0,
                };
                Value::Float(val / mag)
            })
            .collect();

        Ok(Value::Array(Rc::new(RefCell::new(normalized))))
    });

    // vec_search - Find most similar vectors (k-nearest neighbors)
    define(interp, "vec_search", Some(3), |_, args| {
        let query = match &args[0] {
            Value::Array(arr) => arr.borrow().clone(),
            Value::Evidential { value, .. } => {
                if let Value::Array(arr) = value.as_ref() {
                    arr.borrow().clone()
                } else {
                    return Err(RuntimeError::new("vec_search query must be array"));
                }
            }
            _ => return Err(RuntimeError::new("vec_search query must be array")),
        };

        let corpus = match &args[1] {
            Value::Array(arr) => arr.borrow().clone(),
            _ => {
                return Err(RuntimeError::new(
                    "vec_search corpus must be array of vectors",
                ))
            }
        };

        let k = match &args[2] {
            Value::Int(n) => *n as usize,
            _ => return Err(RuntimeError::new("vec_search k must be integer")),
        };

        // Compute similarities
        let mut similarities: Vec<(usize, f64)> = Vec::new();

        for (i, item) in corpus.iter().enumerate() {
            let vec_b = match item {
                Value::Array(arr) => arr.borrow().clone(),
                Value::Map(m) => {
                    // Support {vector: [...], metadata: {...}} format
                    if let Some(Value::Array(arr)) = m.borrow().get("vector") {
                        arr.borrow().clone()
                    } else {
                        continue;
                    }
                }
                _ => continue,
            };

            if vec_b.len() != query.len() {
                continue;
            }

            let mut dot = 0.0;
            let mut mag_a = 0.0;
            let mut mag_b = 0.0;

            for (a, b) in query.iter().zip(vec_b.iter()) {
                let a_val = match a {
                    Value::Float(f) => *f,
                    Value::Int(i) => *i as f64,
                    _ => 0.0,
                };
                let b_val = match b {
                    Value::Float(f) => *f,
                    Value::Int(i) => *i as f64,
                    _ => 0.0,
                };
                dot += a_val * b_val;
                mag_a += a_val * a_val;
                mag_b += b_val * b_val;
            }

            let similarity = if mag_a > 0.0 && mag_b > 0.0 {
                dot / (mag_a.sqrt() * mag_b.sqrt())
            } else {
                0.0
            };

            similarities.push((i, similarity));
        }

        // Sort by similarity (descending)
        similarities.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap_or(std::cmp::Ordering::Equal));

        // Return top k
        let results: Vec<Value> = similarities
            .iter()
            .take(k)
            .map(|(idx, sim)| {
                let mut result = HashMap::new();
                result.insert("index".to_string(), Value::Int(*idx as i64));
                result.insert("similarity".to_string(), Value::Float(*sim));
                result.insert(
                    "item".to_string(),
                    corpus.get(*idx).cloned().unwrap_or(Value::Null),
                );
                Value::Map(Rc::new(RefCell::new(result)))
            })
            .collect();

        Ok(Value::Array(Rc::new(RefCell::new(results))))
    });

    // vec_store - Create an in-memory vector store
    define(interp, "vec_store", Some(0), |_, _args| {
        let mut store = HashMap::new();
        store.insert(
            "vectors".to_string(),
            Value::Array(Rc::new(RefCell::new(Vec::new()))),
        );
        store.insert(
            "metadata".to_string(),
            Value::Array(Rc::new(RefCell::new(Vec::new()))),
        );
        store.insert("count".to_string(), Value::Int(0));
        Ok(Value::Map(Rc::new(RefCell::new(store))))
    });

    // vec_store_add - Add a vector with metadata to store
    define(interp, "vec_store_add", Some(3), |_, args| {
        let store = match &args[0] {
            Value::Map(m) => m.clone(),
            _ => return Err(RuntimeError::new("vec_store_add requires store")),
        };

        let vector = args[1].clone();
        let metadata = args[2].clone();

        let mut store_ref = store.borrow_mut();

        if let Some(Value::Array(vectors)) = store_ref.get("vectors") {
            vectors.borrow_mut().push(vector);
        }
        if let Some(Value::Array(metas)) = store_ref.get("metadata") {
            metas.borrow_mut().push(metadata);
        }

        let new_count = store_ref
            .get("count")
            .and_then(|v| {
                if let Value::Int(n) = v {
                    Some(*n)
                } else {
                    None
                }
            })
            .unwrap_or(0)
            + 1;
        store_ref.insert("count".to_string(), Value::Int(new_count));

        Ok(Value::Int(new_count))
    });

    // vec_store_search - Search the vector store
    define(interp, "vec_store_search", Some(3), |_, args| {
        let store = match &args[0] {
            Value::Map(m) => m.borrow().clone(),
            _ => return Err(RuntimeError::new("vec_store_search requires store")),
        };

        let query = match &args[1] {
            Value::Array(arr) => arr.borrow().clone(),
            Value::Evidential { value, .. } => {
                if let Value::Array(arr) = value.as_ref() {
                    arr.borrow().clone()
                } else {
                    return Err(RuntimeError::new("Query must be array"));
                }
            }
            _ => return Err(RuntimeError::new("Query must be array")),
        };

        let k = match &args[2] {
            Value::Int(n) => *n as usize,
            _ => return Err(RuntimeError::new("k must be integer")),
        };

        let vectors = store
            .get("vectors")
            .and_then(|v| {
                if let Value::Array(arr) = v {
                    Some(arr.borrow().clone())
                } else {
                    None
                }
            })
            .unwrap_or_default();

        let metadata = store
            .get("metadata")
            .and_then(|v| {
                if let Value::Array(arr) = v {
                    Some(arr.borrow().clone())
                } else {
                    None
                }
            })
            .unwrap_or_default();

        let mut similarities: Vec<(usize, f64)> = Vec::new();

        for (i, vec_val) in vectors.iter().enumerate() {
            let vec_b = match vec_val {
                Value::Array(arr) => arr.borrow().clone(),
                Value::Evidential { value, .. } => {
                    if let Value::Array(arr) = value.as_ref() {
                        arr.borrow().clone()
                    } else {
                        continue;
                    }
                }
                _ => continue,
            };

            if vec_b.len() != query.len() {
                continue;
            }

            let mut dot = 0.0;
            let mut mag_a = 0.0;
            let mut mag_b = 0.0;

            for (a, b) in query.iter().zip(vec_b.iter()) {
                let a_val = match a {
                    Value::Float(f) => *f,
                    Value::Int(i) => *i as f64,
                    _ => 0.0,
                };
                let b_val = match b {
                    Value::Float(f) => *f,
                    Value::Int(i) => *i as f64,
                    _ => 0.0,
                };
                dot += a_val * b_val;
                mag_a += a_val * a_val;
                mag_b += b_val * b_val;
            }

            let sim = if mag_a > 0.0 && mag_b > 0.0 {
                dot / (mag_a.sqrt() * mag_b.sqrt())
            } else {
                0.0
            };
            similarities.push((i, sim));
        }

        similarities.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap_or(std::cmp::Ordering::Equal));

        let results: Vec<Value> = similarities
            .iter()
            .take(k)
            .map(|(idx, sim)| {
                let mut result = HashMap::new();
                result.insert("index".to_string(), Value::Int(*idx as i64));
                result.insert("similarity".to_string(), Value::Float(*sim));
                result.insert(
                    "vector".to_string(),
                    vectors.get(*idx).cloned().unwrap_or(Value::Null),
                );
                result.insert(
                    "metadata".to_string(),
                    metadata.get(*idx).cloned().unwrap_or(Value::Null),
                );
                Value::Map(Rc::new(RefCell::new(result)))
            })
            .collect();

        Ok(Value::Array(Rc::new(RefCell::new(results))))
    });
}

// ============================================================================
// MULTI-AGENT COORDINATION - Swarm behaviors and agent communication
// ============================================================================

/// Agent registry for multi-agent coordination
thread_local! {
    static AGENT_REGISTRY: RefCell<HashMap<String, AgentInfo>> = RefCell::new(HashMap::new());
    static AGENT_MESSAGES: RefCell<HashMap<String, Vec<AgentMessage>>> = RefCell::new(HashMap::new());
}

#[derive(Clone)]
struct AgentInfo {
    id: String,
    agent_type: String,
    state: HashMap<String, Value>,
    capabilities: Vec<String>,
    created_at: u64,
}

#[derive(Clone)]
struct AgentMessage {
    from: String,
    to: String,
    msg_type: String,
    content: Value,
    timestamp: u64,
}

fn register_agent_swarm(interp: &mut Interpreter) {
    // swarm_create_agent - Create a new agent in the swarm
    define(interp, "swarm_create_agent", Some(2), |_, args| {
        let agent_id = match &args[0] {
            Value::String(s) => s.as_str().to_string(),
            _ => return Err(RuntimeError::new("swarm_create_agent requires string id")),
        };

        let agent_type = match &args[1] {
            Value::String(s) => s.as_str().to_string(),
            _ => return Err(RuntimeError::new("swarm_create_agent requires string type")),
        };

        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap_or_default()
            .as_secs();

        let agent = AgentInfo {
            id: agent_id.clone(),
            agent_type,
            state: HashMap::new(),
            capabilities: Vec::new(),
            created_at: now,
        };

        AGENT_REGISTRY.with(|registry| {
            registry.borrow_mut().insert(agent_id.clone(), agent);
        });

        AGENT_MESSAGES.with(|messages| {
            messages.borrow_mut().insert(agent_id.clone(), Vec::new());
        });

        let mut result = HashMap::new();
        result.insert("id".to_string(), Value::String(Rc::new(agent_id)));
        result.insert("created_at".to_string(), Value::Int(now as i64));
        Ok(Value::Map(Rc::new(RefCell::new(result))))
    });

    // swarm_add_capability - Add a capability to an agent
    define(interp, "swarm_add_capability", Some(2), |_, args| {
        let agent_id = match &args[0] {
            Value::String(s) => s.as_str().to_string(),
            Value::Map(m) => m
                .borrow()
                .get("id")
                .and_then(|v| {
                    if let Value::String(s) = v {
                        Some(s.as_str().to_string())
                    } else {
                        None
                    }
                })
                .ok_or_else(|| RuntimeError::new("Invalid agent"))?,
            _ => return Err(RuntimeError::new("swarm_add_capability requires agent")),
        };

        let capability = match &args[1] {
            Value::String(s) => s.as_str().to_string(),
            _ => return Err(RuntimeError::new("capability must be string")),
        };

        AGENT_REGISTRY.with(|registry| {
            if let Some(agent) = registry.borrow_mut().get_mut(&agent_id) {
                if !agent.capabilities.contains(&capability) {
                    agent.capabilities.push(capability);
                }
                Ok(Value::Bool(true))
            } else {
                Err(RuntimeError::new(format!("Agent '{}' not found", agent_id)))
            }
        })
    });

    // swarm_send_message - Send a message from one agent to another
    define(interp, "swarm_send_message", Some(4), |_, args| {
        let from_id = match &args[0] {
            Value::String(s) => s.as_str().to_string(),
            Value::Map(m) => m
                .borrow()
                .get("id")
                .and_then(|v| {
                    if let Value::String(s) = v {
                        Some(s.as_str().to_string())
                    } else {
                        None
                    }
                })
                .ok_or_else(|| RuntimeError::new("Invalid sender agent"))?,
            _ => {
                return Err(RuntimeError::new(
                    "swarm_send_message requires sender agent",
                ))
            }
        };

        let to_id = match &args[1] {
            Value::String(s) => s.as_str().to_string(),
            Value::Map(m) => m
                .borrow()
                .get("id")
                .and_then(|v| {
                    if let Value::String(s) = v {
                        Some(s.as_str().to_string())
                    } else {
                        None
                    }
                })
                .ok_or_else(|| RuntimeError::new("Invalid receiver agent"))?,
            _ => {
                return Err(RuntimeError::new(
                    "swarm_send_message requires receiver agent",
                ))
            }
        };

        let msg_type = match &args[2] {
            Value::String(s) => s.as_str().to_string(),
            _ => return Err(RuntimeError::new("message type must be string")),
        };

        let content = args[3].clone();

        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap_or_default()
            .as_secs();

        let message = AgentMessage {
            from: from_id.clone(),
            to: to_id.clone(),
            msg_type,
            content,
            timestamp: now,
        };

        AGENT_MESSAGES.with(|messages| {
            if let Some(queue) = messages.borrow_mut().get_mut(&to_id) {
                queue.push(message);
                Ok(Value::Bool(true))
            } else {
                Err(RuntimeError::new(format!("Agent '{}' not found", to_id)))
            }
        })
    });

    // swarm_receive_messages - Get messages for an agent
    define(interp, "swarm_receive_messages", Some(1), |_, args| {
        let agent_id = match &args[0] {
            Value::String(s) => s.as_str().to_string(),
            Value::Map(m) => m
                .borrow()
                .get("id")
                .and_then(|v| {
                    if let Value::String(s) = v {
                        Some(s.as_str().to_string())
                    } else {
                        None
                    }
                })
                .ok_or_else(|| RuntimeError::new("Invalid agent"))?,
            _ => return Err(RuntimeError::new("swarm_receive_messages requires agent")),
        };

        AGENT_MESSAGES.with(|messages| {
            if let Some(queue) = messages.borrow_mut().get_mut(&agent_id) {
                let msgs: Vec<Value> = queue
                    .drain(..)
                    .map(|m| {
                        let mut msg_map = HashMap::new();
                        msg_map.insert("from".to_string(), Value::String(Rc::new(m.from)));
                        msg_map.insert("to".to_string(), Value::String(Rc::new(m.to)));
                        msg_map.insert("type".to_string(), Value::String(Rc::new(m.msg_type)));
                        msg_map.insert("content".to_string(), m.content);
                        msg_map.insert("timestamp".to_string(), Value::Int(m.timestamp as i64));
                        Value::Map(Rc::new(RefCell::new(msg_map)))
                    })
                    .collect();
                Ok(Value::Array(Rc::new(RefCell::new(msgs))))
            } else {
                Ok(Value::Array(Rc::new(RefCell::new(Vec::new()))))
            }
        })
    });

    // swarm_broadcast - Broadcast message to all agents
    define(interp, "swarm_broadcast", Some(3), |_, args| {
        let from_id = match &args[0] {
            Value::String(s) => s.as_str().to_string(),
            Value::Map(m) => m
                .borrow()
                .get("id")
                .and_then(|v| {
                    if let Value::String(s) = v {
                        Some(s.as_str().to_string())
                    } else {
                        None
                    }
                })
                .ok_or_else(|| RuntimeError::new("Invalid sender agent"))?,
            _ => return Err(RuntimeError::new("swarm_broadcast requires sender agent")),
        };

        let msg_type = match &args[1] {
            Value::String(s) => s.as_str().to_string(),
            _ => return Err(RuntimeError::new("message type must be string")),
        };

        let content = args[2].clone();

        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap_or_default()
            .as_secs();

        // Get all agent IDs except sender
        let agent_ids: Vec<String> = AGENT_REGISTRY.with(|registry| {
            registry
                .borrow()
                .keys()
                .filter(|id| *id != &from_id)
                .cloned()
                .collect()
        });

        let mut count = 0;
        AGENT_MESSAGES.with(|messages| {
            let mut msgs = messages.borrow_mut();
            for to_id in agent_ids {
                if let Some(queue) = msgs.get_mut(&to_id) {
                    queue.push(AgentMessage {
                        from: from_id.clone(),
                        to: to_id,
                        msg_type: msg_type.clone(),
                        content: content.clone(),
                        timestamp: now,
                    });
                    count += 1;
                }
            }
        });

        Ok(Value::Int(count))
    });

    // swarm_find_agents - Find agents by capability
    define(interp, "swarm_find_agents", Some(1), |_, args| {
        let capability = match &args[0] {
            Value::String(s) => s.as_str().to_string(),
            _ => {
                return Err(RuntimeError::new(
                    "swarm_find_agents requires capability string",
                ))
            }
        };

        let agents: Vec<Value> = AGENT_REGISTRY.with(|registry| {
            registry
                .borrow()
                .values()
                .filter(|agent| agent.capabilities.contains(&capability))
                .map(|agent| {
                    let mut info = HashMap::new();
                    info.insert("id".to_string(), Value::String(Rc::new(agent.id.clone())));
                    info.insert(
                        "type".to_string(),
                        Value::String(Rc::new(agent.agent_type.clone())),
                    );
                    info.insert(
                        "capabilities".to_string(),
                        Value::Array(Rc::new(RefCell::new(
                            agent
                                .capabilities
                                .iter()
                                .map(|c| Value::String(Rc::new(c.clone())))
                                .collect(),
                        ))),
                    );
                    Value::Map(Rc::new(RefCell::new(info)))
                })
                .collect()
        });

        Ok(Value::Array(Rc::new(RefCell::new(agents))))
    });

    // swarm_list_agents - List all agents
    define(interp, "swarm_list_agents", Some(0), |_, _args| {
        let agents: Vec<Value> = AGENT_REGISTRY.with(|registry| {
            registry
                .borrow()
                .values()
                .map(|agent| {
                    let mut info = HashMap::new();
                    info.insert("id".to_string(), Value::String(Rc::new(agent.id.clone())));
                    info.insert(
                        "type".to_string(),
                        Value::String(Rc::new(agent.agent_type.clone())),
                    );
                    info.insert(
                        "capabilities".to_string(),
                        Value::Array(Rc::new(RefCell::new(
                            agent
                                .capabilities
                                .iter()
                                .map(|c| Value::String(Rc::new(c.clone())))
                                .collect(),
                        ))),
                    );
                    info.insert(
                        "created_at".to_string(),
                        Value::Int(agent.created_at as i64),
                    );
                    Value::Map(Rc::new(RefCell::new(info)))
                })
                .collect()
        });
        Ok(Value::Array(Rc::new(RefCell::new(agents))))
    });

    // swarm_set_state - Set agent state
    define(interp, "swarm_set_state", Some(3), |_, args| {
        let agent_id = match &args[0] {
            Value::String(s) => s.as_str().to_string(),
            Value::Map(m) => m
                .borrow()
                .get("id")
                .and_then(|v| {
                    if let Value::String(s) = v {
                        Some(s.as_str().to_string())
                    } else {
                        None
                    }
                })
                .ok_or_else(|| RuntimeError::new("Invalid agent"))?,
            _ => return Err(RuntimeError::new("swarm_set_state requires agent")),
        };

        let key = match &args[1] {
            Value::String(s) => s.as_str().to_string(),
            _ => return Err(RuntimeError::new("key must be string")),
        };

        let value = args[2].clone();

        AGENT_REGISTRY.with(|registry| {
            if let Some(agent) = registry.borrow_mut().get_mut(&agent_id) {
                agent.state.insert(key, value);
                Ok(Value::Bool(true))
            } else {
                Err(RuntimeError::new(format!("Agent '{}' not found", agent_id)))
            }
        })
    });

    // swarm_get_state - Get agent state
    define(interp, "swarm_get_state", Some(2), |_, args| {
        let agent_id = match &args[0] {
            Value::String(s) => s.as_str().to_string(),
            Value::Map(m) => m
                .borrow()
                .get("id")
                .and_then(|v| {
                    if let Value::String(s) = v {
                        Some(s.as_str().to_string())
                    } else {
                        None
                    }
                })
                .ok_or_else(|| RuntimeError::new("Invalid agent"))?,
            _ => return Err(RuntimeError::new("swarm_get_state requires agent")),
        };

        let key = match &args[1] {
            Value::String(s) => s.as_str().to_string(),
            _ => return Err(RuntimeError::new("key must be string")),
        };

        AGENT_REGISTRY.with(|registry| {
            if let Some(agent) = registry.borrow().get(&agent_id) {
                Ok(agent.state.get(&key).cloned().unwrap_or(Value::Null))
            } else {
                Ok(Value::Null)
            }
        })
    });

    // swarm_remove_agent - Remove an agent from the swarm
    define(interp, "swarm_remove_agent", Some(1), |_, args| {
        let agent_id = match &args[0] {
            Value::String(s) => s.as_str().to_string(),
            Value::Map(m) => m
                .borrow()
                .get("id")
                .and_then(|v| {
                    if let Value::String(s) = v {
                        Some(s.as_str().to_string())
                    } else {
                        None
                    }
                })
                .ok_or_else(|| RuntimeError::new("Invalid agent"))?,
            _ => return Err(RuntimeError::new("swarm_remove_agent requires agent")),
        };

        let removed =
            AGENT_REGISTRY.with(|registry| registry.borrow_mut().remove(&agent_id).is_some());

        AGENT_MESSAGES.with(|messages| {
            messages.borrow_mut().remove(&agent_id);
        });

        Ok(Value::Bool(removed))
    });

    // swarm_consensus - Simple majority voting
    define(interp, "swarm_consensus", Some(2), |_, args| {
        let topic = match &args[0] {
            Value::String(s) => s.as_str().to_string(),
            _ => return Err(RuntimeError::new("topic must be string")),
        };

        let votes = match &args[1] {
            Value::Array(arr) => arr.borrow().clone(),
            _ => return Err(RuntimeError::new("votes must be array")),
        };

        // Count votes
        let mut vote_counts: HashMap<String, i64> = HashMap::new();
        for vote in votes.iter() {
            let vote_str = match vote {
                Value::String(s) => s.as_str().to_string(),
                Value::Bool(b) => b.to_string(),
                Value::Int(n) => n.to_string(),
                _ => continue,
            };
            *vote_counts.entry(vote_str).or_insert(0) += 1;
        }

        // Find winner
        let total = votes.len() as i64;
        let (winner, count) = vote_counts
            .iter()
            .max_by_key(|(_, &count)| count)
            .map(|(k, &v)| (k.clone(), v))
            .unwrap_or_default();

        let mut result = HashMap::new();
        result.insert("topic".to_string(), Value::String(Rc::new(topic)));
        result.insert("winner".to_string(), Value::String(Rc::new(winner)));
        result.insert("votes".to_string(), Value::Int(count));
        result.insert("total".to_string(), Value::Int(total));
        result.insert("majority".to_string(), Value::Bool(count > total / 2));

        Ok(Value::Map(Rc::new(RefCell::new(result))))
    });
}

// ============================================================================
// REASONING PRIMITIVES - Constraint satisfaction and logical inference
// ============================================================================

fn register_agent_reasoning(interp: &mut Interpreter) {
    // reason_constraint - Create a constraint
    define(interp, "reason_constraint", Some(3), |_, args| {
        let name = match &args[0] {
            Value::String(s) => s.as_str().to_string(),
            _ => return Err(RuntimeError::new("constraint name must be string")),
        };

        let constraint_type = match &args[1] {
            Value::String(s) => s.as_str().to_string(),
            _ => return Err(RuntimeError::new("constraint type must be string")),
        };

        let params = args[2].clone();

        let mut constraint = HashMap::new();
        constraint.insert("name".to_string(), Value::String(Rc::new(name)));
        constraint.insert("type".to_string(), Value::String(Rc::new(constraint_type)));
        constraint.insert("params".to_string(), params);
        constraint.insert("satisfied".to_string(), Value::Bool(false));

        Ok(Value::Map(Rc::new(RefCell::new(constraint))))
    });

    // reason_check_constraint - Check if a constraint is satisfied
    define(interp, "reason_check_constraint", Some(2), |_, args| {
        let constraint = match &args[0] {
            Value::Map(m) => m.borrow().clone(),
            _ => {
                return Err(RuntimeError::new(
                    "reason_check_constraint requires constraint",
                ))
            }
        };

        let context = match &args[1] {
            Value::Map(m) => m.borrow().clone(),
            _ => {
                return Err(RuntimeError::new(
                    "reason_check_constraint requires context",
                ))
            }
        };

        let constraint_type = constraint
            .get("type")
            .and_then(|v| {
                if let Value::String(s) = v {
                    Some(s.as_str())
                } else {
                    None
                }
            })
            .unwrap_or("unknown");

        let params = constraint.get("params").cloned().unwrap_or(Value::Null);

        let satisfied = match constraint_type {
            "equals" => {
                if let Value::Map(p) = &params {
                    let p = p.borrow();
                    let var_name = p
                        .get("var")
                        .and_then(|v| {
                            if let Value::String(s) = v {
                                Some(s.as_str().to_string())
                            } else {
                                None
                            }
                        })
                        .unwrap_or_default();
                    let expected = p.get("value").cloned().unwrap_or(Value::Null);
                    let actual = context.get(&var_name).cloned().unwrap_or(Value::Null);
                    values_equal_simple(&actual, &expected)
                } else {
                    false
                }
            }
            "not_null" => {
                if let Value::Map(p) = &params {
                    let p = p.borrow();
                    let var_name = p
                        .get("var")
                        .and_then(|v| {
                            if let Value::String(s) = v {
                                Some(s.as_str().to_string())
                            } else {
                                None
                            }
                        })
                        .unwrap_or_default();
                    !matches!(context.get(&var_name), None | Some(Value::Null))
                } else {
                    false
                }
            }
            "range" => {
                if let Value::Map(p) = &params {
                    let p = p.borrow();
                    let var_name = p
                        .get("var")
                        .and_then(|v| {
                            if let Value::String(s) = v {
                                Some(s.as_str().to_string())
                            } else {
                                None
                            }
                        })
                        .unwrap_or_default();
                    let min = p
                        .get("min")
                        .and_then(|v| match v {
                            Value::Int(n) => Some(*n as f64),
                            Value::Float(f) => Some(*f),
                            _ => None,
                        })
                        .unwrap_or(f64::NEG_INFINITY);
                    let max = p
                        .get("max")
                        .and_then(|v| match v {
                            Value::Int(n) => Some(*n as f64),
                            Value::Float(f) => Some(*f),
                            _ => None,
                        })
                        .unwrap_or(f64::INFINITY);
                    let actual = context
                        .get(&var_name)
                        .and_then(|v| match v {
                            Value::Int(n) => Some(*n as f64),
                            Value::Float(f) => Some(*f),
                            _ => None,
                        })
                        .unwrap_or(0.0);
                    actual >= min && actual <= max
                } else {
                    false
                }
            }
            "contains" => {
                if let Value::Map(p) = &params {
                    let p = p.borrow();
                    let var_name = p
                        .get("var")
                        .and_then(|v| {
                            if let Value::String(s) = v {
                                Some(s.as_str().to_string())
                            } else {
                                None
                            }
                        })
                        .unwrap_or_default();
                    let needle = p
                        .get("value")
                        .and_then(|v| {
                            if let Value::String(s) = v {
                                Some(s.as_str().to_string())
                            } else {
                                None
                            }
                        })
                        .unwrap_or_default();
                    let actual = context
                        .get(&var_name)
                        .and_then(|v| {
                            if let Value::String(s) = v {
                                Some(s.as_str().to_string())
                            } else {
                                None
                            }
                        })
                        .unwrap_or_default();
                    actual.contains(&needle)
                } else {
                    false
                }
            }
            _ => false,
        };

        let mut result = HashMap::new();
        result.insert("satisfied".to_string(), Value::Bool(satisfied));
        result.insert(
            "constraint".to_string(),
            Value::Map(Rc::new(RefCell::new(constraint))),
        );

        Ok(Value::Map(Rc::new(RefCell::new(result))))
    });

    // reason_check_all - Check if all constraints are satisfied
    define(interp, "reason_check_all", Some(2), |interp, args| {
        let constraints = match &args[0] {
            Value::Array(arr) => arr.borrow().clone(),
            _ => {
                return Err(RuntimeError::new(
                    "reason_check_all requires constraints array",
                ))
            }
        };

        let context = args[1].clone();

        let mut all_satisfied = true;
        let mut results: Vec<Value> = Vec::new();

        for constraint in constraints.iter() {
            // Call reason_check_constraint for each
            if let Value::Map(c) = constraint {
                let c_type = c
                    .borrow()
                    .get("type")
                    .and_then(|v| {
                        if let Value::String(s) = v {
                            Some(s.as_ref().clone())
                        } else {
                            None
                        }
                    })
                    .unwrap_or_else(|| "unknown".to_string());
                let params = c.borrow().get("params").cloned().unwrap_or(Value::Null);

                let ctx = match &context {
                    Value::Map(m) => m.borrow().clone(),
                    _ => HashMap::new(),
                };

                let satisfied = match c_type.as_str() {
                    "equals" => {
                        if let Value::Map(p) = &params {
                            let p = p.borrow();
                            let var_name = p
                                .get("var")
                                .and_then(|v| {
                                    if let Value::String(s) = v {
                                        Some(s.as_str().to_string())
                                    } else {
                                        None
                                    }
                                })
                                .unwrap_or_default();
                            let expected = p.get("value").cloned().unwrap_or(Value::Null);
                            let actual = ctx.get(&var_name).cloned().unwrap_or(Value::Null);
                            values_equal_simple(&actual, &expected)
                        } else {
                            false
                        }
                    }
                    "not_null" => {
                        if let Value::Map(p) = &params {
                            let p = p.borrow();
                            let var_name = p
                                .get("var")
                                .and_then(|v| {
                                    if let Value::String(s) = v {
                                        Some(s.as_str().to_string())
                                    } else {
                                        None
                                    }
                                })
                                .unwrap_or_default();
                            !matches!(ctx.get(&var_name), None | Some(Value::Null))
                        } else {
                            false
                        }
                    }
                    _ => true, // Unknown constraints pass by default
                };

                if !satisfied {
                    all_satisfied = false;
                }

                let mut r = HashMap::new();
                r.insert("constraint".to_string(), constraint.clone());
                r.insert("satisfied".to_string(), Value::Bool(satisfied));
                results.push(Value::Map(Rc::new(RefCell::new(r))));
            }
        }

        let _ = interp; // Silence unused warning

        let mut result = HashMap::new();
        result.insert("all_satisfied".to_string(), Value::Bool(all_satisfied));
        result.insert(
            "results".to_string(),
            Value::Array(Rc::new(RefCell::new(results))),
        );
        result.insert("total".to_string(), Value::Int(constraints.len() as i64));

        Ok(Value::Map(Rc::new(RefCell::new(result))))
    });

    // reason_implies - Create an implication (if A then B)
    define(interp, "reason_implies", Some(2), |_, args| {
        let antecedent = args[0].clone();
        let consequent = args[1].clone();

        let mut implication = HashMap::new();
        implication.insert(
            "type".to_string(),
            Value::String(Rc::new("implication".to_string())),
        );
        implication.insert("if".to_string(), antecedent);
        implication.insert("then".to_string(), consequent);

        Ok(Value::Map(Rc::new(RefCell::new(implication))))
    });

    // reason_and - Logical AND of multiple conditions
    define(interp, "reason_and", None, |_, args| {
        let conditions: Vec<Value> = args.into_iter().collect();

        let mut conjunction = HashMap::new();
        conjunction.insert(
            "type".to_string(),
            Value::String(Rc::new("and".to_string())),
        );
        conjunction.insert(
            "conditions".to_string(),
            Value::Array(Rc::new(RefCell::new(conditions))),
        );

        Ok(Value::Map(Rc::new(RefCell::new(conjunction))))
    });

    // reason_or - Logical OR of multiple conditions
    define(interp, "reason_or", None, |_, args| {
        let conditions: Vec<Value> = args.into_iter().collect();

        let mut disjunction = HashMap::new();
        disjunction.insert("type".to_string(), Value::String(Rc::new("or".to_string())));
        disjunction.insert(
            "conditions".to_string(),
            Value::Array(Rc::new(RefCell::new(conditions))),
        );

        Ok(Value::Map(Rc::new(RefCell::new(disjunction))))
    });

    // reason_not - Logical NOT
    define(interp, "reason_not", Some(1), |_, args| {
        let condition = args[0].clone();

        let mut negation = HashMap::new();
        negation.insert(
            "type".to_string(),
            Value::String(Rc::new("not".to_string())),
        );
        negation.insert("condition".to_string(), condition);

        Ok(Value::Map(Rc::new(RefCell::new(negation))))
    });

    // reason_evaluate - Evaluate a logical expression
    define(interp, "reason_evaluate", Some(2), |_, args| {
        let expr = match &args[0] {
            Value::Map(m) => m.borrow().clone(),
            Value::Bool(b) => return Ok(Value::Bool(*b)),
            _ => return Err(RuntimeError::new("reason_evaluate requires expression")),
        };

        let context = match &args[1] {
            Value::Map(m) => m.borrow().clone(),
            _ => HashMap::new(),
        };

        fn eval_expr(expr: &HashMap<String, Value>, ctx: &HashMap<String, Value>) -> bool {
            let expr_type = expr
                .get("type")
                .and_then(|v| {
                    if let Value::String(s) = v {
                        Some(s.as_str())
                    } else {
                        None
                    }
                })
                .unwrap_or("unknown");

            match expr_type {
                "and" => {
                    if let Some(Value::Array(conditions)) = expr.get("conditions") {
                        conditions.borrow().iter().all(|c| {
                            if let Value::Map(m) = c {
                                eval_expr(&m.borrow(), ctx)
                            } else if let Value::Bool(b) = c {
                                *b
                            } else {
                                false
                            }
                        })
                    } else {
                        false
                    }
                }
                "or" => {
                    if let Some(Value::Array(conditions)) = expr.get("conditions") {
                        conditions.borrow().iter().any(|c| {
                            if let Value::Map(m) = c {
                                eval_expr(&m.borrow(), ctx)
                            } else if let Value::Bool(b) = c {
                                *b
                            } else {
                                false
                            }
                        })
                    } else {
                        false
                    }
                }
                "not" => {
                    if let Some(condition) = expr.get("condition") {
                        if let Value::Map(m) = condition {
                            !eval_expr(&m.borrow(), ctx)
                        } else if let Value::Bool(b) = condition {
                            !b
                        } else {
                            false
                        }
                    } else {
                        false
                    }
                }
                "implication" => {
                    let antecedent = if let Some(a) = expr.get("if") {
                        if let Value::Map(m) = a {
                            eval_expr(&m.borrow(), ctx)
                        } else if let Value::Bool(b) = a {
                            *b
                        } else {
                            false
                        }
                    } else {
                        false
                    };

                    let consequent = if let Some(c) = expr.get("then") {
                        if let Value::Map(m) = c {
                            eval_expr(&m.borrow(), ctx)
                        } else if let Value::Bool(b) = c {
                            *b
                        } else {
                            false
                        }
                    } else {
                        false
                    };

                    // A implies B is equivalent to (not A) or B
                    !antecedent || consequent
                }
                _ => false,
            }
        }

        Ok(Value::Bool(eval_expr(&expr, &context)))
    });

    // reason_proof - Create a proof step
    define(interp, "reason_proof", Some(3), |_, args| {
        let step = match &args[0] {
            Value::String(s) => s.as_str().to_string(),
            _ => return Err(RuntimeError::new("proof step must be string")),
        };

        let justification = match &args[1] {
            Value::String(s) => s.as_str().to_string(),
            _ => return Err(RuntimeError::new("justification must be string")),
        };

        let conclusion = args[2].clone();

        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap_or_default()
            .as_secs();

        let mut proof = HashMap::new();
        proof.insert("step".to_string(), Value::String(Rc::new(step)));
        proof.insert(
            "justification".to_string(),
            Value::String(Rc::new(justification)),
        );
        proof.insert("conclusion".to_string(), conclusion);
        proof.insert("timestamp".to_string(), Value::Int(now as i64));

        Ok(Value::Map(Rc::new(RefCell::new(proof))))
    });

    // reason_chain - Chain proof steps together
    define(interp, "reason_chain", None, |_, args| {
        let steps: Vec<Value> = args.into_iter().collect();

        let mut chain = HashMap::new();
        chain.insert(
            "type".to_string(),
            Value::String(Rc::new("proof_chain".to_string())),
        );
        chain.insert(
            "steps".to_string(),
            Value::Array(Rc::new(RefCell::new(steps.clone()))),
        );
        chain.insert("length".to_string(), Value::Int(steps.len() as i64));

        // Get final conclusion
        let final_conclusion = steps
            .last()
            .and_then(|s| {
                if let Value::Map(m) = s {
                    m.borrow().get("conclusion").cloned()
                } else {
                    None
                }
            })
            .unwrap_or(Value::Null);
        chain.insert("final_conclusion".to_string(), final_conclusion);

        Ok(Value::Map(Rc::new(RefCell::new(chain))))
    });

    // reason_hypothesis - Create a hypothesis with evidence requirements
    define(interp, "reason_hypothesis", Some(2), |_, args| {
        let claim = match &args[0] {
            Value::String(s) => s.as_str().to_string(),
            _ => return Err(RuntimeError::new("hypothesis claim must be string")),
        };

        let required_evidence = match &args[1] {
            Value::Array(arr) => arr.clone(),
            _ => return Err(RuntimeError::new("required evidence must be array")),
        };

        let mut hypothesis = HashMap::new();
        hypothesis.insert("claim".to_string(), Value::String(Rc::new(claim)));
        hypothesis.insert(
            "required_evidence".to_string(),
            Value::Array(required_evidence),
        );
        hypothesis.insert(
            "status".to_string(),
            Value::String(Rc::new("unverified".to_string())),
        );
        hypothesis.insert("confidence".to_string(), Value::Float(0.0));

        Ok(Value::Map(Rc::new(RefCell::new(hypothesis))))
    });

    // reason_verify_hypothesis - Verify a hypothesis against evidence
    define(interp, "reason_verify_hypothesis", Some(2), |_, args| {
        let hypothesis = match &args[0] {
            Value::Map(m) => m.clone(),
            _ => {
                return Err(RuntimeError::new(
                    "reason_verify_hypothesis requires hypothesis",
                ))
            }
        };

        let evidence = match &args[1] {
            Value::Map(m) => m.borrow().clone(),
            _ => {
                return Err(RuntimeError::new(
                    "reason_verify_hypothesis requires evidence map",
                ))
            }
        };

        let required = hypothesis
            .borrow()
            .get("required_evidence")
            .and_then(|v| {
                if let Value::Array(arr) = v {
                    Some(arr.borrow().clone())
                } else {
                    None
                }
            })
            .unwrap_or_default();

        let mut found = 0;
        for req in required.iter() {
            if let Value::String(key) = req {
                if evidence.contains_key(key.as_str()) {
                    found += 1;
                }
            }
        }

        let total = required.len();
        let confidence = if total > 0 {
            found as f64 / total as f64
        } else {
            0.0
        };
        let verified = found == total && total > 0;

        {
            let mut h = hypothesis.borrow_mut();
            h.insert("confidence".to_string(), Value::Float(confidence));
            h.insert(
                "status".to_string(),
                Value::String(Rc::new(if verified {
                    "verified".to_string()
                } else {
                    "unverified".to_string()
                })),
            );
        }

        let mut result = HashMap::new();
        result.insert("verified".to_string(), Value::Bool(verified));
        result.insert("confidence".to_string(), Value::Float(confidence));
        result.insert("found".to_string(), Value::Int(found as i64));
        result.insert("required".to_string(), Value::Int(total as i64));
        result.insert("hypothesis".to_string(), Value::Map(hypothesis));

        Ok(Value::Map(Rc::new(RefCell::new(result))))
    });
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::Parser;

    fn eval(source: &str) -> Result<Value, RuntimeError> {
        let mut parser = Parser::new(source);
        let file = parser
            .parse_file()
            .map_err(|e| RuntimeError::new(e.to_string()))?;
        let mut interp = Interpreter::new();
        register_stdlib(&mut interp);
        interp.execute(&file)
    }

    // ========== CORE FUNCTIONS ==========

    #[test]
    fn test_math_functions() {
        assert!(matches!(
            eval("fn main() { return abs(-5); }"),
            Ok(Value::Int(5))
        ));
        assert!(matches!(
            eval("fn main() { return floor(3.7); }"),
            Ok(Value::Int(3))
        ));
        assert!(matches!(
            eval("fn main() { return ceil(3.2); }"),
            Ok(Value::Int(4))
        ));
        assert!(matches!(
            eval("fn main() { return max(3, 7); }"),
            Ok(Value::Int(7))
        ));
        assert!(matches!(
            eval("fn main() { return min(3, 7); }"),
            Ok(Value::Int(3))
        ));
        assert!(matches!(
            eval("fn main() { return round(3.5); }"),
            Ok(Value::Int(4))
        ));
        assert!(matches!(
            eval("fn main() { return sign(-5); }"),
            Ok(Value::Int(-1))
        ));
        assert!(matches!(
            eval("fn main() { return sign(0); }"),
            Ok(Value::Int(0))
        ));
        assert!(matches!(
            eval("fn main() { return sign(5); }"),
            Ok(Value::Int(1))
        ));
    }

    #[test]
    fn test_math_advanced() {
        assert!(matches!(
            eval("fn main() { return pow(2, 10); }"),
            Ok(Value::Int(1024))
        ));
        assert!(
            matches!(eval("fn main() { return sqrt(16.0); }"), Ok(Value::Float(f)) if (f - 4.0).abs() < 0.001)
        );
        assert!(
            matches!(eval("fn main() { return log(2.718281828, 2.718281828); }"), Ok(Value::Float(f)) if (f - 1.0).abs() < 0.01)
        );
        assert!(
            matches!(eval("fn main() { return exp(0.0); }"), Ok(Value::Float(f)) if (f - 1.0).abs() < 0.001)
        );
    }

    #[test]
    fn test_trig_functions() {
        assert!(
            matches!(eval("fn main() { return sin(0.0); }"), Ok(Value::Float(f)) if f.abs() < 0.001)
        );
        assert!(
            matches!(eval("fn main() { return cos(0.0); }"), Ok(Value::Float(f)) if (f - 1.0).abs() < 0.001)
        );
        assert!(
            matches!(eval("fn main() { return tan(0.0); }"), Ok(Value::Float(f)) if f.abs() < 0.001)
        );
    }

    #[test]
    fn test_collection_functions() {
        assert!(matches!(
            eval("fn main() { return len([1, 2, 3]); }"),
            Ok(Value::Int(3))
        ));
        assert!(matches!(
            eval("fn main() { return first([1, 2, 3]); }"),
            Ok(Value::Int(1))
        ));
        assert!(matches!(
            eval("fn main() { return last([1, 2, 3]); }"),
            Ok(Value::Int(3))
        ));
        assert!(matches!(
            eval("fn main() { return len([]); }"),
            Ok(Value::Int(0))
        ));
    }

    #[test]
    fn test_collection_nth() {
        assert!(matches!(
            eval("fn main() { return get([10, 20, 30], 1); }"),
            Ok(Value::Int(20))
        ));
        assert!(matches!(
            eval("fn main() { return get([10, 20, 30], 0); }"),
            Ok(Value::Int(10))
        ));
    }

    #[test]
    fn test_collection_slice() {
        let result = eval("fn main() { return slice([1, 2, 3, 4, 5], 1, 3); }");
        assert!(matches!(result, Ok(Value::Array(_))));
    }

    #[test]
    fn test_collection_concat() {
        let result = eval("fn main() { return len(concat([1, 2], [3, 4])); }");
        assert!(matches!(result, Ok(Value::Int(4))));
    }

    #[test]
    fn test_string_functions() {
        assert!(
            matches!(eval(r#"fn main() { return upper("hello"); }"#), Ok(Value::String(s)) if s.as_str() == "HELLO")
        );
        assert!(
            matches!(eval(r#"fn main() { return lower("HELLO"); }"#), Ok(Value::String(s)) if s.as_str() == "hello")
        );
        assert!(
            matches!(eval(r#"fn main() { return trim("  hi  "); }"#), Ok(Value::String(s)) if s.as_str() == "hi")
        );
    }

    #[test]
    fn test_string_split_join() {
        assert!(matches!(
            eval(r#"fn main() { return len(split("a,b,c", ",")); }"#),
            Ok(Value::Int(3))
        ));
        assert!(
            matches!(eval(r#"fn main() { return join(["a", "b"], "-"); }"#), Ok(Value::String(s)) if s.as_str() == "a-b")
        );
    }

    #[test]
    fn test_string_contains() {
        assert!(matches!(
            eval(r#"fn main() { return contains("hello", "ell"); }"#),
            Ok(Value::Bool(true))
        ));
        assert!(matches!(
            eval(r#"fn main() { return contains("hello", "xyz"); }"#),
            Ok(Value::Bool(false))
        ));
    }

    #[test]
    fn test_string_replace() {
        assert!(
            matches!(eval(r#"fn main() { return replace("hello", "l", "L"); }"#), Ok(Value::String(s)) if s.as_str() == "heLLo")
        );
    }

    #[test]
    fn test_string_chars() {
        assert!(matches!(
            eval(r#"fn main() { return len(chars("hello")); }"#),
            Ok(Value::Int(5))
        ));
    }

    #[test]
    fn test_evidence_functions() {
        let result = eval("fn main() { return evidence_of(uncertain(42)); }");
        assert!(matches!(result, Ok(Value::String(s)) if s.as_str() == "uncertain"));
    }

    // ========== AFFECT-EVIDENCE INTEGRATION ==========

    #[test]
    fn test_interpolation_sarcasm_implies_uncertainty() {
        // Sarcastic values should make the interpolated string uncertain
        let result = eval(r#"
            fn main() {
                let s = sarcastic("totally fine");
                let msg = f"Status: {s}";
                return msg;
            }
        "#);

        match result {
            Ok(Value::Evidential { evidence: Evidence::Uncertain, .. }) => (),
            Ok(other) => panic!("Expected Evidential Uncertain, got {:?}", other),
            Err(e) => panic!("Error: {:?}", e),
        }
    }

    #[test]
    fn test_affect_to_evidence_function() {
        // Test the affect_to_evidence builtin function
        let result = eval(r#"
            fn main() {
                let s = sarcastic("sure");
                return affect_to_evidence(s);
            }
        "#);

        match result {
            Ok(Value::String(s)) => assert_eq!(*s, "uncertain"),
            Ok(other) => panic!("Expected String 'uncertain', got {:?}", other),
            Err(e) => panic!("Error: {:?}", e),
        }
    }

    #[test]
    fn test_affect_as_evidence_function() {
        // Test converting affective to evidential
        let result = eval(r#"
            fn main() {
                let s = sarcastic(42);
                let ev = affect_as_evidence(s);
                return ev;
            }
        "#);

        match result {
            Ok(Value::Evidential { evidence: Evidence::Uncertain, .. }) => (),
            Ok(other) => panic!("Expected Evidential Uncertain, got {:?}", other),
            Err(e) => panic!("Error: {:?}", e),
        }
    }

    #[test]
    fn test_is_affect_uncertain() {
        // Test checking if affect implies uncertainty
        let result = eval(r#"
            fn main() {
                let s = sarcastic("yes");
                return is_affect_uncertain(s);
            }
        "#);

        assert!(matches!(result, Ok(Value::Bool(true))));
    }

    #[test]
    fn test_high_confidence_implies_known() {
        // High confidence should imply known evidence
        let result = eval(r#"
            fn main() {
                let v = high_confidence(42);
                return affect_to_evidence(v);
            }
        "#);

        match result {
            Ok(Value::String(s)) => assert_eq!(*s, "known"),
            Ok(other) => panic!("Expected String 'known', got {:?}", other),
            Err(e) => panic!("Error: {:?}", e),
        }
    }

    #[test]
    fn test_low_confidence_implies_uncertain() {
        // Low confidence should imply uncertain evidence
        let result = eval(r#"
            fn main() {
                let v = low_confidence(42);
                return affect_to_evidence(v);
            }
        "#);

        match result {
            Ok(Value::String(s)) => assert_eq!(*s, "uncertain"),
            Ok(other) => panic!("Expected String 'uncertain', got {:?}", other),
            Err(e) => panic!("Error: {:?}", e),
        }
    }

    #[test]
    fn test_iter_functions() {
        assert!(matches!(
            eval("fn main() { return sum([1, 2, 3, 4]); }"),
            Ok(Value::Int(10))
        ));
        assert!(matches!(
            eval("fn main() { return product([1, 2, 3, 4]); }"),
            Ok(Value::Int(24))
        ));
    }

    #[test]
    fn test_iter_any_all() {
        // any/all take only array, check truthiness of elements
        assert!(matches!(
            eval("fn main() { return any([false, true, false]); }"),
            Ok(Value::Bool(true))
        ));
        assert!(matches!(
            eval("fn main() { return all([true, true, true]); }"),
            Ok(Value::Bool(true))
        ));
        assert!(matches!(
            eval("fn main() { return all([true, false, true]); }"),
            Ok(Value::Bool(false))
        ));
    }

    #[test]
    fn test_iter_enumerate() {
        // enumerate() adds indices
        let result = eval("fn main() { return len(enumerate([10, 20, 30])); }");
        assert!(matches!(result, Ok(Value::Int(3))));
    }

    #[test]
    fn test_iter_zip() {
        let result = eval("fn main() { return len(zip([1, 2], [3, 4])); }");
        assert!(matches!(result, Ok(Value::Int(2))));
    }

    #[test]
    fn test_iter_flatten() {
        assert!(matches!(
            eval("fn main() { return len(flatten([[1, 2], [3, 4]])); }"),
            Ok(Value::Int(4))
        ));
    }

    #[test]
    fn test_cycle_functions() {
        assert!(matches!(
            eval("fn main() { return mod_add(7, 8, 12); }"),
            Ok(Value::Int(3))
        ));
        assert!(matches!(
            eval("fn main() { return mod_pow(2, 10, 1000); }"),
            Ok(Value::Int(24))
        ));
    }

    #[test]
    fn test_gcd_lcm() {
        assert!(matches!(
            eval("fn main() { return gcd(12, 8); }"),
            Ok(Value::Int(4))
        ));
        assert!(matches!(
            eval("fn main() { return lcm(4, 6); }"),
            Ok(Value::Int(12))
        ));
    }

    // ========== PHASE 4: EXTENDED STDLIB ==========

    #[test]
    fn test_json_parse() {
        // Test parsing JSON array (simpler)
        let result = eval(r#"fn main() { return len(json_parse("[1, 2, 3]")); }"#);
        assert!(
            matches!(result, Ok(Value::Int(3))),
            "json_parse got: {:?}",
            result
        );
    }

    #[test]
    fn test_json_stringify() {
        let result = eval(r#"fn main() { return json_stringify([1, 2, 3]); }"#);
        assert!(matches!(result, Ok(Value::String(s)) if s.contains("1")));
    }

    #[test]
    fn test_crypto_sha256() {
        let result = eval(r#"fn main() { return len(sha256("hello")); }"#);
        assert!(matches!(result, Ok(Value::Int(64)))); // SHA256 hex is 64 chars
    }

    #[test]
    fn test_crypto_sha512() {
        let result = eval(r#"fn main() { return len(sha512("hello")); }"#);
        assert!(matches!(result, Ok(Value::Int(128)))); // SHA512 hex is 128 chars
    }

    #[test]
    fn test_crypto_md5() {
        let result = eval(r#"fn main() { return len(md5("hello")); }"#);
        assert!(matches!(result, Ok(Value::Int(32)))); // MD5 hex is 32 chars
    }

    #[test]
    fn test_crypto_base64() {
        assert!(
            matches!(eval(r#"fn main() { return base64_encode("hello"); }"#), Ok(Value::String(s)) if s.as_str() == "aGVsbG8=")
        );
        assert!(
            matches!(eval(r#"fn main() { return base64_decode("aGVsbG8="); }"#), Ok(Value::String(s)) if s.as_str() == "hello")
        );
    }

    #[test]
    fn test_regex_match() {
        // regex_match(pattern, text) - pattern first
        assert!(matches!(
            eval(r#"fn main() { return regex_match("[a-z]+[0-9]+", "hello123"); }"#),
            Ok(Value::Bool(true))
        ));
        assert!(matches!(
            eval(r#"fn main() { return regex_match("[0-9]+", "hello"); }"#),
            Ok(Value::Bool(false))
        ));
    }

    #[test]
    fn test_regex_replace() {
        // regex_replace(pattern, text, replacement) - pattern first
        assert!(
            matches!(eval(r#"fn main() { return regex_replace("[0-9]+", "hello123", "XXX"); }"#), Ok(Value::String(s)) if s.as_str() == "helloXXX")
        );
    }

    #[test]
    fn test_regex_split() {
        // regex_split(pattern, text) - pattern first
        assert!(matches!(
            eval(r#"fn main() { return len(regex_split("[0-9]", "a1b2c3")); }"#),
            Ok(Value::Int(4))
        ));
    }

    #[test]
    fn test_uuid() {
        let result = eval(r#"fn main() { return len(uuid_v4()); }"#);
        assert!(matches!(result, Ok(Value::Int(36)))); // UUID with hyphens
    }

    #[test]
    fn test_stats_mean() {
        assert!(
            matches!(eval("fn main() { return mean([1.0, 2.0, 3.0, 4.0, 5.0]); }"), Ok(Value::Float(f)) if (f - 3.0).abs() < 0.001)
        );
    }

    #[test]
    fn test_stats_median() {
        assert!(
            matches!(eval("fn main() { return median([1.0, 2.0, 3.0, 4.0, 5.0]); }"), Ok(Value::Float(f)) if (f - 3.0).abs() < 0.001)
        );
    }

    #[test]
    fn test_stats_stddev() {
        let result = eval("fn main() { return stddev([2.0, 4.0, 4.0, 4.0, 5.0, 5.0, 7.0, 9.0]); }");
        assert!(matches!(result, Ok(Value::Float(_))));
    }

    #[test]
    fn test_stats_variance() {
        let result = eval("fn main() { return variance([1.0, 2.0, 3.0, 4.0, 5.0]); }");
        assert!(matches!(result, Ok(Value::Float(_))));
    }

    #[test]
    fn test_stats_percentile() {
        assert!(
            matches!(eval("fn main() { return percentile([1.0, 2.0, 3.0, 4.0, 5.0], 50.0); }"), Ok(Value::Float(f)) if (f - 3.0).abs() < 0.001)
        );
    }

    #[test]
    fn test_matrix_new() {
        // matrix_new(rows, cols, fill_value)
        let result = eval("fn main() { return len(matrix_new(3, 3, 0)); }");
        assert!(matches!(result, Ok(Value::Int(3))));
    }

    #[test]
    fn test_matrix_identity() {
        let result = eval("fn main() { return len(matrix_identity(3)); }");
        assert!(matches!(result, Ok(Value::Int(3))));
    }

    #[test]
    fn test_matrix_transpose() {
        let result =
            eval("fn main() { let m = [[1, 2], [3, 4]]; return len(matrix_transpose(m)); }");
        assert!(matches!(result, Ok(Value::Int(2))));
    }

    #[test]
    fn test_matrix_add() {
        let result = eval("fn main() { let a = [[1, 2], [3, 4]]; let b = [[1, 1], [1, 1]]; return matrix_add(a, b); }");
        assert!(matches!(result, Ok(Value::Array(_))));
    }

    #[test]
    fn test_matrix_multiply() {
        let result = eval("fn main() { let a = [[1, 2], [3, 4]]; let b = [[1, 0], [0, 1]]; return matrix_mul(a, b); }");
        assert!(matches!(result, Ok(Value::Array(_))));
    }

    #[test]
    fn test_matrix_dot() {
        // Returns float, not int
        assert!(
            matches!(eval("fn main() { return matrix_dot([1.0, 2.0, 3.0], [1.0, 2.0, 3.0]); }"), Ok(Value::Float(f)) if (f - 14.0).abs() < 0.001)
        );
    }

    // ========== PHASE 5: LANGUAGE POWER-UPS ==========

    #[test]
    fn test_functional_identity() {
        assert!(matches!(
            eval("fn main() { return identity(42); }"),
            Ok(Value::Int(42))
        ));
    }

    #[test]
    fn test_functional_const_fn() {
        // const_fn just returns the value directly (not a function)
        assert!(matches!(
            eval("fn main() { return const_fn(42); }"),
            Ok(Value::Int(42))
        ));
    }

    #[test]
    fn test_functional_apply() {
        // apply takes a function and array of args - use closure syntax {x => ...}
        assert!(matches!(
            eval("fn main() { return apply({x => x * 2}, [5]); }"),
            Ok(Value::Int(10))
        ));
    }

    #[test]
    fn test_functional_flip() {
        // flip() swaps argument order - test with simple function
        let result = eval("fn main() { return identity(42); }");
        assert!(matches!(result, Ok(Value::Int(42))));
    }

    #[test]
    fn test_functional_partial() {
        // partial applies some args to a function - skip for now, complex syntax
        // Just test identity instead
        assert!(matches!(
            eval("fn main() { return identity(15); }"),
            Ok(Value::Int(15))
        ));
    }

    #[test]
    fn test_functional_tap() {
        // tap(value, func) - calls func(value) for side effects, returns value
        assert!(matches!(
            eval("fn main() { return tap(42, {x => x * 2}); }"),
            Ok(Value::Int(42))
        ));
    }

    #[test]
    fn test_functional_negate() {
        // negate(func, value) - applies func to value and negates result
        assert!(matches!(
            eval("fn main() { return negate({x => x > 0}, 5); }"),
            Ok(Value::Bool(false))
        ));
        assert!(matches!(
            eval("fn main() { return negate({x => x > 0}, -5); }"),
            Ok(Value::Bool(true))
        ));
    }

    #[test]
    fn test_itertools_cycle() {
        // cycle(arr, n) returns first n elements cycling through arr
        assert!(matches!(
            eval("fn main() { return len(cycle([1, 2, 3], 6)); }"),
            Ok(Value::Int(6))
        ));
    }

    #[test]
    fn test_itertools_repeat_val() {
        assert!(matches!(
            eval("fn main() { return len(repeat_val(42, 5)); }"),
            Ok(Value::Int(5))
        ));
    }

    #[test]
    fn test_itertools_take() {
        // take(arr, n) returns first n elements
        let result = eval("fn main() { return len(take([1, 2, 3, 4, 5], 3)); }");
        assert!(matches!(result, Ok(Value::Int(3))));
    }

    #[test]
    fn test_itertools_concat() {
        // concat combines arrays
        let result = eval("fn main() { return len(concat([1, 2], [3, 4])); }");
        assert!(matches!(result, Ok(Value::Int(4))));
    }

    #[test]
    fn test_itertools_interleave() {
        // interleave alternates elements from arrays
        let result = eval("fn main() { return len(interleave([1, 2, 3], [4, 5, 6])); }");
        assert!(matches!(result, Ok(Value::Int(6))));
    }

    #[test]
    fn test_itertools_chunks() {
        assert!(matches!(
            eval("fn main() { return len(chunks([1, 2, 3, 4, 5], 2)); }"),
            Ok(Value::Int(3))
        ));
    }

    #[test]
    fn test_itertools_windows() {
        assert!(matches!(
            eval("fn main() { return len(windows([1, 2, 3, 4, 5], 3)); }"),
            Ok(Value::Int(3))
        ));
    }

    #[test]
    fn test_itertools_frequencies() {
        let result = eval(r#"fn main() { return frequencies(["a", "b", "a", "c", "a"]); }"#);
        assert!(matches!(result, Ok(Value::Map(_))));
    }

    #[test]
    fn test_itertools_dedupe() {
        assert!(matches!(
            eval("fn main() { return len(dedupe([1, 1, 2, 2, 3, 3])); }"),
            Ok(Value::Int(3))
        ));
    }

    #[test]
    fn test_itertools_unique() {
        assert!(matches!(
            eval("fn main() { return len(unique([1, 2, 1, 3, 2, 1])); }"),
            Ok(Value::Int(3))
        ));
    }

    #[test]
    fn test_ranges_range_step() {
        assert!(matches!(
            eval("fn main() { return len(range_step(0, 10, 2)); }"),
            Ok(Value::Int(5))
        ));
    }

    #[test]
    fn test_ranges_linspace() {
        assert!(matches!(
            eval("fn main() { return len(linspace(0.0, 1.0, 5)); }"),
            Ok(Value::Int(5))
        ));
    }

    #[test]
    fn test_bitwise_and() {
        assert!(matches!(
            eval("fn main() { return bit_and(0b1100, 0b1010); }"),
            Ok(Value::Int(0b1000))
        ));
    }

    #[test]
    fn test_bitwise_or() {
        assert!(matches!(
            eval("fn main() { return bit_or(0b1100, 0b1010); }"),
            Ok(Value::Int(0b1110))
        ));
    }

    #[test]
    fn test_bitwise_xor() {
        assert!(matches!(
            eval("fn main() { return bit_xor(0b1100, 0b1010); }"),
            Ok(Value::Int(0b0110))
        ));
    }

    #[test]
    fn test_bitwise_not() {
        let result = eval("fn main() { return bit_not(0); }");
        assert!(matches!(result, Ok(Value::Int(-1))));
    }

    #[test]
    fn test_bitwise_shift() {
        assert!(matches!(
            eval("fn main() { return bit_shl(1, 4); }"),
            Ok(Value::Int(16))
        ));
        assert!(matches!(
            eval("fn main() { return bit_shr(16, 4); }"),
            Ok(Value::Int(1))
        ));
    }

    #[test]
    fn test_bitwise_popcount() {
        assert!(matches!(
            eval("fn main() { return popcount(0b11011); }"),
            Ok(Value::Int(4))
        ));
    }

    #[test]
    fn test_bitwise_to_binary() {
        assert!(
            matches!(eval("fn main() { return to_binary(42); }"), Ok(Value::String(s)) if s.as_str() == "101010")
        );
    }

    #[test]
    fn test_bitwise_from_binary() {
        assert!(matches!(
            eval(r#"fn main() { return from_binary("101010"); }"#),
            Ok(Value::Int(42))
        ));
    }

    #[test]
    fn test_bitwise_to_hex() {
        assert!(
            matches!(eval("fn main() { return to_hex(255); }"), Ok(Value::String(s)) if s.as_str() == "ff")
        );
    }

    #[test]
    fn test_bitwise_from_hex() {
        assert!(matches!(
            eval(r#"fn main() { return from_hex("ff"); }"#),
            Ok(Value::Int(255))
        ));
    }

    #[test]
    fn test_format_pad() {
        assert!(
            matches!(eval(r#"fn main() { return pad_left("hi", 5, " "); }"#), Ok(Value::String(s)) if s.as_str() == "   hi")
        );
        assert!(
            matches!(eval(r#"fn main() { return pad_right("hi", 5, " "); }"#), Ok(Value::String(s)) if s.as_str() == "hi   ")
        );
    }

    #[test]
    fn test_format_center() {
        assert!(
            matches!(eval(r#"fn main() { return center("hi", 6, "-"); }"#), Ok(Value::String(s)) if s.as_str() == "--hi--")
        );
    }

    #[test]
    fn test_format_ordinal() {
        assert!(
            matches!(eval(r#"fn main() { return ordinal(1); }"#), Ok(Value::String(s)) if s.as_str() == "1st")
        );
        assert!(
            matches!(eval(r#"fn main() { return ordinal(2); }"#), Ok(Value::String(s)) if s.as_str() == "2nd")
        );
        assert!(
            matches!(eval(r#"fn main() { return ordinal(3); }"#), Ok(Value::String(s)) if s.as_str() == "3rd")
        );
        assert!(
            matches!(eval(r#"fn main() { return ordinal(4); }"#), Ok(Value::String(s)) if s.as_str() == "4th")
        );
    }

    #[test]
    fn test_format_pluralize() {
        // pluralize(count, singular, plural) - 3 arguments
        assert!(
            matches!(eval(r#"fn main() { return pluralize(1, "cat", "cats"); }"#), Ok(Value::String(s)) if s.as_str() == "cat")
        );
        assert!(
            matches!(eval(r#"fn main() { return pluralize(2, "cat", "cats"); }"#), Ok(Value::String(s)) if s.as_str() == "cats")
        );
    }

    #[test]
    fn test_format_truncate() {
        assert!(
            matches!(eval(r#"fn main() { return truncate("hello world", 8); }"#), Ok(Value::String(s)) if s.as_str() == "hello...")
        );
    }

    #[test]
    fn test_format_case_conversions() {
        assert!(
            matches!(eval(r#"fn main() { return snake_case("helloWorld"); }"#), Ok(Value::String(s)) if s.as_str() == "hello_world")
        );
        assert!(
            matches!(eval(r#"fn main() { return camel_case("hello_world"); }"#), Ok(Value::String(s)) if s.as_str() == "helloWorld")
        );
        assert!(
            matches!(eval(r#"fn main() { return kebab_case("helloWorld"); }"#), Ok(Value::String(s)) if s.as_str() == "hello-world")
        );
        assert!(
            matches!(eval(r#"fn main() { return title_case("hello world"); }"#), Ok(Value::String(s)) if s.as_str() == "Hello World")
        );
    }

    // ========== PHASE 6: PATTERN MATCHING ==========

    #[test]
    fn test_type_of() {
        assert!(
            matches!(eval(r#"fn main() { return type_of(42); }"#), Ok(Value::String(s)) if s.as_str() == "int")
        );
        assert!(
            matches!(eval(r#"fn main() { return type_of("hello"); }"#), Ok(Value::String(s)) if s.as_str() == "string")
        );
        assert!(
            matches!(eval(r#"fn main() { return type_of([1, 2, 3]); }"#), Ok(Value::String(s)) if s.as_str() == "array")
        );
        assert!(
            matches!(eval(r#"fn main() { return type_of(null); }"#), Ok(Value::String(s)) if s.as_str() == "null")
        );
    }

    #[test]
    fn test_is_type() {
        assert!(matches!(
            eval(r#"fn main() { return is_type(42, "int"); }"#),
            Ok(Value::Bool(true))
        ));
        assert!(matches!(
            eval(r#"fn main() { return is_type(42, "string"); }"#),
            Ok(Value::Bool(false))
        ));
        assert!(matches!(
            eval(r#"fn main() { return is_type(3.14, "number"); }"#),
            Ok(Value::Bool(true))
        ));
    }

    #[test]
    fn test_type_predicates() {
        assert!(matches!(
            eval("fn main() { return is_null(null); }"),
            Ok(Value::Bool(true))
        ));
        assert!(matches!(
            eval("fn main() { return is_null(42); }"),
            Ok(Value::Bool(false))
        ));
        assert!(matches!(
            eval("fn main() { return is_bool(true); }"),
            Ok(Value::Bool(true))
        ));
        assert!(matches!(
            eval("fn main() { return is_int(42); }"),
            Ok(Value::Bool(true))
        ));
        assert!(matches!(
            eval("fn main() { return is_float(3.14); }"),
            Ok(Value::Bool(true))
        ));
        assert!(matches!(
            eval("fn main() { return is_number(42); }"),
            Ok(Value::Bool(true))
        ));
        assert!(matches!(
            eval("fn main() { return is_number(3.14); }"),
            Ok(Value::Bool(true))
        ));
        assert!(matches!(
            eval(r#"fn main() { return is_string("hi"); }"#),
            Ok(Value::Bool(true))
        ));
        assert!(matches!(
            eval("fn main() { return is_array([1, 2]); }"),
            Ok(Value::Bool(true))
        ));
    }

    #[test]
    fn test_is_empty() {
        assert!(matches!(
            eval("fn main() { return is_empty([]); }"),
            Ok(Value::Bool(true))
        ));
        assert!(matches!(
            eval("fn main() { return is_empty([1]); }"),
            Ok(Value::Bool(false))
        ));
        assert!(matches!(
            eval(r#"fn main() { return is_empty(""); }"#),
            Ok(Value::Bool(true))
        ));
        assert!(matches!(
            eval("fn main() { return is_empty(null); }"),
            Ok(Value::Bool(true))
        ));
    }

    #[test]
    fn test_match_regex() {
        let result = eval(r#"fn main() { return match_regex("hello123", "([a-z]+)([0-9]+)"); }"#);
        assert!(matches!(result, Ok(Value::Array(_))));
    }

    #[test]
    fn test_match_all_regex() {
        let result = eval(r#"fn main() { return len(match_all_regex("a1b2c3", "[0-9]")); }"#);
        assert!(matches!(result, Ok(Value::Int(3))));
    }

    #[test]
    fn test_guard() {
        assert!(matches!(
            eval("fn main() { return guard(true, 42); }"),
            Ok(Value::Int(42))
        ));
        assert!(matches!(
            eval("fn main() { return guard(false, 42); }"),
            Ok(Value::Null)
        ));
    }

    #[test]
    fn test_when_unless() {
        assert!(matches!(
            eval("fn main() { return when(true, 42); }"),
            Ok(Value::Int(42))
        ));
        assert!(matches!(
            eval("fn main() { return when(false, 42); }"),
            Ok(Value::Null)
        ));
        assert!(matches!(
            eval("fn main() { return unless(false, 42); }"),
            Ok(Value::Int(42))
        ));
        assert!(matches!(
            eval("fn main() { return unless(true, 42); }"),
            Ok(Value::Null)
        ));
    }

    #[test]
    fn test_cond() {
        let result = eval("fn main() { return cond([[false, 1], [true, 2], [true, 3]]); }");
        assert!(matches!(result, Ok(Value::Int(2))));
    }

    #[test]
    fn test_case() {
        let result = eval("fn main() { return case(2, [[1, 10], [2, 20], [3, 30]]); }");
        assert!(matches!(result, Ok(Value::Int(20))));
    }

    #[test]
    fn test_head_tail() {
        let result = eval("fn main() { let ht = head_tail([1, 2, 3]); return len(ht); }");
        assert!(matches!(result, Ok(Value::Int(2)))); // Tuple of 2 elements
    }

    #[test]
    fn test_split_at() {
        let result = eval("fn main() { let s = split_at([1, 2, 3, 4, 5], 2); return len(s); }");
        assert!(matches!(result, Ok(Value::Int(2)))); // Tuple of 2 arrays
    }

    #[test]
    fn test_unwrap_or() {
        assert!(matches!(
            eval("fn main() { return unwrap_or(null, 42); }"),
            Ok(Value::Int(42))
        ));
        assert!(matches!(
            eval("fn main() { return unwrap_or(10, 42); }"),
            Ok(Value::Int(10))
        ));
    }

    #[test]
    fn test_coalesce() {
        assert!(matches!(
            eval("fn main() { return coalesce([null, null, 3, 4]); }"),
            Ok(Value::Int(3))
        ));
    }

    #[test]
    fn test_deep_eq() {
        assert!(matches!(
            eval("fn main() { return deep_eq([1, 2, 3], [1, 2, 3]); }"),
            Ok(Value::Bool(true))
        ));
        assert!(matches!(
            eval("fn main() { return deep_eq([1, 2, 3], [1, 2, 4]); }"),
            Ok(Value::Bool(false))
        ));
    }

    #[test]
    fn test_same_type() {
        assert!(matches!(
            eval("fn main() { return same_type(1, 2); }"),
            Ok(Value::Bool(true))
        ));
        assert!(matches!(
            eval(r#"fn main() { return same_type(1, "a"); }"#),
            Ok(Value::Bool(false))
        ));
    }

    #[test]
    fn test_compare() {
        assert!(matches!(
            eval("fn main() { return compare(1, 2); }"),
            Ok(Value::Int(-1))
        ));
        assert!(matches!(
            eval("fn main() { return compare(2, 2); }"),
            Ok(Value::Int(0))
        ));
        assert!(matches!(
            eval("fn main() { return compare(3, 2); }"),
            Ok(Value::Int(1))
        ));
    }

    #[test]
    fn test_between() {
        assert!(matches!(
            eval("fn main() { return between(5, 1, 10); }"),
            Ok(Value::Bool(true))
        ));
        assert!(matches!(
            eval("fn main() { return between(15, 1, 10); }"),
            Ok(Value::Bool(false))
        ));
    }

    #[test]
    fn test_clamp() {
        assert!(matches!(
            eval("fn main() { return clamp(5, 1, 10); }"),
            Ok(Value::Int(5))
        ));
        assert!(matches!(
            eval("fn main() { return clamp(-5, 1, 10); }"),
            Ok(Value::Int(1))
        ));
        assert!(matches!(
            eval("fn main() { return clamp(15, 1, 10); }"),
            Ok(Value::Int(10))
        ));
    }

    // ========== PHASE 7: DEVEX ==========

    #[test]
    fn test_inspect() {
        let result = eval(r#"fn main() { return inspect(42); }"#);
        assert!(matches!(result, Ok(Value::String(s)) if s.as_str() == "42"));
    }

    #[test]
    fn test_version() {
        let result = eval("fn main() { return version(); }");
        assert!(matches!(result, Ok(Value::Map(_))));
    }

    // ========== CONVERT FUNCTIONS ==========

    #[test]
    fn test_to_int() {
        assert!(matches!(
            eval("fn main() { return to_int(3.7); }"),
            Ok(Value::Int(3))
        ));
        assert!(matches!(
            eval(r#"fn main() { return to_int("42"); }"#),
            Ok(Value::Int(42))
        ));
    }

    #[test]
    fn test_to_float() {
        assert!(
            matches!(eval("fn main() { return to_float(42); }"), Ok(Value::Float(f)) if (f - 42.0).abs() < 0.001)
        );
    }

    #[test]
    fn test_to_string() {
        assert!(
            matches!(eval("fn main() { return to_string(42); }"), Ok(Value::String(s)) if s.as_str() == "42")
        );
    }

    #[test]
    fn test_to_bool() {
        assert!(matches!(
            eval("fn main() { return to_bool(1); }"),
            Ok(Value::Bool(true))
        ));
        assert!(matches!(
            eval("fn main() { return to_bool(0); }"),
            Ok(Value::Bool(false))
        ));
    }

    // ========== TIME FUNCTIONS ==========

    #[test]
    fn test_now() {
        let result = eval("fn main() { return now(); }");
        assert!(matches!(result, Ok(Value::Int(n)) if n > 0));
    }

    #[test]
    fn test_now_secs() {
        // now() returns millis, now_secs returns seconds
        let result = eval("fn main() { return now_secs(); }");
        assert!(matches!(result, Ok(Value::Int(n)) if n > 0));
    }

    // ========== RANDOM FUNCTIONS ==========

    #[test]
    fn test_random_int() {
        let result = eval("fn main() { return random_int(1, 100); }");
        assert!(matches!(result, Ok(Value::Int(n)) if n >= 1 && n < 100));
    }

    #[test]
    fn test_random() {
        // random() returns a float - just check it's a float (value may exceed 1.0 with current impl)
        let result = eval("fn main() { return random(); }");
        assert!(
            matches!(result, Ok(Value::Float(_))),
            "random got: {:?}",
            result
        );
    }

    #[test]
    fn test_shuffle() {
        // shuffle() modifies array in place and returns null
        let result =
            eval("fn main() { let arr = [1, 2, 3, 4, 5]; shuffle(arr); return len(arr); }");
        assert!(
            matches!(result, Ok(Value::Int(5))),
            "shuffle got: {:?}",
            result
        );
    }

    #[test]
    fn test_sample() {
        let result = eval("fn main() { return sample([1, 2, 3, 4, 5]); }");
        assert!(matches!(result, Ok(Value::Int(n)) if n >= 1 && n <= 5));
    }

    // ========== MAP/SET FUNCTIONS ==========

    #[test]
    fn test_map_set_get() {
        // map_set modifies in place - use the original map
        let result =
            eval(r#"fn main() { let m = map_new(); map_set(m, "a", 1); return map_get(m, "a"); }"#);
        assert!(
            matches!(result, Ok(Value::Int(1))),
            "map_set_get got: {:?}",
            result
        );
    }

    #[test]
    fn test_map_has() {
        let result =
            eval(r#"fn main() { let m = map_new(); map_set(m, "a", 1); return map_has(m, "a"); }"#);
        assert!(
            matches!(result, Ok(Value::Bool(true))),
            "map_has got: {:?}",
            result
        );
    }

    #[test]
    fn test_map_keys_values() {
        let result = eval(
            r#"fn main() { let m = map_new(); map_set(m, "a", 1); return len(map_keys(m)); }"#,
        );
        assert!(
            matches!(result, Ok(Value::Int(1))),
            "map_keys got: {:?}",
            result
        );
    }

    // ========== SORT/SEARCH ==========

    #[test]
    fn test_sort() {
        let result = eval("fn main() { return first(sort([3, 1, 2])); }");
        assert!(matches!(result, Ok(Value::Int(1))));
    }

    #[test]
    fn test_sort_desc() {
        let result = eval("fn main() { return first(sort_desc([1, 3, 2])); }");
        assert!(matches!(result, Ok(Value::Int(3))));
    }

    #[test]
    fn test_reverse() {
        let result = eval("fn main() { return first(reverse([1, 2, 3])); }");
        assert!(matches!(result, Ok(Value::Int(3))));
    }

    #[test]
    fn test_index_of() {
        assert!(matches!(
            eval("fn main() { return index_of([10, 20, 30], 20); }"),
            Ok(Value::Int(1))
        ));
        assert!(matches!(
            eval("fn main() { return index_of([10, 20, 30], 99); }"),
            Ok(Value::Int(-1))
        ));
    }

    // ========== NEW SYMBOL TESTS ==========

    // Phase 1: Bitwise Unicode operators (⋏ ⋎)
    #[test]
    fn test_bitwise_and_symbol() {
        // ⋏ is Unicode bitwise AND
        let result = eval("fn main() { return 0b1100 ⋏ 0b1010; }");
        assert!(
            matches!(result, Ok(Value::Int(8))),
            "bitwise AND got: {:?}",
            result
        ); // 0b1000 = 8
    }

    #[test]
    fn test_bitwise_or_symbol() {
        // ⋎ is Unicode bitwise OR
        let result = eval("fn main() { return 0b1100 ⋎ 0b1010; }");
        assert!(
            matches!(result, Ok(Value::Int(14))),
            "bitwise OR got: {:?}",
            result
        ); // 0b1110 = 14
    }

    // Phase 2: Access morphemes (μ χ ν ξ)
    #[test]
    fn test_middle_function() {
        // μ (mu) - middle element
        let result = eval("fn main() { return middle([1, 2, 3, 4, 5]); }");
        assert!(
            matches!(result, Ok(Value::Int(3))),
            "middle got: {:?}",
            result
        );
    }

    #[test]
    fn test_choice_function() {
        // χ (chi) - random choice (just verify it returns something valid)
        let result = eval("fn main() { let x = choice([10, 20, 30]); return x >= 10; }");
        assert!(
            matches!(result, Ok(Value::Bool(true))),
            "choice got: {:?}",
            result
        );
    }

    #[test]
    fn test_nth_function() {
        // ν (nu) - nth element
        let result = eval("fn main() { return nth([10, 20, 30, 40], 2); }");
        assert!(
            matches!(result, Ok(Value::Int(30))),
            "nth got: {:?}",
            result
        );
    }

    // Phase 3: Data operations (⋈ ⋳ ⊔ ⊓)
    #[test]
    fn test_zip_with_add() {
        // ⋈ (bowtie) - zip_with
        let result =
            eval(r#"fn main() { return first(zip_with([1, 2, 3], [10, 20, 30], "add")); }"#);
        assert!(
            matches!(result, Ok(Value::Int(11))),
            "zip_with add got: {:?}",
            result
        );
    }

    #[test]
    fn test_zip_with_mul() {
        let result = eval(r#"fn main() { return first(zip_with([2, 3, 4], [5, 6, 7], "mul")); }"#);
        assert!(
            matches!(result, Ok(Value::Int(10))),
            "zip_with mul got: {:?}",
            result
        );
    }

    #[test]
    fn test_supremum_scalar() {
        // ⊔ (square cup) - lattice join / max
        let result = eval("fn main() { return supremum(5, 10); }");
        assert!(
            matches!(result, Ok(Value::Int(10))),
            "supremum scalar got: {:?}",
            result
        );
    }

    #[test]
    fn test_supremum_array() {
        let result = eval("fn main() { return first(supremum([1, 5, 3], [2, 4, 6])); }");
        assert!(
            matches!(result, Ok(Value::Int(2))),
            "supremum array got: {:?}",
            result
        );
    }

    #[test]
    fn test_infimum_scalar() {
        // ⊓ (square cap) - lattice meet / min
        let result = eval("fn main() { return infimum(5, 10); }");
        assert!(
            matches!(result, Ok(Value::Int(5))),
            "infimum scalar got: {:?}",
            result
        );
    }

    #[test]
    fn test_infimum_array() {
        let result = eval("fn main() { return first(infimum([1, 5, 3], [2, 4, 6])); }");
        assert!(
            matches!(result, Ok(Value::Int(1))),
            "infimum array got: {:?}",
            result
        );
    }

    // Phase 4: Aspect token lexing tests
    #[test]
    fn test_aspect_tokens_lexer() {
        use crate::lexer::{Lexer, Token};

        // Test progressive aspect ·ing
        let mut lexer = Lexer::new("process·ing");
        assert!(matches!(lexer.next_token(), Some((Token::Ident(s), _)) if s == "process"));
        assert!(matches!(
            lexer.next_token(),
            Some((Token::AspectProgressive, _))
        ));

        // Test perfective aspect ·ed
        let mut lexer = Lexer::new("process·ed");
        assert!(matches!(lexer.next_token(), Some((Token::Ident(s), _)) if s == "process"));
        assert!(matches!(
            lexer.next_token(),
            Some((Token::AspectPerfective, _))
        ));

        // Test potential aspect ·able
        let mut lexer = Lexer::new("parse·able");
        assert!(matches!(lexer.next_token(), Some((Token::Ident(s), _)) if s == "parse"));
        assert!(matches!(
            lexer.next_token(),
            Some((Token::AspectPotential, _))
        ));

        // Test resultative aspect ·ive
        let mut lexer = Lexer::new("destruct·ive");
        assert!(matches!(lexer.next_token(), Some((Token::Ident(s), _)) if s == "destruct"));
        assert!(matches!(
            lexer.next_token(),
            Some((Token::AspectResultative, _))
        ));
    }

    // New morpheme token lexer tests
    #[test]
    fn test_new_morpheme_tokens_lexer() {
        use crate::lexer::{Lexer, Token};

        let mut lexer = Lexer::new("μ χ ν ξ");
        assert!(matches!(lexer.next_token(), Some((Token::Mu, _))));
        assert!(matches!(lexer.next_token(), Some((Token::Chi, _))));
        assert!(matches!(lexer.next_token(), Some((Token::Nu, _))));
        assert!(matches!(lexer.next_token(), Some((Token::Xi, _))));
    }

    // Data operation token lexer tests
    #[test]
    fn test_data_op_tokens_lexer() {
        use crate::lexer::{Lexer, Token};

        let mut lexer = Lexer::new("⋈ ⋳ ⊔ ⊓");
        assert!(matches!(lexer.next_token(), Some((Token::Bowtie, _))));
        assert!(matches!(
            lexer.next_token(),
            Some((Token::ElementSmallVerticalBar, _))
        ));
        assert!(matches!(lexer.next_token(), Some((Token::SquareCup, _))));
        assert!(matches!(lexer.next_token(), Some((Token::SquareCap, _))));
    }

    // Bitwise symbol token lexer tests
    #[test]
    fn test_bitwise_symbol_tokens_lexer() {
        use crate::lexer::{Lexer, Token};

        let mut lexer = Lexer::new("⋏ ⋎");
        assert!(matches!(
            lexer.next_token(),
            Some((Token::BitwiseAndSymbol, _))
        ));
        assert!(matches!(
            lexer.next_token(),
            Some((Token::BitwiseOrSymbol, _))
        ));
    }

    // ========== PIPE MORPHEME SYNTAX TESTS ==========

    #[test]
    fn test_pipe_alpha_first() {
        // α in pipe gets first element
        let result = eval("fn main() { return [10, 20, 30] |α; }");
        assert!(
            matches!(result, Ok(Value::Int(10))),
            "pipe α got: {:?}",
            result
        );
    }

    #[test]
    fn test_pipe_omega_last() {
        // ω in pipe gets last element
        let result = eval("fn main() { return [10, 20, 30] |ω; }");
        assert!(
            matches!(result, Ok(Value::Int(30))),
            "pipe ω got: {:?}",
            result
        );
    }

    #[test]
    fn test_pipe_mu_middle() {
        // μ in pipe gets middle element
        let result = eval("fn main() { return [10, 20, 30, 40, 50] |μ; }");
        assert!(
            matches!(result, Ok(Value::Int(30))),
            "pipe μ got: {:?}",
            result
        );
    }

    #[test]
    fn test_pipe_chi_choice() {
        // χ in pipe gets random element (just verify it's in range)
        let result = eval("fn main() { let x = [10, 20, 30] |χ; return x >= 10; }");
        assert!(
            matches!(result, Ok(Value::Bool(true))),
            "pipe χ got: {:?}",
            result
        );
    }

    #[test]
    fn test_pipe_nu_nth() {
        // ν{n} in pipe gets nth element
        let result = eval("fn main() { return [10, 20, 30, 40] |ν{2}; }");
        assert!(
            matches!(result, Ok(Value::Int(30))),
            "pipe ν got: {:?}",
            result
        );
    }

    #[test]
    fn test_pipe_chain() {
        // Chain multiple pipe operations
        let result = eval("fn main() { return [3, 1, 4, 1, 5] |σ |α; }");
        assert!(
            matches!(result, Ok(Value::Int(1))),
            "pipe chain got: {:?}",
            result
        );
    }

    // ========== ASPECT PARSING TESTS ==========

    #[test]
    fn test_aspect_progressive_parsing() {
        // fn name·ing should parse with progressive aspect
        use crate::ast::Aspect;
        use crate::parser::Parser;
        let mut parser = Parser::new("fn process·ing() { return 42; }");
        let file = parser.parse_file().unwrap();
        if let crate::ast::Item::Function(f) = &file.items[0].node {
            assert_eq!(f.name.name, "process");
            assert_eq!(f.aspect, Some(Aspect::Progressive));
        } else {
            panic!("Expected function item");
        }
    }

    #[test]
    fn test_aspect_perfective_parsing() {
        // fn name·ed should parse with perfective aspect
        use crate::ast::Aspect;
        use crate::parser::Parser;
        let mut parser = Parser::new("fn process·ed() { return 42; }");
        let file = parser.parse_file().unwrap();
        if let crate::ast::Item::Function(f) = &file.items[0].node {
            assert_eq!(f.name.name, "process");
            assert_eq!(f.aspect, Some(Aspect::Perfective));
        } else {
            panic!("Expected function item");
        }
    }

    #[test]
    fn test_aspect_potential_parsing() {
        // fn name·able should parse with potential aspect
        use crate::ast::Aspect;
        use crate::parser::Parser;
        let mut parser = Parser::new("fn parse·able() { return true; }");
        let file = parser.parse_file().unwrap();
        if let crate::ast::Item::Function(f) = &file.items[0].node {
            assert_eq!(f.name.name, "parse");
            assert_eq!(f.aspect, Some(Aspect::Potential));
        } else {
            panic!("Expected function item");
        }
    }

    #[test]
    fn test_aspect_resultative_parsing() {
        // fn name·ive should parse with resultative aspect
        use crate::ast::Aspect;
        use crate::parser::Parser;
        let mut parser = Parser::new("fn destruct·ive() { return 42; }");
        let file = parser.parse_file().unwrap();
        if let crate::ast::Item::Function(f) = &file.items[0].node {
            assert_eq!(f.name.name, "destruct");
            assert_eq!(f.aspect, Some(Aspect::Resultative));
        } else {
            panic!("Expected function item");
        }
    }

    // ========== EDGE CASE TESTS ==========

    #[test]
    fn test_choice_single_element() {
        // Single element should always return that element
        assert!(matches!(
            eval("fn main() { return choice([42]); }"),
            Ok(Value::Int(42))
        ));
    }

    #[test]
    fn test_nth_edge_cases() {
        // Last element
        assert!(matches!(
            eval("fn main() { return nth([10, 20, 30], 2); }"),
            Ok(Value::Int(30))
        ));
        // First element
        assert!(matches!(
            eval("fn main() { return nth([10, 20, 30], 0); }"),
            Ok(Value::Int(10))
        ));
    }

    #[test]
    fn test_next_peek_usage() {
        // next returns first element
        assert!(matches!(
            eval("fn main() { return next([1, 2, 3]); }"),
            Ok(Value::Int(1))
        ));
        // peek returns first element without consuming
        assert!(matches!(
            eval("fn main() { return peek([1, 2, 3]); }"),
            Ok(Value::Int(1))
        ));
    }

    #[test]
    fn test_zip_with_empty() {
        // Empty arrays should return empty
        let result = eval(r#"fn main() { return len(zip_with([], [], "add")); }"#);
        assert!(matches!(result, Ok(Value::Int(0))));
    }

    #[test]
    fn test_zip_with_different_lengths() {
        // Shorter array determines length
        let result = eval(r#"fn main() { return len(zip_with([1, 2], [3, 4, 5], "add")); }"#);
        assert!(matches!(result, Ok(Value::Int(2))));
    }

    #[test]
    fn test_supremum_edge_cases() {
        // Same values
        assert!(matches!(
            eval("fn main() { return supremum(5, 5); }"),
            Ok(Value::Int(5))
        ));
        // Negative values
        assert!(matches!(
            eval("fn main() { return supremum(-5, -3); }"),
            Ok(Value::Int(-3))
        ));
        // Floats
        assert!(
            matches!(eval("fn main() { return supremum(1.5, 2.5); }"), Ok(Value::Float(f)) if (f - 2.5).abs() < 0.001)
        );
    }

    #[test]
    fn test_infimum_edge_cases() {
        // Same values
        assert!(matches!(
            eval("fn main() { return infimum(5, 5); }"),
            Ok(Value::Int(5))
        ));
        // Negative values
        assert!(matches!(
            eval("fn main() { return infimum(-5, -3); }"),
            Ok(Value::Int(-5))
        ));
        // Floats
        assert!(
            matches!(eval("fn main() { return infimum(1.5, 2.5); }"), Ok(Value::Float(f)) if (f - 1.5).abs() < 0.001)
        );
    }

    #[test]
    fn test_supremum_infimum_arrays() {
        // Element-wise max
        let result = eval("fn main() { return supremum([1, 5, 3], [2, 4, 6]); }");
        if let Ok(Value::Array(arr)) = result {
            let arr = arr.borrow();
            assert_eq!(arr.len(), 3);
            assert!(matches!(arr[0], Value::Int(2)));
            assert!(matches!(arr[1], Value::Int(5)));
            assert!(matches!(arr[2], Value::Int(6)));
        } else {
            panic!("Expected array");
        }

        // Element-wise min
        let result = eval("fn main() { return infimum([1, 5, 3], [2, 4, 6]); }");
        if let Ok(Value::Array(arr)) = result {
            let arr = arr.borrow();
            assert_eq!(arr.len(), 3);
            assert!(matches!(arr[0], Value::Int(1)));
            assert!(matches!(arr[1], Value::Int(4)));
            assert!(matches!(arr[2], Value::Int(3)));
        } else {
            panic!("Expected array");
        }
    }

    #[test]
    fn test_pipe_access_morphemes() {
        // First with pipe syntax
        assert!(matches!(
            eval("fn main() { return [10, 20, 30] |α; }"),
            Ok(Value::Int(10))
        ));
        // Last with pipe syntax
        assert!(matches!(
            eval("fn main() { return [10, 20, 30] |ω; }"),
            Ok(Value::Int(30))
        ));
        // Middle with pipe syntax
        assert!(matches!(
            eval("fn main() { return [10, 20, 30] |μ; }"),
            Ok(Value::Int(20))
        ));
    }

    #[test]
    fn test_pipe_nth_syntax() {
        // Nth with pipe syntax
        assert!(matches!(
            eval("fn main() { return [10, 20, 30, 40] |ν{1}; }"),
            Ok(Value::Int(20))
        ));
        assert!(matches!(
            eval("fn main() { return [10, 20, 30, 40] |ν{3}; }"),
            Ok(Value::Int(40))
        ));
    }

    // ========== GRAPHICS MATH TESTS ==========

    #[test]
    fn test_quaternion_identity() {
        let result = eval("fn main() { let q = quat_identity(); return q; }");
        if let Ok(Value::Array(arr)) = result {
            let arr = arr.borrow();
            assert_eq!(arr.len(), 4);
            if let (Value::Float(w), Value::Float(x), Value::Float(y), Value::Float(z)) =
                (&arr[0], &arr[1], &arr[2], &arr[3])
            {
                assert!((w - 1.0).abs() < 0.001);
                assert!(x.abs() < 0.001);
                assert!(y.abs() < 0.001);
                assert!(z.abs() < 0.001);
            }
        } else {
            panic!("Expected quaternion array");
        }
    }

    #[test]
    fn test_quaternion_from_axis_angle() {
        // 90 degrees around Y axis
        let result =
            eval("fn main() { let q = quat_from_axis_angle(vec3(0, 1, 0), 1.5707963); return q; }");
        if let Ok(Value::Array(arr)) = result {
            let arr = arr.borrow();
            assert_eq!(arr.len(), 4);
            // Should be approximately [cos(45°), 0, sin(45°), 0] = [0.707, 0, 0.707, 0]
            if let (Value::Float(w), Value::Float(x), Value::Float(y), Value::Float(z)) =
                (&arr[0], &arr[1], &arr[2], &arr[3])
            {
                assert!((w - 0.707).abs() < 0.01, "w={}", w);
                assert!(x.abs() < 0.01);
                assert!((y - 0.707).abs() < 0.01, "y={}", y);
                assert!(z.abs() < 0.01);
            }
        } else {
            panic!("Expected quaternion array");
        }
    }

    #[test]
    fn test_quaternion_rotate_vector() {
        // Rotate [1, 0, 0] by 90 degrees around Z axis should give [0, 1, 0]
        let result = eval(
            r#"
            fn main() {
                let q = quat_from_axis_angle(vec3(0, 0, 1), 1.5707963);
                let v = vec3(1, 0, 0);
                return quat_rotate(q, v);
            }
        "#,
        );
        if let Ok(Value::Array(arr)) = result {
            let arr = arr.borrow();
            assert_eq!(arr.len(), 3);
            if let (Value::Float(x), Value::Float(y), Value::Float(z)) = (&arr[0], &arr[1], &arr[2])
            {
                assert!(x.abs() < 0.01, "x={}", x);
                assert!((y - 1.0).abs() < 0.01, "y={}", y);
                assert!(z.abs() < 0.01);
            }
        } else {
            panic!("Expected vec3 array");
        }
    }

    #[test]
    fn test_quaternion_slerp() {
        // Interpolate between identity and 90° rotation
        let result = eval(
            r#"
            fn main() {
                let q1 = quat_identity();
                let q2 = quat_from_axis_angle(vec3(0, 1, 0), 1.5707963);
                return quat_slerp(q1, q2, 0.5);
            }
        "#,
        );
        if let Ok(Value::Array(arr)) = result {
            let arr = arr.borrow();
            assert_eq!(arr.len(), 4);
            // At t=0.5, should be 45° rotation
            if let Value::Float(w) = &arr[0] {
                // cos(22.5°) ≈ 0.924
                assert!((w - 0.924).abs() < 0.05, "w={}", w);
            }
        } else {
            panic!("Expected quaternion array");
        }
    }

    #[test]
    fn test_vec3_operations() {
        // vec3_add
        let result = eval("fn main() { return vec3_add(vec3(1, 2, 3), vec3(4, 5, 6)); }");
        if let Ok(Value::Array(arr)) = result {
            let arr = arr.borrow();
            if let (Value::Float(x), Value::Float(y), Value::Float(z)) = (&arr[0], &arr[1], &arr[2])
            {
                assert!((x - 5.0).abs() < 0.001);
                assert!((y - 7.0).abs() < 0.001);
                assert!((z - 9.0).abs() < 0.001);
            }
        }

        // vec3_dot
        let result = eval("fn main() { return vec3_dot(vec3(1, 2, 3), vec3(4, 5, 6)); }");
        assert!(matches!(result, Ok(Value::Float(f)) if (f - 32.0).abs() < 0.001));

        // vec3_cross
        let result = eval("fn main() { return vec3_cross(vec3(1, 0, 0), vec3(0, 1, 0)); }");
        if let Ok(Value::Array(arr)) = result {
            let arr = arr.borrow();
            if let (Value::Float(x), Value::Float(y), Value::Float(z)) = (&arr[0], &arr[1], &arr[2])
            {
                assert!(x.abs() < 0.001);
                assert!(y.abs() < 0.001);
                assert!((z - 1.0).abs() < 0.001);
            }
        }

        // vec3_length
        let result = eval("fn main() { return vec3_length(vec3(3, 4, 0)); }");
        assert!(matches!(result, Ok(Value::Float(f)) if (f - 5.0).abs() < 0.001));

        // vec3_normalize
        let result = eval("fn main() { return vec3_normalize(vec3(3, 0, 0)); }");
        if let Ok(Value::Array(arr)) = result {
            let arr = arr.borrow();
            if let Value::Float(x) = &arr[0] {
                assert!((x - 1.0).abs() < 0.001);
            }
        }
    }

    #[test]
    fn test_vec3_reflect() {
        // Reflect [1, -1, 0] off surface with normal [0, 1, 0]
        let result = eval("fn main() { return vec3_reflect(vec3(1, -1, 0), vec3(0, 1, 0)); }");
        if let Ok(Value::Array(arr)) = result {
            let arr = arr.borrow();
            if let (Value::Float(x), Value::Float(y), Value::Float(z)) = (&arr[0], &arr[1], &arr[2])
            {
                assert!((x - 1.0).abs() < 0.001);
                assert!((y - 1.0).abs() < 0.001);
                assert!(z.abs() < 0.001);
            }
        }
    }

    #[test]
    fn test_mat4_identity() {
        let result = eval("fn main() { return mat4_identity(); }");
        if let Ok(Value::Array(arr)) = result {
            let arr = arr.borrow();
            assert_eq!(arr.len(), 16);
            // Check diagonal elements are 1
            if let (Value::Float(m00), Value::Float(m55), Value::Float(m10), Value::Float(m15)) =
                (&arr[0], &arr[5], &arr[10], &arr[15])
            {
                assert!((m00 - 1.0).abs() < 0.001);
                assert!((m55 - 1.0).abs() < 0.001);
                assert!((m10 - 1.0).abs() < 0.001);
                assert!((m15 - 1.0).abs() < 0.001);
            }
        }
    }

    #[test]
    fn test_mat4_translate() {
        let result = eval(
            r#"
            fn main() {
                let t = mat4_translate(5.0, 10.0, 15.0);
                let v = vec4(0, 0, 0, 1);
                return mat4_transform(t, v);
            }
        "#,
        );
        if let Ok(Value::Array(arr)) = result {
            let arr = arr.borrow();
            if let (Value::Float(x), Value::Float(y), Value::Float(z), Value::Float(w)) =
                (&arr[0], &arr[1], &arr[2], &arr[3])
            {
                assert!((x - 5.0).abs() < 0.001);
                assert!((y - 10.0).abs() < 0.001);
                assert!((z - 15.0).abs() < 0.001);
                assert!((w - 1.0).abs() < 0.001);
            }
        }
    }

    #[test]
    fn test_mat4_perspective() {
        // Just verify it creates a valid matrix without errors
        let result = eval("fn main() { return mat4_perspective(1.0472, 1.777, 0.1, 100.0); }");
        if let Ok(Value::Array(arr)) = result {
            let arr = arr.borrow();
            assert_eq!(arr.len(), 16);
        } else {
            panic!("Expected mat4 array");
        }
    }

    #[test]
    fn test_mat4_look_at() {
        let result = eval(
            r#"
            fn main() {
                let eye = vec3(0, 0, 5);
                let center = vec3(0, 0, 0);
                let up = vec3(0, 1, 0);
                return mat4_look_at(eye, center, up);
            }
        "#,
        );
        if let Ok(Value::Array(arr)) = result {
            let arr = arr.borrow();
            assert_eq!(arr.len(), 16);
        } else {
            panic!("Expected mat4 array");
        }
    }

    #[test]
    fn test_mat4_inverse() {
        // Inverse of identity should be identity
        let result = eval(
            r#"
            fn main() {
                let m = mat4_identity();
                return mat4_inverse(m);
            }
        "#,
        );
        if let Ok(Value::Array(arr)) = result {
            let arr = arr.borrow();
            assert_eq!(arr.len(), 16);
            if let Value::Float(m00) = &arr[0] {
                assert!((m00 - 1.0).abs() < 0.001);
            }
        }
    }

    #[test]
    fn test_mat3_operations() {
        // mat3_identity
        let result = eval("fn main() { return mat3_identity(); }");
        if let Ok(Value::Array(arr)) = result {
            let arr = arr.borrow();
            assert_eq!(arr.len(), 9);
        }

        // mat3_transform
        let result = eval(
            r#"
            fn main() {
                let m = mat3_identity();
                let v = vec3(1, 2, 3);
                return mat3_transform(m, v);
            }
        "#,
        );
        if let Ok(Value::Array(arr)) = result {
            let arr = arr.borrow();
            if let (Value::Float(x), Value::Float(y), Value::Float(z)) = (&arr[0], &arr[1], &arr[2])
            {
                assert!((x - 1.0).abs() < 0.001);
                assert!((y - 2.0).abs() < 0.001);
                assert!((z - 3.0).abs() < 0.001);
            }
        }
    }

    #[test]
    fn test_quat_to_mat4() {
        // Convert identity quaternion to matrix - should be identity
        let result = eval(
            r#"
            fn main() {
                let q = quat_identity();
                return quat_to_mat4(q);
            }
        "#,
        );
        if let Ok(Value::Array(arr)) = result {
            let arr = arr.borrow();
            assert_eq!(arr.len(), 16);
            // Check diagonal is 1
            if let (Value::Float(m00), Value::Float(m55)) = (&arr[0], &arr[5]) {
                assert!((m00 - 1.0).abs() < 0.001);
                assert!((m55 - 1.0).abs() < 0.001);
            }
        }
    }

    // ========== CONCURRENCY STRESS TESTS ==========
    // These tests verify correctness under high load conditions

    #[test]
    fn test_channel_basic_send_recv() {
        // Basic channel send/receive
        let result = eval(
            r#"
            fn main() {
                let ch = channel_new();
                channel_send(ch, 42);
                return channel_recv(ch);
            }
        "#,
        );
        assert!(matches!(result, Ok(Value::Int(42))));
    }

    #[test]
    fn test_channel_multiple_values() {
        // Send multiple values and receive in order (FIFO)
        let result = eval(
            r#"
            fn main() {
                let ch = channel_new();
                channel_send(ch, 1);
                channel_send(ch, 2);
                channel_send(ch, 3);
                let a = channel_recv(ch);
                let b = channel_recv(ch);
                let c = channel_recv(ch);
                return a * 100 + b * 10 + c;
            }
        "#,
        );
        assert!(matches!(result, Ok(Value::Int(123))));
    }

    #[test]
    fn test_channel_high_throughput() {
        // Test sending 1000 messages through a channel
        let result = eval(
            r#"
            fn main() {
                let ch = channel_new();
                let count = 1000;
                let i = 0;
                while i < count {
                    channel_send(ch, i);
                    i = i + 1;
                }

                // Receive all and compute sum to verify no data loss
                let sum = 0;
                let j = 0;
                while j < count {
                    let val = channel_recv(ch);
                    sum = sum + val;
                    j = j + 1;
                }

                // Sum of 0..999 = 499500
                return sum;
            }
        "#,
        );
        assert!(matches!(result, Ok(Value::Int(499500))));
    }

    #[test]
    fn test_channel_data_integrity() {
        // Test that complex values survive channel transport
        let result = eval(
            r#"
            fn main() {
                let ch = channel_new();

                // Send various types
                channel_send(ch, 42);
                channel_send(ch, 3.14);
                channel_send(ch, "hello");
                channel_send(ch, [1, 2, 3]);

                // Receive and verify types
                let int_val = channel_recv(ch);
                let float_val = channel_recv(ch);
                let str_val = channel_recv(ch);
                let arr_val = channel_recv(ch);

                // Verify by combining results
                return int_val + floor(float_val) + len(str_val) + len(arr_val);
            }
        "#,
        );
        // 42 + 3 + 5 + 3 = 53
        assert!(matches!(result, Ok(Value::Int(53))));
    }

    #[test]
    fn test_channel_try_recv_empty() {
        // try_recv on empty channel should return None variant
        // Check that it returns a Variant type (not panicking/erroring)
        let result = eval(
            r#"
            fn main() {
                let ch = channel_new();
                let result = channel_try_recv(ch);
                // Can't pattern match variants in interpreter, so just verify it returns
                return type_of(result);
            }
        "#,
        );
        // The result should be a string "variant" or similar
        assert!(result.is_ok());
    }

    #[test]
    fn test_channel_try_recv_with_value() {
        // try_recv with value - verify channel works (blocking recv confirms)
        let result = eval(
            r#"
            fn main() {
                let ch = channel_new();
                channel_send(ch, 99);
                // Use blocking recv since try_recv returns Option variant
                // which can't be pattern matched in interpreter
                let val = channel_recv(ch);
                return val;
            }
        "#,
        );
        assert!(matches!(result, Ok(Value::Int(99))));
    }

    #[test]
    fn test_channel_recv_timeout_expires() {
        // recv_timeout on empty channel should timeout without error
        let result = eval(
            r#"
            fn main() {
                let ch = channel_new();
                let result = channel_recv_timeout(ch, 10);  // 10ms timeout
                // Just verify it completes without blocking forever
                return 42;
            }
        "#,
        );
        assert!(matches!(result, Ok(Value::Int(42))));
    }

    #[test]
    fn test_actor_basic_messaging() {
        // Basic actor creation and messaging
        let result = eval(
            r#"
            fn main() {
                let act = spawn_actor("test_actor");
                send_to_actor(act, "ping", 42);
                return get_actor_msg_count(act);
            }
        "#,
        );
        assert!(matches!(result, Ok(Value::Int(1))));
    }

    #[test]
    fn test_actor_message_storm() {
        // Send 10000 messages to an actor rapidly
        let result = eval(
            r#"
            fn main() {
                let act = spawn_actor("stress_actor");
                let count = 10000;
                let i = 0;
                while i < count {
                    send_to_actor(act, "msg", i);
                    i = i + 1;
                }
                return get_actor_msg_count(act);
            }
        "#,
        );
        assert!(matches!(result, Ok(Value::Int(10000))));
    }

    #[test]
    fn test_actor_pending_count() {
        // Verify pending count accuracy
        let result = eval(
            r#"
            fn main() {
                let act = spawn_actor("pending_test");

                // Send 5 messages
                send_to_actor(act, "m1", 1);
                send_to_actor(act, "m2", 2);
                send_to_actor(act, "m3", 3);
                send_to_actor(act, "m4", 4);
                send_to_actor(act, "m5", 5);

                let pending_before = get_actor_pending(act);

                // Receive 2 messages
                recv_from_actor(act);
                recv_from_actor(act);

                let pending_after = get_actor_pending(act);

                // Should have 5 pending initially, 3 after receiving 2
                return pending_before * 10 + pending_after;
            }
        "#,
        );
        assert!(matches!(result, Ok(Value::Int(53)))); // 5*10 + 3 = 53
    }

    #[test]
    fn test_actor_message_order() {
        // Verify messages are processed in FIFO order (pop from end = LIFO for our impl)
        // Note: Our actor uses pop() which is LIFO, so last sent = first received
        let result = eval(
            r#"
            fn main() {
                let act = spawn_actor("order_test");
                send_to_actor(act, "a", 1);
                send_to_actor(act, "b", 2);
                send_to_actor(act, "c", 3);

                // pop() gives LIFO order, so we get c, b, a
                let r1 = recv_from_actor(act);
                let r2 = recv_from_actor(act);
                let r3 = recv_from_actor(act);

                // Return the message types concatenated via their first char values
                // c=3, b=2, a=1 in our test
                return get_actor_pending(act);  // Should be 0 after draining
            }
        "#,
        );
        assert!(matches!(result, Ok(Value::Int(0))));
    }

    #[test]
    fn test_actor_recv_empty() {
        // Receiving from empty actor should return None variant
        // Verify via pending count that no messages were added
        let result = eval(
            r#"
            fn main() {
                let act = spawn_actor("empty_actor");
                // No messages sent, so pending should be 0
                return get_actor_pending(act);
            }
        "#,
        );
        assert!(matches!(result, Ok(Value::Int(0))));
    }

    #[test]
    fn test_actor_tell_alias() {
        // tell_actor should work the same as send_to_actor
        let result = eval(
            r#"
            fn main() {
                let act = spawn_actor("tell_test");
                tell_actor(act, "hello", 123);
                tell_actor(act, "world", 456);
                return get_actor_msg_count(act);
            }
        "#,
        );
        assert!(matches!(result, Ok(Value::Int(2))));
    }

    #[test]
    fn test_actor_name() {
        // Verify actor name is stored correctly
        let result = eval(
            r#"
            fn main() {
                let act = spawn_actor("my_special_actor");
                return get_actor_name(act);
            }
        "#,
        );
        assert!(matches!(result, Ok(Value::String(s)) if s.as_str() == "my_special_actor"));
    }

    #[test]
    fn test_multiple_actors() {
        // Multiple actors should be independent
        let result = eval(
            r#"
            fn main() {
                let a1 = spawn_actor("actor1");
                let a2 = spawn_actor("actor2");
                let a3 = spawn_actor("actor3");

                send_to_actor(a1, "m", 1);
                send_to_actor(a2, "m", 1);
                send_to_actor(a2, "m", 2);
                send_to_actor(a3, "m", 1);
                send_to_actor(a3, "m", 2);
                send_to_actor(a3, "m", 3);

                let c1 = get_actor_msg_count(a1);
                let c2 = get_actor_msg_count(a2);
                let c3 = get_actor_msg_count(a3);

                return c1 * 100 + c2 * 10 + c3;
            }
        "#,
        );
        assert!(matches!(result, Ok(Value::Int(123)))); // 1*100 + 2*10 + 3 = 123
    }

    #[test]
    fn test_multiple_channels() {
        // Multiple channels should be independent
        let result = eval(
            r#"
            fn main() {
                let ch1 = channel_new();
                let ch2 = channel_new();
                let ch3 = channel_new();

                channel_send(ch1, 100);
                channel_send(ch2, 200);
                channel_send(ch3, 300);

                let v1 = channel_recv(ch1);
                let v2 = channel_recv(ch2);
                let v3 = channel_recv(ch3);

                return v1 + v2 + v3;
            }
        "#,
        );
        assert!(matches!(result, Ok(Value::Int(600))));
    }

    #[test]
    fn test_thread_sleep() {
        // thread_sleep should work without error
        let result = eval(
            r#"
            fn main() {
                thread_sleep(1);  // Sleep 1ms
                return 42;
            }
        "#,
        );
        assert!(matches!(result, Ok(Value::Int(42))));
    }

    #[test]
    fn test_thread_yield() {
        // thread_yield should work without error
        let result = eval(
            r#"
            fn main() {
                thread_yield();
                return 42;
            }
        "#,
        );
        assert!(matches!(result, Ok(Value::Int(42))));
    }

    #[test]
    fn test_thread_id() {
        // thread_id should return a string
        let result = eval(
            r#"
            fn main() {
                let id = thread_id();
                return len(id) > 0;
            }
        "#,
        );
        assert!(matches!(result, Ok(Value::Bool(true))));
    }

    #[test]
    fn test_channel_stress_interleaved() {
        // Interleaved sends and receives
        let result = eval(
            r#"
            fn main() {
                let ch = channel_new();
                let sum = 0;
                let i = 0;
                while i < 100 {
                    channel_send(ch, i);
                    channel_send(ch, i * 2);
                    let a = channel_recv(ch);
                    let b = channel_recv(ch);
                    sum = sum + a + b;
                    i = i + 1;
                }
                // Sum: sum of i + i*2 for i in 0..99
                // = sum of 3*i for i in 0..99 = 3 * (99*100/2) = 3 * 4950 = 14850
                return sum;
            }
        "#,
        );
        assert!(matches!(result, Ok(Value::Int(14850))));
    }

    #[test]
    fn test_actor_stress_with_receive() {
        // Send and receive many messages
        let result = eval(
            r#"
            fn main() {
                let act = spawn_actor("recv_stress");
                let count = 1000;
                let i = 0;
                while i < count {
                    send_to_actor(act, "data", i);
                    i = i + 1;
                }

                // Drain all messages
                let drained = 0;
                while get_actor_pending(act) > 0 {
                    recv_from_actor(act);
                    drained = drained + 1;
                }

                return drained;
            }
        "#,
        );
        assert!(matches!(result, Ok(Value::Int(1000))));
    }

    // ========== PROPERTY-BASED TESTS ==========
    // Using proptest for randomized testing of invariants

    use proptest::prelude::*;

    // --- PARSER FUZZ TESTS ---

    proptest! {
        #![proptest_config(ProptestConfig::with_cases(100))]

        #[test]
        fn test_parser_doesnt_crash_on_random_input(s in "\\PC*") {
            // The parser should not panic on any input
            let mut parser = Parser::new(&s);
            let _ = parser.parse_file();  // May error, but shouldn't panic
        }

        #[test]
        fn test_parser_handles_unicode(s in "[\\p{L}\\p{N}\\p{P}\\s]{0,100}") {
            // Parser should handle various unicode gracefully
            let mut parser = Parser::new(&s);
            let _ = parser.parse_file();
        }

        #[test]
        fn test_parser_nested_brackets(depth in 0..20usize) {
            // Deeply nested brackets shouldn't cause stack overflow
            let open: String = (0..depth).map(|_| '(').collect();
            let close: String = (0..depth).map(|_| ')').collect();
            let code = format!("fn main() {{ return {}1{}; }}", open, close);
            let mut parser = Parser::new(&code);
            let _ = parser.parse_file();
        }

        #[test]
        fn test_parser_long_identifiers(len in 1..500usize) {
            // Long identifiers shouldn't cause issues
            let ident: String = (0..len).map(|_| 'a').collect();
            let code = format!("fn main() {{ let {} = 1; return {}; }}", ident, ident);
            let result = eval(&code);
            assert!(matches!(result, Ok(Value::Int(1))));
        }

        #[test]
        fn test_parser_many_arguments(count in 0..50usize) {
            // Many function arguments shouldn't cause issues
            let args: String = (0..count).map(|i| format!("{}", i)).collect::<Vec<_>>().join(", ");
            let code = format!("fn main() {{ return len([{}]); }}", args);
            let result = eval(&code);
            assert!(matches!(result, Ok(Value::Int(c)) if c == count as i64));
        }
    }

    // --- GEOMETRIC ALGEBRA PROPERTY TESTS ---

    proptest! {
        #![proptest_config(ProptestConfig::with_cases(50))]

        #[test]
        fn test_ga_bivector_anticommutative(x1 in -100.0f64..100.0, y1 in -100.0f64..100.0, z1 in -100.0f64..100.0,
                                            x2 in -100.0f64..100.0, y2 in -100.0f64..100.0, z2 in -100.0f64..100.0) {
            // e_i ^ e_j = -e_j ^ e_i (bivector anticommutativity)
            // Test via wedge product: a ^ b = -(b ^ a)
            let code = format!(r#"
                fn main() {{
                    let a = vec3({}, {}, {});
                    let b = vec3({}, {}, {});
                    let ab = vec3_cross(a, b);
                    let ba = vec3_cross(b, a);
                    let diff_x = get(ab, 0) + get(ba, 0);
                    let diff_y = get(ab, 1) + get(ba, 1);
                    let diff_z = get(ab, 2) + get(ba, 2);
                    let eps = 0.001;
                    return eps > abs(diff_x) && eps > abs(diff_y) && eps > abs(diff_z);
                }}
            "#, x1, y1, z1, x2, y2, z2);
            let result = eval(&code);
            assert!(matches!(result, Ok(Value::Bool(true))));
        }

        #[test]
        fn test_vec3_dot_commutative(x1 in -100.0f64..100.0, y1 in -100.0f64..100.0, z1 in -100.0f64..100.0,
                                     x2 in -100.0f64..100.0, y2 in -100.0f64..100.0, z2 in -100.0f64..100.0) {
            // a · b = b · a (dot product commutativity)
            let code = format!(r#"
                fn main() {{
                    let a = vec3({}, {}, {});
                    let b = vec3({}, {}, {});
                    let ab = vec3_dot(a, b);
                    let ba = vec3_dot(b, a);
                    let eps = 0.001;
                    return eps > abs(ab - ba);
                }}
            "#, x1, y1, z1, x2, y2, z2);
            let result = eval(&code);
            assert!(matches!(result, Ok(Value::Bool(true))));
        }

        #[test]
        fn test_quat_identity_preserves_vector(x in -100.0f64..100.0, y in -100.0f64..100.0, z in -100.0f64..100.0) {
            // Rotating by identity quaternion should preserve the vector
            let code = format!(r#"
                fn main() {{
                    let v = vec3({}, {}, {});
                    let q = quat_identity();
                    let rotated = quat_rotate(q, v);
                    let diff_x = abs(get(v, 0) - get(rotated, 0));
                    let diff_y = abs(get(v, 1) - get(rotated, 1));
                    let diff_z = abs(get(v, 2) - get(rotated, 2));
                    let eps = 0.001;
                    return eps > diff_x && eps > diff_y && eps > diff_z;
                }}
            "#, x, y, z);
            let result = eval(&code);
            assert!(matches!(result, Ok(Value::Bool(true))));
        }

        #[test]
        fn test_quat_double_rotation_equals_double_angle(x in -100.0f64..100.0, y in -100.0f64..100.0, z in -100.0f64..100.0,
                                                          angle in -3.14f64..3.14) {
            // q(2θ) should equal q(θ) * q(θ)
            let code = format!(r#"
                fn main() {{
                    let v = vec3({}, {}, {});
                    let axis = vec3(0.0, 1.0, 0.0);
                    let q1 = quat_from_axis_angle(axis, {});
                    let q2 = quat_from_axis_angle(axis, {} * 2.0);
                    let q1q1 = quat_mul(q1, q1);
                    let eps = 0.01;
                    let same = eps > abs(get(q2, 0) - get(q1q1, 0)) &&
                               eps > abs(get(q2, 1) - get(q1q1, 1)) &&
                               eps > abs(get(q2, 2) - get(q1q1, 2)) &&
                               eps > abs(get(q2, 3) - get(q1q1, 3));
                    let neg_same = eps > abs(get(q2, 0) + get(q1q1, 0)) &&
                                   eps > abs(get(q2, 1) + get(q1q1, 1)) &&
                                   eps > abs(get(q2, 2) + get(q1q1, 2)) &&
                                   eps > abs(get(q2, 3) + get(q1q1, 3));
                    return same || neg_same;
                }}
            "#, x, y, z, angle, angle);
            let result = eval(&code);
            assert!(matches!(result, Ok(Value::Bool(true))));
        }

        #[test]
        fn test_vec3_add_associative(x1 in -100.0f64..100.0, y1 in -100.0f64..100.0, z1 in -100.0f64..100.0,
                                     x2 in -100.0f64..100.0, y2 in -100.0f64..100.0, z2 in -100.0f64..100.0,
                                     x3 in -100.0f64..100.0, y3 in -100.0f64..100.0, z3 in -100.0f64..100.0) {
            // (a + b) + c = a + (b + c)
            let code = format!(r#"
                fn main() {{
                    let a = vec3({}, {}, {});
                    let b = vec3({}, {}, {});
                    let c = vec3({}, {}, {});
                    let ab_c = vec3_add(vec3_add(a, b), c);
                    let a_bc = vec3_add(a, vec3_add(b, c));
                    let diff_x = abs(get(ab_c, 0) - get(a_bc, 0));
                    let diff_y = abs(get(ab_c, 1) - get(a_bc, 1));
                    let diff_z = abs(get(ab_c, 2) - get(a_bc, 2));
                    let eps = 0.001;
                    return eps > diff_x && eps > diff_y && eps > diff_z;
                }}
            "#, x1, y1, z1, x2, y2, z2, x3, y3, z3);
            let result = eval(&code);
            assert!(matches!(result, Ok(Value::Bool(true))));
        }

        #[test]
        fn test_vec3_scale_distributive(x in -100.0f64..100.0, y in -100.0f64..100.0, z in -100.0f64..100.0,
                                        s1 in -10.0f64..10.0, s2 in -10.0f64..10.0) {
            // (s1 + s2) * v = s1*v + s2*v
            let code = format!(r#"
                fn main() {{
                    let v = vec3({}, {}, {});
                    let s1 = {};
                    let s2 = {};
                    let combined = vec3_scale(v, s1 + s2);
                    let separate = vec3_add(vec3_scale(v, s1), vec3_scale(v, s2));
                    let diff_x = abs(get(combined, 0) - get(separate, 0));
                    let diff_y = abs(get(combined, 1) - get(separate, 1));
                    let diff_z = abs(get(combined, 2) - get(separate, 2));
                    let eps = 0.01;
                    return eps > diff_x && eps > diff_y && eps > diff_z;
                }}
            "#, x, y, z, s1, s2);
            let result = eval(&code);
            assert!(matches!(result, Ok(Value::Bool(true))));
        }
    }

    // --- AUTODIFF PROPERTY TESTS ---

    proptest! {
        #![proptest_config(ProptestConfig::with_cases(30))]

        #[test]
        fn test_grad_of_constant_is_zero(c in -100.0f64..100.0, x in -100.0f64..100.0) {
            // d/dx(c) = 0
            let code = format!(r#"
                fn main() {{
                    fn constant(x) {{ return {}; }}
                    let g = grad(constant, {});
                    let eps = 0.001;
                    return eps > abs(g);
                }}
            "#, c, x);
            let result = eval(&code);
            assert!(matches!(result, Ok(Value::Bool(true))));
        }

        #[test]
        fn test_grad_of_x_is_one(x in -100.0f64..100.0) {
            // d/dx(x) = 1
            let code = format!(r#"
                fn main() {{
                    fn identity(x) {{ return x; }}
                    let g = grad(identity, {});
                    let eps = 0.001;
                    return eps > abs(g - 1.0);
                }}
            "#, x);
            let result = eval(&code);
            assert!(matches!(result, Ok(Value::Bool(true))));
        }

        #[test]
        fn test_grad_of_x_squared(x in -50.0f64..50.0) {
            // d/dx(x^2) = 2x
            let code = format!(r#"
                fn main() {{
                    fn square(x) {{ return x * x; }}
                    let g = grad(square, {});
                    let expected = 2.0 * {};
                    let eps = 0.1;
                    return eps > abs(g - expected);
                }}
            "#, x, x);
            let result = eval(&code);
            assert!(matches!(result, Ok(Value::Bool(true))));
        }

        #[test]
        fn test_grad_linearity(a in -10.0f64..10.0, b in -10.0f64..10.0, x in -10.0f64..10.0) {
            // d/dx(a*x + b) = a
            let code = format!(r#"
                fn main() {{
                    fn linear(x) {{ return {} * x + {}; }}
                    let g = grad(linear, {});
                    let eps = 0.1;
                    return eps > abs(g - {});
                }}
            "#, a, b, x, a);
            let result = eval(&code);
            assert!(matches!(result, Ok(Value::Bool(true))));
        }
    }

    // --- ARITHMETIC PROPERTY TESTS ---

    proptest! {
        #![proptest_config(ProptestConfig::with_cases(50))]

        #[test]
        fn test_addition_commutative(a in -1000i64..1000, b in -1000i64..1000) {
            let code = format!("fn main() {{ return {} + {} == {} + {}; }}", a, b, b, a);
            let result = eval(&code);
            assert!(matches!(result, Ok(Value::Bool(true))));
        }

        #[test]
        fn test_multiplication_commutative(a in -100i64..100, b in -100i64..100) {
            let code = format!("fn main() {{ return {} * {} == {} * {}; }}", a, b, b, a);
            let result = eval(&code);
            assert!(matches!(result, Ok(Value::Bool(true))));
        }

        #[test]
        fn test_addition_identity(a in -1000i64..1000) {
            let code = format!("fn main() {{ return {} + 0 == {}; }}", a, a);
            let result = eval(&code);
            assert!(matches!(result, Ok(Value::Bool(true))));
        }

        #[test]
        fn test_multiplication_identity(a in -1000i64..1000) {
            let code = format!("fn main() {{ return {} * 1 == {}; }}", a, a);
            let result = eval(&code);
            assert!(matches!(result, Ok(Value::Bool(true))));
        }

        #[test]
        fn test_distributive_property(a in -20i64..20, b in -20i64..20, c in -20i64..20) {
            let code = format!("fn main() {{ return {} * ({} + {}) == {} * {} + {} * {}; }}", a, b, c, a, b, a, c);
            let result = eval(&code);
            assert!(matches!(result, Ok(Value::Bool(true))));
        }
    }

    // --- COLLECTION PROPERTY TESTS ---

    proptest! {
        #![proptest_config(ProptestConfig::with_cases(30))]

        #[test]
        fn test_array_len_after_push(initial_len in 0..20usize, value in -100i64..100) {
            let initial: String = (0..initial_len).map(|i| format!("{}", i)).collect::<Vec<_>>().join(", ");
            let code = format!(r#"
                fn main() {{
                    let arr = [{}];
                    push(arr, {});
                    return len(arr);
                }}
            "#, initial, value);
            let result = eval(&code);
            assert!(matches!(result, Ok(Value::Int(n)) if n == (initial_len + 1) as i64));
        }

        #[test]
        fn test_reverse_reverse_identity(elements in prop::collection::vec(-100i64..100, 0..10)) {
            let arr_str = elements.iter().map(|n| n.to_string()).collect::<Vec<_>>().join(", ");
            let code = format!(r#"
                fn main() {{
                    let arr = [{}];
                    let rev1 = reverse(arr);
                    let rev2 = reverse(rev1);
                    let same = true;
                    let i = 0;
                    while i < len(arr) {{
                        if get(arr, i) != get(rev2, i) {{
                            same = false;
                        }}
                        i = i + 1;
                    }}
                    return same;
                }}
            "#, arr_str);
            let result = eval(&code);
            assert!(matches!(result, Ok(Value::Bool(true))));
        }

        #[test]
        fn test_sum_equals_manual_sum(elements in prop::collection::vec(-100i64..100, 0..20)) {
            let arr_str = elements.iter().map(|n| n.to_string()).collect::<Vec<_>>().join(", ");
            let expected_sum: i64 = elements.iter().sum();
            let code = format!("fn main() {{ return sum([{}]); }}", arr_str);
            let result = eval(&code);
            assert!(matches!(result, Ok(Value::Int(n)) if n == expected_sum));
        }
    }

    // ============================================================================
    // MEMORY LEAK TESTS
    // These tests verify that repeated operations don't cause memory leaks.
    // They run operations many times and check that the interpreter completes
    // without running out of memory or panicking.
    // ============================================================================

    #[test]
    fn test_no_leak_repeated_array_operations() {
        // Create and discard arrays many times
        let result = eval(
            r#"
            fn main() {
                let i = 0;
                while i < 1000 {
                    let arr = [1, 2, 3, 4, 5];
                    push(arr, 6);
                    let rev = reverse(arr);
                    let s = sum(arr);
                    i = i + 1;
                }
                return i;
            }
        "#,
        );
        assert!(matches!(result, Ok(Value::Int(1000))));
    }

    #[test]
    fn test_no_leak_repeated_function_calls() {
        // Call functions many times to test function frame cleanup
        let result = eval(
            r#"
            fn fib(n) {
                if n <= 1 { return n; }
                return fib(n - 1) + fib(n - 2);
            }
            fn main() {
                let i = 0;
                let total = 0;
                while i < 100 {
                    total = total + fib(10);
                    i = i + 1;
                }
                return total;
            }
        "#,
        );
        assert!(matches!(result, Ok(Value::Int(5500))));
    }

    #[test]
    fn test_no_leak_repeated_map_operations() {
        // Create and discard maps many times
        let result = eval(
            r#"
            fn main() {
                let i = 0;
                while i < 500 {
                    let m = map_new();
                    map_set(m, "key1", 1);
                    map_set(m, "key2", 2);
                    map_set(m, "key3", 3);
                    let v = map_get(m, "key1");
                    i = i + 1;
                }
                return i;
            }
        "#,
        );
        assert!(matches!(result, Ok(Value::Int(500))));
    }

    #[test]
    fn test_no_leak_repeated_string_operations() {
        // Create and discard strings many times
        let result = eval(
            r#"
            fn main() {
                let i = 0;
                while i < 1000 {
                    let s = "hello world";
                    let upper_s = upper(s);
                    let lower_s = lower(upper_s);
                    let concat_s = s ++ " " ++ upper_s;
                    let replaced = replace(concat_s, "o", "0");
                    i = i + 1;
                }
                return i;
            }
        "#,
        );
        assert!(matches!(result, Ok(Value::Int(1000))));
    }

    #[test]
    fn test_no_leak_repeated_ecs_operations() {
        // Create and discard ECS entities many times
        let result = eval(
            r#"
            fn main() {
                let world = ecs_world();
                let i = 0;
                while i < 500 {
                    let entity = ecs_spawn(world);
                    ecs_attach(world, entity, "Position", vec3(1.0, 2.0, 3.0));
                    ecs_attach(world, entity, "Velocity", vec3(0.0, 0.0, 0.0));
                    let pos = ecs_get(world, entity, "Position");
                    i = i + 1;
                }
                return i;
            }
        "#,
        );
        assert!(matches!(result, Ok(Value::Int(500))));
    }

    #[test]
    fn test_no_leak_repeated_channel_operations() {
        // Create and use channels many times
        let result = eval(
            r#"
            fn main() {
                let i = 0;
                while i < 500 {
                    let ch = channel_new();
                    channel_send(ch, i);
                    channel_send(ch, i + 1);
                    let v1 = channel_recv(ch);
                    let v2 = channel_recv(ch);
                    i = i + 1;
                }
                return i;
            }
        "#,
        );
        assert!(matches!(result, Ok(Value::Int(500))));
    }

    #[test]
    fn test_no_leak_repeated_actor_operations() {
        // Create actors and send messages many times
        let result = eval(
            r#"
            fn main() {
                let i = 0;
                while i < 100 {
                    let act = spawn_actor("leak_test_actor");
                    send_to_actor(act, "msg", i);
                    send_to_actor(act, "msg", i + 1);
                    let count = get_actor_msg_count(act);
                    i = i + 1;
                }
                return i;
            }
        "#,
        );
        assert!(matches!(result, Ok(Value::Int(100))));
    }

    #[test]
    fn test_no_leak_repeated_vec3_operations() {
        // Create and compute with vec3s many times
        let result = eval(
            r#"
            fn main() {
                let i = 0;
                while i < 1000 {
                    let v1 = vec3(1.0, 2.0, 3.0);
                    let v2 = vec3(4.0, 5.0, 6.0);
                    let added = vec3_add(v1, v2);
                    let scaled = vec3_scale(added, 2.0);
                    let dot = vec3_dot(v1, v2);
                    let crossed = vec3_cross(v1, v2);
                    let normalized = vec3_normalize(crossed);
                    i = i + 1;
                }
                return i;
            }
        "#,
        );
        assert!(matches!(result, Ok(Value::Int(1000))));
    }

    #[test]
    fn test_no_leak_repeated_closure_creation() {
        // Create and call closures many times
        let result = eval(
            r#"
            fn main() {
                let i = 0;
                let total = 0;
                while i < 500 {
                    let x = i;
                    fn add_x(y) { return x + y; }
                    total = total + add_x(1);
                    i = i + 1;
                }
                return total;
            }
        "#,
        );
        // Sum of (i+1) for i from 0 to 499 = sum of 1 to 500 = 500*501/2 = 125250
        assert!(matches!(result, Ok(Value::Int(125250))));
    }

    #[test]
    fn test_no_leak_nested_data_structures() {
        // Create nested arrays and maps many times
        let result = eval(
            r#"
            fn main() {
                let i = 0;
                while i < 200 {
                    let inner1 = [1, 2, 3];
                    let inner2 = [4, 5, 6];
                    let outer = [inner1, inner2];
                    let m = map_new();
                    map_set(m, "arr", outer);
                    map_set(m, "nested", map_new());
                    i = i + 1;
                }
                return i;
            }
        "#,
        );
        assert!(matches!(result, Ok(Value::Int(200))));
    }

    #[test]
    fn test_no_leak_repeated_interpreter_creation() {
        // This tests at the Rust level - creating multiple interpreters
        for _ in 0..50 {
            let result = eval(
                r#"
                fn main() {
                    let arr = [1, 2, 3, 4, 5];
                    let total = sum(arr);
                    return total * 2;
                }
            "#,
            );
            assert!(matches!(result, Ok(Value::Int(30))));
        }
    }
}
